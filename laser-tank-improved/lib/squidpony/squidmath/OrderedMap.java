/*
 * Copyright (C) 2002-2015 Sebastiano Vigna
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package squidpony.squidmath;

import java.io.Serializable;
import java.util.AbstractCollection;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;

import squidpony.annotation.GwtIncompatible;

/**
 * A generic linked hash map with with a fast implementation, originally from
 * fastutil as Object2ObjectLinkedOpenHashMap but modified to support indexed
 * access of keys, values, and entries, reordering, and optional hash strategies
 * for array keys (which fastutil does differently). <br>
 * <p>
 * Instances of this class use a hash table to represent a map. The table is
 * filled up to a specified <em>load factor</em>, and then doubled in size to
 * accommodate new entries. If the table is emptied below <em>one fourth</em> of
 * the load factor, it is halved in size. However, halving is not performed when
 * deleting entries from an iterator, as it would interfere with the iteration
 * process.
 * </p>
 * <p>
 * Note that {@link #clear()} does not modify the hash table size. Rather, a
 * family of {@linkplain #trim() trimming methods} lets you control the size of
 * the table; this is particularly useful if you reuse instances of this class.
 * </p>
 * <p>
 * Iterators generated by this map will enumerate pairs in the same order in
 * which they have been added to the map (addition of pairs whose key is already
 * present in the set does not change the iteration order). Note that this order
 * has nothing in common with the natural order of the keys. The order is kept
 * by means of a int-specialized list, {@link IntVLA}, and is modifiable with
 * this class' {@link #reorder(int...)} and {@link #shuffle(RNG)} methods, among
 * other tools.
 * </p>
 * <p>
 * This class implements the interface of a sorted map, so to allow easy access
 * of the iteration order: for instance, you can get the first key in iteration
 * order with {@code firstKey()} without having to create an iterator; however,
 * this class partially violates the {@link SortedMap} contract because all
 * submap methods throw an exception and {@link #comparator()} returns always
 * <code>null</code>.
 * </p>
 * <p>
 * Additional methods, such as <code>getAndMoveToFirst()</code>, make it easy to
 * use instances of this class as a cache (e.g., with LRU policy).
 * </p>
 * <p>
 * This class allows approximately constant-time lookup of keys or values by
 * their index in the ordering, which can allow some novel usage of the data
 * structure. {@link OrderedSet} can be used like a list of unique elements,
 * keeping order like a list does but also allowing rapid checks for whether an
 * item exists in the OrderedSet, and OrderedMap can be used like that but with
 * values associated as well (where OrderedSet uses contains(), OrderedMap uses
 * containsKey()). You can also set the key and value at a position with
 * {@link #putAt(Object, Object, int)}, or alter the key while keeping its value
 * and index the same with {@link #alter(Object, Object)}. Reordering works here
 * too, both with completely random orders from {@link #shuffle(RNG)} or with a
 * previously-generated ordering from {@link #reorder(int...)} (you can produce
 * such an ordering for a given size and reuse it across multiple Ordered data
 * structures with {@link RNG#randomOrdering(int)}).
 * </p>
 * <p>
 * You can pass an {@link CrossHash.IHasher} instance such as
 * {@link CrossHash#generalHasher} as an extra parameter to most of this class'
 * constructors, which allows the OrderedMap to use arrays (usually primitive
 * arrays) as keys. If you expect only one type of array, you can use an
 * instance like {@link CrossHash#intHasher} to hash int arrays, or the
 * aforementioned generalHasher to hash most kinds of arrays (it can't handle
 * most multi-dimensional arrays well). If you aren't using arrays as keys, you
 * don't need to give an IHasher to the constructor and can ignore this feature.
 * </p>
 * <br>
 * Thank you, Sebastiano Vigna, for making FastUtil available to the public with
 * such high quality. <br>
 * See https://github.com/vigna/fastutil for the original library.
 *
 * @author Sebastiano Vigna (responsible for all the hard parts)
 * @author Tommy Ettinger (mostly responsible for squashing several layers of
 *         parent classes into one monster class)
 */
public class OrderedMap<K, V> implements SortedMap<K, V>, java.io.Serializable, Cloneable {
    private static final long serialVersionUID = 0L;
    /**
     * The array of keys.
     */
    protected K[] key;
    /**
     * The array of values.
     */
    protected V[] value;
    /**
     * The mask for wrapping a position counter.
     */
    protected int mask;
    /**
     * Whether this set contains the key zero.
     */
    protected boolean containsNullKey;
    /**
     * The index of the first entry in iteration order. It is valid iff
     * {@link #size} is nonzero; otherwise, it contains -1.
     */
    protected int first = -1;
    /**
     * The index of the last entry in iteration order. It is valid iff {@link #size}
     * is nonzero; otherwise, it contains -1.
     */
    protected int last = -1;
    /*
     * For each entry, the next and the previous entry in iteration order, stored as
     * <code>((prev & 0xFFFFFFFFL) << 32) | (next & 0xFFFFFFFFL)</code>. The first
     * entry contains predecessor -1, and the last entry contains successor -1.
     */
    // protected long[] link;
    protected IntVLA order;
    /**
     * The current table size.
     */
    protected int n;
    /**
     * Threshold after which we rehash. It must be the table size times {@link #f}.
     */
    protected int maxFill;
    /**
     * Number of entries in the set (including the key zero, if present).
     */
    protected int size;
    /**
     * The acceptable load factor.
     */
    public final float f;
    /**
     * Cached set of entries.
     */
    protected volatile MapEntrySet entries;
    /**
     * Cached set of keys.
     */
    protected volatile KeySet keys;
    /**
     * Cached collection of values.
     */
    protected volatile Collection<V> values;
    /**
     * Default return value.
     */
    protected V defRetValue = null;
    /**
     * The initial default size of a hash table.
     */
    public static final int DEFAULT_INITIAL_SIZE = 16;
    /**
     * The default load factor of a hash table.
     */
    public static final float DEFAULT_LOAD_FACTOR = .75f; // .1875f; // .75f;
    /**
     * The load factor for a (usually small) table that is meant to be particularly
     * fast.
     */
    public static final float FAST_LOAD_FACTOR = .5f;
    /**
     * The load factor for a (usually very small) table that is meant to be
     * extremely fast.
     */
    public static final float VERY_FAST_LOAD_FACTOR = .25f;
    protected CrossHash.IHasher hasher = null;

    public void defaultReturnValue(final V rv) {
	this.defRetValue = rv;
    }

    public V defaultReturnValue() {
	return this.defRetValue;
    }

    /**
     * Creates a new OrderedMap.
     * <p>
     * <p>
     * The actual table size will be the least power of two greater than
     * <code>expected</code>/<code>f</code>.
     *
     * @param expected the expected number of elements in the hash set.
     * @param f        the load factor.
     */
    @SuppressWarnings("unchecked")
    public OrderedMap(final int expected, final float f) {
	if (f <= 0 || f > 1) {
	    throw new IllegalArgumentException("Load factor must be greater than 0 and smaller than or equal to 1");
	}
	if (expected < 0) {
	    throw new IllegalArgumentException("The expected number of elements must be nonnegative");
	}
	this.f = f;
	this.n = OrderedMap.arraySize(expected, f);
	this.mask = this.n - 1;
	this.maxFill = OrderedMap.maxFill(this.n, f);
	this.key = (K[]) new Object[this.n + 1];
	this.value = (V[]) new Object[this.n + 1];
	// link = new long[n + 1];
	this.order = new IntVLA(expected);
	this.hasher = CrossHash.defaultHasher;
    }

    /**
     * Creates a new OrderedMap with 0.75f as load factor.
     *
     * @param expected the expected number of elements in the OrderedMap.
     */
    public OrderedMap(final int expected) {
	this(expected, OrderedMap.DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new OrderedMap with initial expected 16 entries and 0.75f as load
     * factor.
     */
    public OrderedMap() {
	this(OrderedMap.DEFAULT_INITIAL_SIZE, OrderedMap.DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new OrderedMap copying a given one.
     *
     * @param m a {@link Map} to be copied into the new OrderedMap.
     * @param f the load factor.
     */
    public OrderedMap(final Map<? extends K, ? extends V> m, final float f) {
	this(m.size(), f, m instanceof OrderedMap ? ((OrderedMap) m).hasher : CrossHash.defaultHasher);
	this.putAll(m);
    }

    /**
     * Creates a new OrderedMap with 0.75f as load factor copying a given one.
     *
     * @param m a {@link Map} to be copied into the new OrderedMap.
     */
    public OrderedMap(final Map<? extends K, ? extends V> m) {
	this(m, m instanceof OrderedMap ? ((OrderedMap) m).f : OrderedMap.DEFAULT_LOAD_FACTOR,
		m instanceof OrderedMap ? ((OrderedMap) m).hasher : CrossHash.defaultHasher);
    }

    /**
     * Creates a new OrderedMap using the elements of two parallel arrays.
     *
     * @param keyArray   the array of keys of the new OrderedMap.
     * @param valueArray the array of corresponding values in the new OrderedMap.
     * @param f          the load factor.
     * @throws IllegalArgumentException if <code>k</code> and <code>v</code> have
     *                                  different lengths.
     */
    public OrderedMap(final K[] keyArray, final V[] valueArray, final float f) {
	this(keyArray.length, f);
	if (keyArray.length != valueArray.length) {
	    throw new IllegalArgumentException("The key array and the value array have different lengths ("
		    + keyArray.length + " and " + valueArray.length + ")");
	}
	for (int i = 0; i < keyArray.length; i++) {
	    this.put(keyArray[i], valueArray[i]);
	}
    }

    /**
     * Creates a new OrderedMap using the elements of two parallel arrays.
     *
     * @param keyColl   the collection of keys of the new OrderedMap.
     * @param valueColl the collection of corresponding values in the new
     *                  OrderedMap.
     * @param f         the load factor.
     * @throws IllegalArgumentException if <code>k</code> and <code>v</code> have
     *                                  different lengths.
     */
    public OrderedMap(final Collection<K> keyColl, final Collection<V> valueColl, final float f) {
	this(keyColl.size(), f);
	if (keyColl.size() != valueColl.size()) {
	    throw new IllegalArgumentException("The key array and the value array have different lengths ("
		    + keyColl.size() + " and " + valueColl.size() + ")");
	}
	final Iterator<K> ki = keyColl.iterator();
	final Iterator<V> vi = valueColl.iterator();
	while (ki.hasNext() && vi.hasNext()) {
	    this.put(ki.next(), vi.next());
	}
    }

    /**
     * Creates a new OrderedMap with 0.75f as load factor using the elements of two
     * parallel arrays.
     *
     * @param keyArray   the array of keys of the new OrderedMap.
     * @param valueArray the array of corresponding values in the new OrderedMap.
     * @throws IllegalArgumentException if <code>k</code> and <code>v</code> have
     *                                  different lengths.
     */
    public OrderedMap(final K[] keyArray, final V[] valueArray) {
	this(keyArray, valueArray, OrderedMap.DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new OrderedMap.
     * <p>
     * <p>
     * The actual table size will be the least power of two greater than
     * <code>expected</code>/<code>f</code>.
     *
     * @param expected the expected number of elements in the hash set.
     * @param f        the load factor.
     * @param hasher   used to hash items; typically only needed when K is an array,
     *                 where CrossHash has implementations
     */
    @SuppressWarnings("unchecked")
    public OrderedMap(final int expected, final float f, final CrossHash.IHasher hasher) {
	if (f <= 0 || f > 1) {
	    throw new IllegalArgumentException("Load factor must be greater than 0 and smaller than or equal to 1");
	}
	if (expected < 0) {
	    throw new IllegalArgumentException("The expected number of elements must be nonnegative");
	}
	this.f = f;
	this.n = OrderedMap.arraySize(expected, f);
	this.mask = this.n - 1;
	this.maxFill = OrderedMap.maxFill(this.n, f);
	this.key = (K[]) new Object[this.n + 1];
	this.value = (V[]) new Object[this.n + 1];
	// link = new long[n + 1];
	this.order = new IntVLA(expected);
	this.hasher = hasher == null ? CrossHash.defaultHasher : hasher;
    }

    /**
     * Creates a new OrderedMap with 0.75f as load factor.
     *
     * @param expected the expected number of elements in the OrderedMap.
     * @param hasher   used to hash items; typically only needed when K is an array,
     *                 where CrossHash has implementations
     */
    public OrderedMap(final int expected, final CrossHash.IHasher hasher) {
	this(expected, OrderedMap.DEFAULT_LOAD_FACTOR, hasher);
    }

    /**
     * Creates a new OrderedMap with initial expected 16 entries and 0.75f as load
     * factor.
     */
    public OrderedMap(final CrossHash.IHasher hasher) {
	this(OrderedMap.DEFAULT_INITIAL_SIZE, OrderedMap.DEFAULT_LOAD_FACTOR, hasher);
    }

    /**
     * Creates a new OrderedMap copying a given one.
     *
     * @param m      a {@link Map} to be copied into the new OrderedMap.
     * @param f      the load factor.
     * @param hasher used to hash items; typically only needed when K is an array,
     *               where CrossHash has implementations
     */
    public OrderedMap(final Map<? extends K, ? extends V> m, final float f, final CrossHash.IHasher hasher) {
	this(m.size(), f, hasher);
	this.putAll(m);
    }

    /**
     * Creates a new OrderedMap with 0.75f as load factor copying a given one.
     *
     * @param m      a {@link Map} to be copied into the new OrderedMap.
     * @param hasher used to hash items; typically only needed when K is an array,
     *               where CrossHash has implementations
     */
    public OrderedMap(final Map<? extends K, ? extends V> m, final CrossHash.IHasher hasher) {
	this(m, OrderedMap.DEFAULT_LOAD_FACTOR, hasher);
    }

    /**
     * Creates a new OrderedMap using the elements of two parallel arrays.
     *
     * @param keyArray   the array of keys of the new OrderedMap.
     * @param valueArray the array of corresponding values in the new OrderedMap.
     * @param f          the load factor.
     * @param hasher     used to hash items; typically only needed when K is an
     *                   array, where CrossHash has implementations
     * @throws IllegalArgumentException if <code>k</code> and <code>v</code> have
     *                                  different lengths.
     */
    public OrderedMap(final K[] keyArray, final V[] valueArray, final float f, final CrossHash.IHasher hasher) {
	this(keyArray.length, f, hasher);
	if (keyArray.length != valueArray.length) {
	    throw new IllegalArgumentException("The key array and the value array have different lengths ("
		    + keyArray.length + " and " + valueArray.length + ")");
	}
	for (int i = 0; i < keyArray.length; i++) {
	    this.put(keyArray[i], valueArray[i]);
	}
    }

    /**
     * Creates a new OrderedMap with 0.75f as load factor using the elements of two
     * parallel arrays.
     *
     * @param keyArray   the array of keys of the new OrderedMap.
     * @param valueArray the array of corresponding values in the new OrderedMap.
     * @param hasher     used to hash items; typically only needed when K is an
     *                   array, where CrossHash has implementations
     * @throws IllegalArgumentException if <code>k</code> and <code>v</code> have
     *                                  different lengths.
     */
    public OrderedMap(final K[] keyArray, final V[] valueArray, final CrossHash.IHasher hasher) {
	this(keyArray, valueArray, OrderedMap.DEFAULT_LOAD_FACTOR, hasher);
    }

    private int realSize() {
	return this.containsNullKey ? this.size - 1 : this.size;
    }

    private void ensureCapacity(final int capacity) {
	final int needed = OrderedMap.arraySize(capacity, this.f);
	if (needed > this.n) {
	    this.rehash(needed);
	}
    }

    private void tryCapacity(final long capacity) {
	final int needed = (int) Math.min(1 << 30,
		Math.max(2, HashCommon.nextPowerOfTwo((long) Math.ceil(capacity / this.f))));
	if (needed > this.n) {
	    this.rehash(needed);
	}
    }

    private V removeEntry(final int pos) {
	final V oldValue = this.value[pos];
	this.value[pos] = null;
	this.size--;
	this.fixOrder(pos);
	this.shiftKeys(pos);
	if (this.size < this.maxFill / 4 && this.n > OrderedMap.DEFAULT_INITIAL_SIZE) {
	    this.rehash(this.n / 2);
	}
	return oldValue;
    }

    private V removeNullEntry() {
	this.containsNullKey = false;
	this.key[this.n] = null;
	final V oldValue = this.value[this.n];
	this.value[this.n] = null;
	this.size--;
	this.fixOrder(this.n);
	if (this.size < this.maxFill / 4 && this.n > OrderedMap.DEFAULT_INITIAL_SIZE) {
	    this.rehash(this.n / 2);
	}
	return oldValue;
    }

    /**
     * Puts the first key in keyArray with the first value in valueArray, then the
     * second in each and so on. The entries are all appended to the end of the
     * iteration order, unless a key was already present. Then, its value is changed
     * at the existing position in the iteration order. If the lengths of the two
     * arrays are not equal, this puts a number of entries equal to the lesser
     * length. If either array is null, this returns without performing any changes.
     *
     * @param keyArray   an array of K keys that should usually have the same length
     *                   as valueArray
     * @param valueArray an array of V values that should usually have the same
     *                   length as keyArray
     */
    public void putAll(final K[] keyArray, final V[] valueArray) {
	if (keyArray == null || valueArray == null) {
	    return;
	}
	for (int i = 0; i < keyArray.length && i < valueArray.length; i++) {
	    this.put(keyArray[i], valueArray[i]);
	}
    }

    /**
     * Puts all key-value pairs in the Map m into this OrderedMap. The entries are
     * all appended to the end of the iteration order, unless a key was already
     * present. Then, its value is changed at the existing position in the iteration
     * order. This can take any kind of Map, including unordered HashMap objects; if
     * the Map does not have stable ordering, the order in which entries will be
     * appended is not stable either. For this reason, OrderedMap, LinkedHashMap,
     * and TreeMap (or other SortedMap implementations) will work best when order
     * matters.
     *
     * @param m a Map that should have the same or compatible K key and V value
     *          types; OrderedMap and TreeMap work best
     */
    @Override
    public void putAll(final Map<? extends K, ? extends V> m) {
	if (this.f <= .5) {
	    this.ensureCapacity(m.size()); // The resulting map will be sized for
	    // m.size() elements
	} else {
	    this.tryCapacity(this.size() + m.size()); // The resulting map will be
	}
	int n = m.size();
	final Iterator<? extends Map.Entry<? extends K, ? extends V>> i = m.entrySet().iterator();
	if (m instanceof OrderedMap) {
	    Entry<? extends K, ? extends V> e;
	    while (n-- != 0) {
		e = i.next();
		this.put(e.getKey(), e.getValue());
	    }
	} else {
	    Map.Entry<? extends K, ? extends V> e;
	    while (n-- != 0) {
		e = i.next();
		this.put(e.getKey(), e.getValue());
	    }
	}
    }

    private int insert(final K k, final V v) {
	int pos;
	if (k == null) {
	    if (this.containsNullKey) {
		return this.n;
	    }
	    this.containsNullKey = true;
	    pos = this.n;
	} else {
	    K curr;
	    final K[] key = this.key;
	    // The starting point.
	    if ((curr = key[pos = HashCommon.mix(this.hasher.hash(k)) & this.mask]) != null) {
		if (this.hasher.areEqual(curr, k)) {
		    return pos;
		}
		while ((curr = key[pos = pos + 1 & this.mask]) != null) {
		    if (this.hasher.areEqual(curr, k)) {
			return pos;
		    }
		}
	    }
	}
	this.key[pos] = k;
	this.value[pos] = v;
	if (this.size == 0) {
	    this.first = this.last = pos;
	} else {
	    this.last = pos;
	}
	this.order.add(pos);
	if (this.size++ >= this.maxFill) {
	    this.rehash(OrderedMap.arraySize(this.size + 1, this.f));
	}
	return -1;
    }

    private int insertAt(final K k, final V v, final int idx) {
	int pos;
	if (k == null) {
	    if (this.containsNullKey) {
		this.fixOrder(this.n);
		this.order.insert(idx, this.n);
		return this.n;
	    }
	    this.containsNullKey = true;
	    pos = this.n;
	} else {
	    K curr;
	    final K[] key = this.key;
	    // The starting point.
	    if ((curr = key[pos = HashCommon.mix(this.hasher.hash(k)) & this.mask]) != null) {
		if (this.hasher.areEqual(curr, k)) {
		    this.fixOrder(pos);
		    this.order.insert(idx, pos);
		    return pos;
		}
		while ((curr = key[pos = pos + 1 & this.mask]) != null) {
		    if (this.hasher.areEqual(curr, k)) {
			this.fixOrder(pos);
			this.order.insert(idx, pos);
			return pos;
		    }
		}
	    }
	}
	this.key[pos] = k;
	this.value[pos] = v;
	if (this.size == 0) {
	    this.first = this.last = pos;
	}
	this.order.insert(idx, pos);
	if (this.size++ >= this.maxFill) {
	    this.rehash(OrderedMap.arraySize(this.size + 1, this.f));
	}
	return -1;
    }

    @Override
    public V put(final K k, final V v) {
	final int pos = this.insert(k, v);
	if (pos < 0) {
	    return this.defRetValue;
	}
	final V oldValue = this.value[pos];
	this.value[pos] = v;
	return oldValue;
    }

    public V putAt(final K k, final V v, final int idx) {
	if (idx <= 0) {
	    return this.putAndMoveToFirst(k, v);
	} else if (idx >= this.size) {
	    return this.putAndMoveToLast(k, v);
	}
	final int pos = this.insertAt(k, v, idx);
	if (pos < 0) {
	    return this.defRetValue;
	}
	final V oldValue = this.value[pos];
	this.value[pos] = v;
	return oldValue;
    }

    /**
     * Shifts left entries with the specified hash code, starting at the specified
     * position, and empties the resulting free entry.
     *
     * @param pos a starting position.
     */
    protected final void shiftKeys(int pos) {
	// Shift entries with the same hash.
	int last, slot;
	K curr;
	final K[] key = this.key;
	for (;;) {
	    pos = (last = pos) + 1 & this.mask;
	    for (;;) {
		if ((curr = key[pos]) == null) {
		    key[last] = null;
		    this.value[last] = null;
		    return;
		}
		slot = HashCommon.mix(this.hasher.hash(curr)) & this.mask;
		if (last <= pos ? last >= slot || slot > pos : last >= slot && slot > pos) {
		    break;
		}
		pos = pos + 1 & this.mask;
	    }
	    key[last] = curr;
	    this.value[last] = this.value[pos];
	    this.fixOrder(pos, last);
	}
    }

    @Override
    @SuppressWarnings("unchecked")
    public V remove(final Object k) {
	if ((K) k == null) {
	    if (this.containsNullKey) {
		return this.removeNullEntry();
	    }
	    return this.defRetValue;
	}
	K curr;
	final K[] key = this.key;
	int pos;
	// The starting point.
	if ((curr = key[pos = HashCommon.mix(this.hasher.hash(k)) & this.mask]) == null) {
	    return this.defRetValue;
	}
	if (this.hasher.areEqual(k, curr)) {
	    return this.removeEntry(pos);
	}
	while (true) {
	    if ((curr = key[pos = pos + 1 & this.mask]) == null) {
		return this.defRetValue;
	    }
	    if (this.hasher.areEqual(k, curr)) {
		return this.removeEntry(pos);
	    }
	}
    }

    private V setValue(final int pos, final V v) {
	final V oldValue = this.value[pos];
	this.value[pos] = v;
	return oldValue;
    }

    /**
     * Removes the mapping associated with the first key in iteration order.
     *
     * @return the value previously associated with the first key in iteration
     *         order.
     * @throws NoSuchElementException is this map is empty.
     */
    public V removeFirst() {
	if (this.size == 0) {
	    throw new NoSuchElementException();
	}
	final int pos = this.first;
	this.order.removeIndex(0);
	if (this.order.size > 0) {
	    this.first = this.order.get(0);
	} else {
	    this.first = -1;
	}
	this.size--;
	final V v = this.value[pos];
	if (pos == this.n) {
	    this.containsNullKey = false;
	    this.key[this.n] = null;
	    this.value[this.n] = null;
	} else {
	    this.shiftKeys(pos);
	}
	if (this.size < this.maxFill / 4 && this.n > OrderedMap.DEFAULT_INITIAL_SIZE) {
	    this.rehash(this.n / 2);
	}
	return v;
    }

    /**
     * Removes the mapping associated with the last key in iteration order.
     *
     * @return the value previously associated with the last key in iteration order.
     * @throws NoSuchElementException is this map is empty.
     */
    public V removeLast() {
	if (this.size == 0) {
	    throw new NoSuchElementException();
	}
	final int pos = this.last;
	this.order.pop();
	if (this.order.size > 0) {
	    this.last = this.order.get(this.order.size - 1);
	} else {
	    this.last = -1;
	}
	this.size--;
	final V v = this.value[pos];
	if (pos == this.n) {
	    this.containsNullKey = false;
	    this.key[this.n] = null;
	    this.value[this.n] = null;
	} else {
	    this.shiftKeys(pos);
	}
	if (this.size < this.maxFill / 4 && this.n > OrderedMap.DEFAULT_INITIAL_SIZE) {
	    this.rehash(this.n / 2);
	}
	return v;
    }

    private void moveIndexToFirst(final int i) {
	if (this.size <= 1 || this.first == i) {
	    return;
	}
	this.order.moveToFirst(i);
	if (this.last == i) {
	    this.last = this.order.peek();
	    // last = (int) (link[i] >>> 32);
	    // Special case of SET_NEXT( link[ last ], -1 );
	    // link[last] |= -1 & 0xFFFFFFFFL;
	} /*
	   * else { final long linki = link[i]; final int prev = (int) (linki >>> 32);
	   * final int next = (int) linki; link[prev] ^= ((link[prev] ^ (linki &
	   * 0xFFFFFFFFL)) & 0xFFFFFFFFL); link[next] ^= ((link[next] ^ (linki &
	   * 0xFFFFFFFF00000000L)) & 0xFFFFFFFF00000000L); } link[first] ^= ((link[first]
	   * ^ ((i & 0xFFFFFFFFL) << 32)) & 0xFFFFFFFF00000000L); link[i] = ((-1 &
	   * 0xFFFFFFFFL) << 32) | (first & 0xFFFFFFFFL);
	   */
	this.first = i;
    }

    private void moveIndexToLast(final int i) {
	if (this.size <= 1 || this.last == i) {
	    return;
	}
	this.order.moveToLast(i);
	if (this.first == i) {
	    this.first = this.order.get(0);
	    // first = (int) link[i];
	    // Special case of SET_PREV( link[ first ], -1 );
	    // link[first] |= (-1 & 0xFFFFFFFFL) << 32;
	} /*
	   * else { final long linki = link[i]; final int prev = (int) (linki >>> 32);
	   * final int next = (int) linki; link[prev] ^= ((link[prev] ^ (linki &
	   * 0xFFFFFFFFL)) & 0xFFFFFFFFL); link[next] ^= ((link[next] ^ (linki &
	   * 0xFFFFFFFF00000000L)) & 0xFFFFFFFF00000000L); } link[last] ^= ((link[last] ^
	   * (i & 0xFFFFFFFFL)) & 0xFFFFFFFFL); link[i] = ((last & 0xFFFFFFFFL) << 32) |
	   * (-1 & 0xFFFFFFFFL);
	   */
	this.last = i;
    }

    /**
     * Returns the value to which the given key is mapped; if the key is present, it
     * is moved to the first position of the iteration order.
     *
     * @param k the key.
     * @return the corresponding value, or the {@linkplain #defaultReturnValue()
     *         default return value} if no value was present for the given key.
     */
    public V getAndMoveToFirst(final K k) {
	if (k == null) {
	    if (this.containsNullKey) {
		this.moveIndexToFirst(this.n);
		return this.value[this.n];
	    }
	    return this.defRetValue;
	}
	K curr;
	final K[] key = this.key;
	int pos;
	// The starting point.
	if ((curr = key[pos = HashCommon.mix(this.hasher.hash(k)) & this.mask]) == null) {
	    return this.defRetValue;
	}
	if (this.hasher.areEqual(k, curr)) {
	    this.moveIndexToFirst(pos);
	    return this.value[pos];
	}
	// There's always an unused entry.
	while (true) {
	    if ((curr = key[pos = pos + 1 & this.mask]) == null) {
		return this.defRetValue;
	    }
	    if (this.hasher.areEqual(k, curr)) {
		this.moveIndexToFirst(pos);
		return this.value[pos];
	    }
	}
    }

    /**
     * Returns the value to which the given key is mapped; if the key is present, it
     * is moved to the last position of the iteration order.
     *
     * @param k the key.
     * @return the corresponding value, or the {@linkplain #defaultReturnValue()
     *         default return value} if no value was present for the given key.
     */
    public V getAndMoveToLast(final K k) {
	if (k == null) {
	    if (this.containsNullKey) {
		this.moveIndexToLast(this.n);
		return this.value[this.n];
	    }
	    return this.defRetValue;
	}
	K curr;
	final K[] key = this.key;
	int pos;
	// The starting point.
	if ((curr = key[pos = HashCommon.mix(this.hasher.hash(k)) & this.mask]) == null) {
	    return this.defRetValue;
	}
	if (this.hasher.areEqual(k, curr)) {
	    this.moveIndexToLast(pos);
	    return this.value[pos];
	}
	// There's always an unused entry.
	while (true) {
	    if ((curr = key[pos = pos + 1 & this.mask]) == null) {
		return this.defRetValue;
	    }
	    if (this.hasher.areEqual(k, curr)) {
		this.moveIndexToLast(pos);
		return this.value[pos];
	    }
	}
    }

    /**
     * Adds a pair to the map; if the key is already present, it is moved to the
     * first position of the iteration order.
     *
     * @param k the key.
     * @param v the value.
     * @return the old value, or the {@linkplain #defaultReturnValue() default
     *         return value} if no value was present for the given key.
     */
    public V putAndMoveToFirst(final K k, final V v) {
	int pos;
	if (k == null) {
	    if (this.containsNullKey) {
		this.moveIndexToFirst(this.n);
		return this.setValue(this.n, v);
	    }
	    this.containsNullKey = true;
	    pos = this.n;
	} else {
	    K curr;
	    final K[] key = this.key;
	    // The starting point.
	    if (!((curr = key[pos = HashCommon.mix(this.hasher.hash(k)) & this.mask]) == null)) {
		if (this.hasher.areEqual(curr, k)) {
		    this.moveIndexToFirst(pos);
		    return this.setValue(pos, v);
		}
		while (!((curr = key[pos = pos + 1 & this.mask]) == null)) {
		    if (this.hasher.areEqual(curr, k)) {
			this.moveIndexToFirst(pos);
			return this.setValue(pos, v);
		    }
		}
	    }
	}
	this.key[pos] = k;
	this.value[pos] = v;
	if (this.size == 0) {
	    this.first = this.last = pos;
	    // Special case of SET_UPPER_LOWER( link[ pos ], -1, -1 );
	    // link[pos] = -1L;
	} else {
	    // link[first] ^= ((link[first] ^ ((pos & 0xFFFFFFFFL) << 32)) &
	    // 0xFFFFFFFF00000000L);
	    // link[pos] = ((-1 & 0xFFFFFFFFL) << 32) | (first & 0xFFFFFFFFL);
	    this.first = pos;
	}
	this.order.insert(0, pos);
	if (this.size++ >= this.maxFill) {
	    this.rehash(OrderedMap.arraySize(this.size, this.f));
	}
	return this.defRetValue;
    }

    /**
     * Adds a pair to the map; if the key is already present, it is moved to the
     * last position of the iteration order.
     *
     * @param k the key.
     * @param v the value.
     * @return the old value, or the {@linkplain #defaultReturnValue() default
     *         return value} if no value was present for the given key.
     */
    public V putAndMoveToLast(final K k, final V v) {
	int pos;
	if (k == null) {
	    if (this.containsNullKey) {
		this.moveIndexToLast(this.n);
		return this.setValue(this.n, v);
	    }
	    this.containsNullKey = true;
	    pos = this.n;
	} else {
	    K curr;
	    final K[] key = this.key;
	    // The starting point.
	    if (!((curr = key[pos = HashCommon.mix(this.hasher.hash(k)) & this.mask]) == null)) {
		if (this.hasher.areEqual(curr, k)) {
		    this.moveIndexToLast(pos);
		    return this.setValue(pos, v);
		}
		while (!((curr = key[pos = pos + 1 & this.mask]) == null)) {
		    if (this.hasher.areEqual(curr, k)) {
			this.moveIndexToLast(pos);
			return this.setValue(pos, v);
		    }
		}
	    }
	}
	this.key[pos] = k;
	this.value[pos] = v;
	if (this.size == 0) {
	    this.first = this.last = pos;
	    // Special case of SET_UPPER_LOWER( link[ pos ], -1, -1 );
	    // link[pos] = -1L;
	} else {
	    // link[last] ^= ((link[last] ^ (pos & 0xFFFFFFFFL)) & 0xFFFFFFFFL);
	    // link[pos] = ((last & 0xFFFFFFFFL) << 32) | (-1 & 0xFFFFFFFFL);
	    this.last = pos;
	}
	if (this.order.peek() != pos) {
	    this.order.add(pos);
	}
	if (this.size++ >= this.maxFill) {
	    this.rehash(OrderedMap.arraySize(this.size, this.f));
	}
	return this.defRetValue;
    }

    @Override
    public V get(final Object k) {
	if (k == null) {
	    return this.containsNullKey ? this.value[this.n] : this.defRetValue;
	}
	K curr;
	final K[] key = this.key;
	int pos;
	// The starting point.
	if ((curr = key[pos = HashCommon.mix(this.hasher.hash(k)) & this.mask]) == null) {
	    return this.defRetValue;
	}
	if (this.hasher.areEqual(k, curr)) {
	    return this.value[pos];
	}
	// There's always an unused entry.
	while (true) {
	    if ((curr = key[pos = pos + 1 & this.mask]) == null) {
		return this.defRetValue;
	    }
	    if (this.hasher.areEqual(k, curr)) {
		return this.value[pos];
	    }
	}
    }

    @Override
    public V getOrDefault(final Object k, final V defaultValue) {
	if (k == null) {
	    return this.containsNullKey ? this.value[this.n] : defaultValue;
	}
	K curr;
	final K[] key = this.key;
	int pos;
	// The starting point.
	if ((curr = key[pos = HashCommon.mix(this.hasher.hash(k)) & this.mask]) == null) {
	    return defaultValue;
	}
	if (this.hasher.areEqual(k, curr)) {
	    return this.value[pos];
	}
	// There's always an unused entry.
	while (true) {
	    if ((curr = key[pos = pos + 1 & this.mask]) == null) {
		return defaultValue;
	    }
	    if (this.hasher.areEqual(k, curr)) {
		return this.value[pos];
	    }
	}
    }

    protected int positionOf(final Object k) {
	if (k == null) {
	    if (this.containsNullKey) {
		return this.n;
	    } else {
		return -1;
	    }
	}
	K curr;
	final K[] key = this.key;
	int pos;
	// The starting point.
	if ((curr = key[pos = HashCommon.mix(this.hasher.hash(k)) & this.mask]) == null) {
	    return -1;
	}
	if (this.hasher.areEqual(k, curr)) {
	    return pos;
	}
	// There's always an unused entry.
	while (true) {
	    if ((curr = key[pos = pos + 1 & this.mask]) == null) {
		return -1;
	    }
	    if (this.hasher.areEqual(k, curr)) {
		return pos;
	    }
	}
    }

    /**
     * Gets the position in the ordering of the given key, though not as efficiently
     * as some data structures can do it (e.g. {@link Arrangement} can access
     * ordering position very quickly but doesn't store other values on its own).
     * Returns a value that is at least 0 if it found k, or -1 if k was not present.
     *
     * @param k a key or possible key that this should find the index of
     * @return the index of k, if present, or -1 if it is not present in this
     *         OrderedMap
     */
    public int indexOf(final Object k) {
	final int pos = this.positionOf(k);
	return pos < 0 ? -1 : this.order.indexOf(pos);
    }

    /**
     * Swaps the positions in the ordering for the given items, if they are both
     * present. Returns true if the ordering changed as a result of this call, or
     * false if it stayed the same (which can be because left or right was not
     * present, or because left and right are the same reference (so swapping would
     * do nothing)).
     *
     * @param left  an item that should be present in this OrderedMap
     * @param right an item that should be present in this OrderedMap
     * @return true if this OrderedMap changed in ordering as a result of this call,
     *         or false otherwise
     */
    public boolean swap(final K left, final K right) {
	if (left == right) {
	    return false;
	}
	final int l = this.indexOf(left);
	if (l < 0) {
	    return false;
	}
	final int r = this.indexOf(right);
	if (r < 0) {
	    return false;
	}
	this.order.swap(l, r);
	return true;
    }

    /**
     * Swaps the given indices in the ordering, if they are both valid int indices.
     * Returns true if the ordering changed as a result of this call, or false if it
     * stayed the same (which can be because left or right referred to an
     * out-of-bounds index, or because left and right are equal (so swapping would
     * do nothing)).
     *
     * @param left  an index of an item in this OrderedSet, at least 0 and less than
     *              {@link #size()}
     * @param right an index of an item in this OrderedSet, at least 0 and less than
     *              {@link #size()}
     * @return true if this OrderedSet changed in ordering as a result of this call,
     *         or false otherwise
     */
    public boolean swapIndices(final int left, final int right) {
	if (left < 0 || right < 0 || left >= this.order.size || right >= this.order.size || left == right) {
	    return false;
	}
	this.order.swap(left, right);
	return true;
    }

    @Override
    public boolean containsKey(final Object k) {
	if (k == null) {
	    return this.containsNullKey;
	}
	K curr;
	final K[] key = this.key;
	int pos;
	// The starting point.
	if ((curr = key[pos = HashCommon.mix(this.hasher.hash(k)) & this.mask]) == null) {
	    return false;
	}
	if (this.hasher.areEqual(k, curr)) {
	    return true;
	}
	// There's always an unused entry.
	while (true) {
	    if ((curr = key[pos = pos + 1 & this.mask]) == null) {
		return false;
	    }
	    if (this.hasher.areEqual(k, curr)) {
		return true;
	    }
	}
    }

    @Override
    public boolean containsValue(final Object v) {
	final V value[] = this.value;
	final K key[] = this.key;
	if (this.containsNullKey && (value[this.n] == null ? v == null : value[this.n].equals(v))) {
	    return true;
	}
	for (int i = this.n; i-- != 0;) {
	    if (key[i] != null && (value[i] == null ? v == null : value[i].equals(v))) {
		return true;
	    }
	}
	return false;
    }

    /*
     * Removes all elements from this map.
     *
     * <P>To increase object reuse, this method does not change the table size. If
     * you want to reduce the table size, you must use {@link #trim()}.
     */
    @Override
    public void clear() {
	if (this.size == 0) {
	    return;
	}
	this.size = 0;
	this.containsNullKey = false;
	Arrays.fill(this.key, null);
	Arrays.fill(this.value, null);
	this.first = this.last = -1;
	this.order.clear();
    }

    @Override
    public int size() {
	return this.size;
    }

    @Override
    public boolean isEmpty() {
	return this.size == 0;
    }

    /**
     * A no-op for backward compatibility.
     *
     * @param growthFactor unused.
     * @deprecated Since <code>fastutil</code> 6.1.0, hash tables are doubled when
     *             they are too full.
     */
    @Deprecated
    public void growthFactor(final int growthFactor) {
    }

    /**
     * Gets the growth factor (2).
     *
     * @return the growth factor of this set, which is fixed (2).
     * @see #growthFactor(int)
     * @deprecated Since <code>fastutil</code> 6.1.0, hash tables are doubled when
     *             they are too full.
     */
    @Deprecated
    public int growthFactor() {
	return 16;
    }

    /**
     * The entry class for a OrderedMap does not record key and value, but rather
     * the position in the hash table of the corresponding entry. This is necessary
     * so that calls to {@link Entry#setValue(Object)} are reflected in the map
     */
    final class MapEntry implements Entry<K, V> {
	// The table index this entry refers to, or -1 if this entry has been
	// deleted.
	int index;

	MapEntry(final int index) {
	    this.index = index;
	}

	MapEntry() {
	}

	@Override
	public K getKey() {
	    return OrderedMap.this.key[this.index];
	}

	@Override
	public V getValue() {
	    return OrderedMap.this.value[this.index];
	}

	@Override
	public V setValue(final V v) {
	    final V oldValue = OrderedMap.this.value[this.index];
	    OrderedMap.this.value[this.index] = v;
	    return oldValue;
	}

	@Override
	@SuppressWarnings("unchecked")
	public boolean equals(final Object o) {
	    if (!(o instanceof Map.Entry)) {
		return false;
	    }
	    final Map.Entry<K, V> e = (Map.Entry<K, V>) o;
	    return (OrderedMap.this.key[this.index] == null ? e.getKey() == null
		    : OrderedMap.this.hasher.areEqual(OrderedMap.this.key[this.index], e.getKey()))
		    && (OrderedMap.this.value[this.index] == null ? e.getValue() == null
			    : OrderedMap.this.value[this.index].equals(e.getValue()));
	}

	@Override
	public int hashCode() {
	    return OrderedMap.this.hasher.hash(OrderedMap.this.key[this.index])
		    ^ (OrderedMap.this.value[this.index] == null ? 0 : OrderedMap.this.value[this.index].hashCode());
	}

	@Override
	public String toString() {
	    return OrderedMap.this.key[this.index] + "=>" + OrderedMap.this.value[this.index];
	}
    }

    /**
     * Modifies the ordering so that the given entry is removed. This method will
     * complete in logarithmic time.
     *
     * @param i the index of an entry.
     * @return the iteration-order index of the removed entry
     */
    protected int fixOrder(final int i) {
	if (this.size == 0) {
	    this.order.clear();
	    this.first = this.last = -1;
	    return 0;
	}
	final int idx = this.order.removeValue(i);
	if (this.first == i) {
	    this.first = this.order.get(0);
	}
	if (this.last == i) {
	    this.last = this.order.peek();
	}
	return idx;
    }

    /**
     * Modifies the ordering for a shift from s to d. <br>
     * This method will complete in logarithmic time or better.
     *
     * @param s the source position.
     * @param d the destination position.
     */
    protected void fixOrder(final int s, final int d) {
	if (this.size == 1) {
	    this.first = this.last = d;
	    this.order.set(0, d);
	} else if (this.first == s) {
	    this.first = d;
	    this.order.set(0, d);
	} else if (this.last == s) {
	    this.last = d;
	    this.order.set(this.order.size - 1, d);
	} else {
	    this.order.set(this.order.indexOf(s), d);
	}
    }

    /**
     * Returns the first key of this map in iteration order.
     *
     * @return the first key in iteration order.
     */
    @Override
    public K firstKey() {
	if (this.size == 0) {
	    throw new NoSuchElementException();
	}
	return this.key[this.first];
    }

    /**
     * Returns the last key of this map in iteration order.
     *
     * @return the last key in iteration order.
     */
    @Override
    public K lastKey() {
	if (this.size == 0) {
	    throw new NoSuchElementException();
	}
	return this.key[this.last];
    }

    @Override
    public Comparator<? super K> comparator() {
	return null;
    }

    @Override
    public SortedMap<K, V> tailMap(final K from) {
	throw new UnsupportedOperationException();
    }

    @Override
    public SortedMap<K, V> headMap(final K to) {
	throw new UnsupportedOperationException();
    }

    @Override
    public SortedMap<K, V> subMap(final K from, final K to) {
	throw new UnsupportedOperationException();
    }

    /**
     * A list iterator over a OrderedMap.
     *
     * <P>
     * This class provides a list iterator over a OrderedMap. The constructor runs
     * in constant time.
     */
    private class MapIterator {
	/**
	 * The entry that will be returned by the next call to
	 * {@link java.util.ListIterator#previous()} (or <code>null</code> if no
	 * previous entry exists).
	 */
	int prev = -1;
	/**
	 * The entry that will be returned by the next call to
	 * {@link java.util.ListIterator#next()} (or <code>null</code> if no next entry
	 * exists).
	 */
	int next = -1;
	/**
	 * The last entry that was returned (or -1 if we did not iterate or used
	 * {@link java.util.Iterator#remove()}).
	 */
	int curr = -1;
	/**
	 * The current index (in the sense of a {@link java.util.ListIterator}). Note
	 * that this value is not meaningful when this iterator has been created using
	 * the nonempty constructor.
	 */
	int index = 0;

	private MapIterator() {
	    this.next = OrderedMap.this.first;
	    this.index = 0;
	}

	/*
	 * private MapIterator(final K from) { if (((from) == null)) { if
	 * (containsNullKey) { next = (int) link[n]; prev = n; return; } else throw new
	 * NoSuchElementException("The key null" + " does not belong to this map."); }
	 * if (((key[last]) != null && (key[last]).equals(from))) { prev = last; index =
	 * size; return; } // The starting point. int pos =
	 * (HashCommon.mix((from).hashCode())) & mask; // There's always an unused
	 * entry. while (!((key[pos]) == null)) { if (((key[pos]).equals(from))) { //
	 * Note: no valid index known. next = (int) link[pos]; prev = pos; return; } pos
	 * = (pos + 1) & mask; } throw new NoSuchElementException("The key " + from +
	 * " does not belong to this map."); }
	 */
	public boolean hasNext() {
	    return this.next != -1;
	}

	public boolean hasPrevious() {
	    return this.prev != -1;
	}

	private void ensureIndexKnown() {
	    if (this.index >= 0) {
		return;
	    }
	    if (this.prev == -1) {
		this.index = 0;
		return;
	    }
	    if (this.next == -1) {
		this.index = OrderedMap.this.size;
		return;
	    }
	    this.index = 0;
	    /*
	     * while (pos != prev) { pos = (int) link[pos]; index++; }
	     */
	}

	public int nextIndex() {
	    this.ensureIndexKnown();
	    return this.index + 1;
	}

	public int previousIndex() {
	    this.ensureIndexKnown();
	    return this.index - 1;
	}

	public int nextEntry() {
	    if (!this.hasNext()) {
		throw new NoSuchElementException();
	    }
	    this.curr = this.next;
	    if (++this.index >= OrderedMap.this.order.size) {
		this.next = -1;
	    } else {
		this.next = OrderedMap.this.order.get(this.index);// (int) link[curr];
	    }
	    this.prev = this.curr;
	    return this.curr;
	}

	public int previousEntry() {
	    if (!this.hasPrevious()) {
		throw new NoSuchElementException();
	    }
	    this.curr = this.prev;
	    if (--this.index < 1) {
		this.prev = -1;
	    } else {
		this.prev = OrderedMap.this.order.get(this.index - 1);
	    }
	    // prev = (int) (link[curr] >>> 32);
	    this.next = this.curr;
	    return this.curr;
	}

	public void remove() {
	    this.ensureIndexKnown();
	    if (this.curr == -1) {
		throw new IllegalStateException();
	    }
	    if (this.curr == this.prev) {
		/*
		 * If the last operation was a next(), we are removing an entry that precedes
		 * the current index, and thus we must decrement it.
		 */
		if (--this.index >= 1) {
		    this.prev = OrderedMap.this.order.get(this.index - 1); // (int) (link[curr] >>> 32);
		} else {
		    this.prev = -1;
		}
	    } else {
		if (this.index < OrderedMap.this.order.size - 1) {
		    this.next = OrderedMap.this.order.get(this.index + 1);
		} else {
		    this.next = -1;
		}
	    }
	    /*
	     * Now we manually fix the pointers. Because of our knowledge of next and prev,
	     * this is going to be faster than calling fixOrder().
	     */
	    if (this.prev == -1) {
		OrderedMap.this.first = this.next;
	    }
	    if (this.next == -1) {
		OrderedMap.this.last = this.prev;
	    }
	    OrderedMap.this.order.removeIndex(this.index);
	    OrderedMap.this.size--;
	    int last, slot, pos = this.curr;
	    this.curr = -1;
	    if (pos == OrderedMap.this.n) {
		OrderedMap.this.containsNullKey = false;
		OrderedMap.this.key[OrderedMap.this.n] = null;
		OrderedMap.this.value[OrderedMap.this.n] = null;
	    } else {
		K curr;
		final K[] key = OrderedMap.this.key;
		// We have to horribly duplicate the shiftKeys() code because we
		// need to update next/prev.
		for (;;) {
		    pos = (last = pos) + 1 & OrderedMap.this.mask;
		    for (;;) {
			if ((curr = key[pos]) == null) {
			    key[last] = null;
			    OrderedMap.this.value[last] = null;
			    return;
			}
			slot = HashCommon.mix(OrderedMap.this.hasher.hash(curr)) & OrderedMap.this.mask;
			if (last <= pos ? last >= slot || slot > pos : last >= slot && slot > pos) {
			    break;
			}
			pos = pos + 1 & OrderedMap.this.mask;
		    }
		    key[last] = curr;
		    OrderedMap.this.value[last] = OrderedMap.this.value[pos];
		    if (this.next == pos) {
			this.next = last;
		    }
		    if (this.prev == pos) {
			this.prev = last;
		    }
		    OrderedMap.this.fixOrder(pos, last);
		}
	    }
	}

	public int skip(final int n) {
	    int i = n;
	    while (i-- != 0 && this.hasNext()) {
		this.nextEntry();
	    }
	    return n - i - 1;
	}

	public int back(final int n) {
	    int i = n;
	    while (i-- != 0 && this.hasPrevious()) {
		this.previousEntry();
	    }
	    return n - i - 1;
	}
    }

    private class EntryIterator extends MapIterator implements Iterator<Entry<K, V>>, Serializable {
	private static final long serialVersionUID = 0L;
	private MapEntry entry;

	public EntryIterator() {
	}

	@Override
	public MapEntry next() {
	    return this.entry = new MapEntry(this.nextEntry());
	}

	@Override
	public void remove() {
	    super.remove();
	    this.entry.index = -1; // You cannot use a deleted entry.
	}
    }

    public class FastEntryIterator extends MapIterator implements ListIterator<MapEntry>, Serializable {
	private static final long serialVersionUID = 0L;
	final MapEntry entry = new MapEntry();

	public FastEntryIterator() {
	}

	@Override
	public MapEntry next() {
	    this.entry.index = this.nextEntry();
	    return this.entry;
	}

	@Override
	public MapEntry previous() {
	    this.entry.index = this.previousEntry();
	    return this.entry;
	}

	@Override
	public void set(final MapEntry ok) {
	    throw new UnsupportedOperationException();
	}

	@Override
	public void add(final MapEntry ok) {
	    throw new UnsupportedOperationException();
	}
    }

    public final class MapEntrySet
	    implements Cloneable, SortedSet<Entry<K, V>>, Set<Entry<K, V>>, Collection<Entry<K, V>>, Serializable {
	private static final long serialVersionUID = 0L;

	@Override
	public EntryIterator iterator() {
	    return new EntryIterator();
	}

	@Override
	public Comparator<? super Entry<K, V>> comparator() {
	    return null;
	}

	@Override
	public SortedSet<Entry<K, V>> subSet(final Entry<K, V> fromElement, final Entry<K, V> toElement) {
	    throw new UnsupportedOperationException();
	}

	@Override
	public SortedSet<Entry<K, V>> headSet(final Entry<K, V> toElement) {
	    throw new UnsupportedOperationException();
	}

	@Override
	public SortedSet<Entry<K, V>> tailSet(final Entry<K, V> fromElement) {
	    throw new UnsupportedOperationException();
	}

	@Override
	public Entry<K, V> first() {
	    if (OrderedMap.this.size == 0) {
		throw new NoSuchElementException();
	    }
	    return new MapEntry(OrderedMap.this.first);
	}

	@Override
	public Entry<K, V> last() {
	    if (OrderedMap.this.size == 0) {
		throw new NoSuchElementException();
	    }
	    return new MapEntry(OrderedMap.this.last);
	}

	@Override
	@SuppressWarnings("unchecked")
	public boolean contains(final Object o) {
	    if (!(o instanceof Map.Entry)) {
		return false;
	    }
	    final Map.Entry<?, ?> e = (Map.Entry<?, ?>) o;
	    final K k = (K) e.getKey();
	    final V v = (V) e.getValue();
	    if (k == null) {
		return OrderedMap.this.containsNullKey && (OrderedMap.this.value[OrderedMap.this.n] == null ? v == null
			: OrderedMap.this.value[OrderedMap.this.n].equals(v));
	    }
	    K curr;
	    final K[] key = OrderedMap.this.key;
	    int pos;
	    // The starting point.
	    if ((curr = key[pos = HashCommon.mix(OrderedMap.this.hasher.hash(k)) & OrderedMap.this.mask]) == null) {
		return false;
	    }
	    if (OrderedMap.this.hasher.areEqual(k, curr)) {
		return OrderedMap.this.value[pos] == null ? v == null : OrderedMap.this.value[pos].equals(v);
	    }
	    // There's always an unused entry.
	    while (true) {
		if ((curr = key[pos = pos + 1 & OrderedMap.this.mask]) == null) {
		    return false;
		}
		if (OrderedMap.this.hasher.areEqual(k, curr)) {
		    return OrderedMap.this.value[pos] == null ? v == null : OrderedMap.this.value[pos].equals(v);
		}
	    }
	}

	@Override
	@SuppressWarnings("unchecked")
	public boolean remove(final Object o) {
	    if (!(o instanceof Map.Entry)) {
		return false;
	    }
	    final Map.Entry<?, ?> e = (Map.Entry<?, ?>) o;
	    final K k = (K) e.getKey();
	    final V v = (V) e.getValue();
	    if (k == null) {
		if (OrderedMap.this.containsNullKey && (OrderedMap.this.value[OrderedMap.this.n] == null ? v == null
			: OrderedMap.this.value[OrderedMap.this.n].equals(v))) {
		    OrderedMap.this.removeNullEntry();
		    return true;
		}
		return false;
	    }
	    K curr;
	    final K[] key = OrderedMap.this.key;
	    int pos;
	    // The starting point.
	    if ((curr = key[pos = HashCommon.mix(OrderedMap.this.hasher.hash(k)) & OrderedMap.this.mask]) == null) {
		return false;
	    }
	    if (OrderedMap.this.hasher.areEqual(curr, k)) {
		if (OrderedMap.this.value[pos] == null ? v == null : OrderedMap.this.value[pos].equals(v)) {
		    OrderedMap.this.removeEntry(pos);
		    return true;
		}
		return false;
	    }
	    while (true) {
		if ((curr = key[pos = pos + 1 & OrderedMap.this.mask]) == null) {
		    return false;
		}
		if (OrderedMap.this.hasher.areEqual(curr, k)) {
		    if (OrderedMap.this.value[pos] == null ? v == null : OrderedMap.this.value[pos].equals(v)) {
			OrderedMap.this.removeEntry(pos);
			return true;
		    }
		}
	    }
	}

	@Override
	public int size() {
	    return OrderedMap.this.size;
	}

	@Override
	public void clear() {
	    OrderedMap.this.clear();
	}

	public FastEntryIterator fastIterator() {
	    return new FastEntryIterator();
	}

	@Override
	public boolean equals(final Object o) {
	    if (o == this) {
		return true;
	    }
	    if (!(o instanceof Set)) {
		return false;
	    }
	    final Set<?> s = (Set<?>) o;
	    return s.size() == this.size() && this.containsAll(s);
	}

	@Override
	public Object[] toArray() {
	    final Object[] a = new Object[this.size()];
	    OrderedMap.objectUnwrap(this.iterator(), a);
	    return a;
	}

	@Override
	@SuppressWarnings("unchecked")
	public <T> T[] toArray(T[] a) {
	    if (a == null || a.length < this.size()) {
		a = (T[]) new Object[this.size()];
	    }
	    OrderedMap.objectUnwrap(this.iterator(), a);
	    return a;
	}

	/**
	 * Unsupported.
	 *
	 * @param c ignored
	 * @return nothing, throws UnsupportedOperationException
	 * @throws UnsupportedOperationException always
	 */
	@Override
	public boolean addAll(final Collection<? extends Entry<K, V>> c) {
	    throw new UnsupportedOperationException("addAll not supported");
	}

	/**
	 * Unsupported.
	 *
	 * @param k ignored
	 * @return nothing, throws UnsupportedOperationException
	 * @throws UnsupportedOperationException always
	 */
	@Override
	public boolean add(final Entry<K, V> k) {
	    throw new UnsupportedOperationException("add not supported");
	}

	/**
	 * Checks whether this collection contains all elements from the given
	 * collection.
	 *
	 * @param c a collection.
	 * @return <code>true</code> if this collection contains all elements of the
	 *         argument.
	 */
	@Override
	public boolean containsAll(final Collection<?> c) {
	    int n = c.size();
	    final Iterator<?> i = c.iterator();
	    while (n-- != 0) {
		if (!this.contains(i.next())) {
		    return false;
		}
	    }
	    return true;
	}

	/**
	 * Retains in this collection only elements from the given collection.
	 *
	 * @param c a collection.
	 * @return <code>true</code> if this collection changed as a result of the call.
	 */
	@Override
	public boolean retainAll(final Collection<?> c) {
	    boolean retVal = false;
	    int n = this.size();
	    final Iterator<?> i = this.iterator();
	    while (n-- != 0) {
		if (!c.contains(i.next())) {
		    i.remove();
		    retVal = true;
		}
	    }
	    return retVal;
	}

	/**
	 * Remove from this collection all elements in the given collection. If the
	 * collection is an instance of this class, it uses faster iterators.
	 *
	 * @param c a collection.
	 * @return <code>true</code> if this collection changed as a result of the call.
	 */
	@Override
	public boolean removeAll(final Collection<?> c) {
	    boolean retVal = false;
	    int n = c.size();
	    final Iterator<?> i = c.iterator();
	    while (n-- != 0) {
		if (this.remove(i.next())) {
		    retVal = true;
		}
	    }
	    return retVal;
	}

	@Override
	public boolean isEmpty() {
	    return this.size() == 0;
	}

	@Override
	public String toString() {
	    final StringBuilder s = new StringBuilder();
	    final EntryIterator i = this.iterator();
	    int n = this.size();
	    Object k;
	    boolean first = true;
	    s.append("{");
	    while (n-- != 0) {
		if (first) {
		    first = false;
		} else {
		    s.append(", ");
		}
		k = i.next();
		if (this == k) {
		    s.append("(this collection)");
		} else {
		    s.append(String.valueOf(k));
		}
	    }
	    s.append("}");
	    return s.toString();
	}
    }

    @Override
    public SortedSet<Entry<K, V>> entrySet() {
	if (this.entries == null) {
	    this.entries = new MapEntrySet();
	}
	return this.entries;
    }

    public MapEntrySet mapEntrySet() {
	if (this.entries == null) {
	    this.entries = new MapEntrySet();
	}
	return this.entries;
    }

    /**
     * An iterator on keys.
     * <p>
     * <P>
     * We simply override the
     * {@link ListIterator#next()}/{@link ListIterator#previous()} methods (and
     * possibly their type-specific counterparts) so that they return keys instead
     * of entries.
     */
    public final class KeyIterator extends MapIterator implements Iterator<K>, Serializable {
	private static final long serialVersionUID = 0L;

	public K previous() {
	    return OrderedMap.this.key[this.previousEntry()];
	}

	public void set(final K k) {
	    throw new UnsupportedOperationException();
	}

	public void add(final K k) {
	    throw new UnsupportedOperationException();
	}

	public KeyIterator() {
	}

	@Override
	public K next() {
	    return OrderedMap.this.key[this.nextEntry()];
	}

	@Override
	public void remove() {
	    super.remove();
	}
    }

    public final class KeySet implements SortedSet<K>, Serializable {
	private static final long serialVersionUID = 0L;

	@Override
	public KeyIterator iterator() {
	    return new KeyIterator();
	}

	@Override
	public int size() {
	    return OrderedMap.this.size;
	}

	@Override
	public void clear() {
	    OrderedMap.this.clear();
	}

	@Override
	public K first() {
	    if (OrderedMap.this.size == 0) {
		throw new NoSuchElementException();
	    }
	    return OrderedMap.this.key[OrderedMap.this.first];
	}

	@Override
	public K last() {
	    if (OrderedMap.this.size == 0) {
		throw new NoSuchElementException();
	    }
	    return OrderedMap.this.key[OrderedMap.this.last];
	}

	@Override
	public Comparator<K> comparator() {
	    return null;
	}

	@Override
	public SortedSet<K> tailSet(final K from) {
	    throw new UnsupportedOperationException();
	}

	@Override
	public SortedSet<K> headSet(final K to) {
	    throw new UnsupportedOperationException();
	}

	@Override
	public SortedSet<K> subSet(final K from, final K to) {
	    throw new UnsupportedOperationException();
	}

	@SuppressWarnings("unchecked")
	@Override
	public <T> T[] toArray(T[] a) {
	    if (a == null || a.length < this.size()) {
		a = (T[]) new Object[this.size()];
	    }
	    this.unwrap(this.iterator(), a);
	    return a;
	}

	/**
	 * Always throws an UnsupportedOperationException
	 */
	@Override
	public boolean remove(final Object ok) {
	    throw new UnsupportedOperationException("Cannot remove from the key set directly");
	}

	/**
	 * Always throws an UnsupportedOperationException
	 */
	@Override
	public boolean add(final K o) {
	    throw new UnsupportedOperationException("Cannot add to the key set directly");
	}

	/**
	 * Delegates to the corresponding type-specific method.
	 */
	@Override
	public boolean contains(final Object o) {
	    return OrderedMap.this.containsKey(o);
	}

	/**
	 * Checks whether this collection contains all elements from the given
	 * type-specific collection.
	 *
	 * @param c a type-specific collection.
	 * @return <code>true</code> if this collection contains all elements of the
	 *         argument.
	 */
	@Override
	public boolean containsAll(final Collection<?> c) {
	    final Iterator<?> i = c.iterator();
	    int n = c.size();
	    while (n-- != 0) {
		if (!this.contains(i.next())) {
		    return false;
		}
	    }
	    return true;
	}

	/**
	 * Retains in this collection only elements from the given type-specific
	 * collection.
	 *
	 * @param c a type-specific collection.
	 * @return <code>true</code> if this collection changed as a result of the call.
	 */
	@Override
	public boolean retainAll(final Collection<?> c) {
	    boolean retVal = false;
	    int n = this.size();
	    final Iterator<?> i = this.iterator();
	    while (n-- != 0) {
		if (!c.contains(i.next())) {
		    i.remove();
		    retVal = true;
		}
	    }
	    return retVal;
	}

	/**
	 * Remove from this collection all elements in the given type-specific
	 * collection.
	 *
	 * @param c a type-specific collection.
	 * @return <code>true</code> if this collection changed as a result of the call.
	 */
	@Override
	public boolean removeAll(final Collection<?> c) {
	    boolean retVal = false;
	    int n = c.size();
	    final Iterator<?> i = c.iterator();
	    while (n-- != 0) {
		if (this.remove(i.next())) {
		    retVal = true;
		}
	    }
	    return retVal;
	}

	@Override
	public Object[] toArray() {
	    final Object[] a = new Object[this.size()];
	    OrderedMap.objectUnwrap(this.iterator(), a);
	    return a;
	}

	/**
	 * Adds all elements of the given collection to this collection.
	 *
	 * @param c a collection.
	 * @return <code>true</code> if this collection changed as a result of the call.
	 */
	@Override
	public boolean addAll(final Collection<? extends K> c) {
	    boolean retVal = false;
	    final Iterator<? extends K> i = c.iterator();
	    int n = c.size();
	    while (n-- != 0) {
		if (this.add(i.next())) {
		    retVal = true;
		}
	    }
	    return retVal;
	}

	@Override
	public boolean equals(final Object o) {
	    if (o == this) {
		return true;
	    }
	    if (!(o instanceof Set)) {
		return false;
	    }
	    final Set<?> s = (Set<?>) o;
	    if (s.size() != this.size()) {
		return false;
	    }
	    return this.containsAll(s);
	}

	/**
	 * Unwraps an iterator into an array starting at a given offset for a given
	 * number of elements.
	 * <p>
	 * <P>
	 * This method iterates over the given type-specific iterator and stores the
	 * elements returned, up to a maximum of <code>length</code>, in the given array
	 * starting at <code>offset</code>. The number of actually unwrapped elements is
	 * returned (it may be less than <code>max</code> if the iterator emits less
	 * than <code>max</code> elements).
	 *
	 * @param i      a type-specific iterator.
	 * @param array  an array to contain the output of the iterator.
	 * @param offset the first element of the array to be returned.
	 * @param max    the maximum number of elements to unwrap.
	 * @return the number of elements unwrapped.
	 */
	public int unwrap(final KeyIterator i, final Object[] array, int offset, final int max) {
	    if (max < 0) {
		throw new IllegalArgumentException("The maximum number of elements (" + max + ") is negative");
	    }
	    if (offset < 0 || offset + max > array.length) {
		throw new IllegalArgumentException();
	    }
	    int j = max;
	    while (j-- != 0 && i.hasNext()) {
		array[offset++] = i.next();
	    }
	    return max - j - 1;
	}

	/**
	 * Unwraps an iterator into an array.
	 * <p>
	 * <P>
	 * This method iterates over the given type-specific iterator and stores the
	 * elements returned in the given array. The iteration will stop when the
	 * iterator has no more elements or when the end of the array has been reached.
	 *
	 * @param i     a type-specific iterator.
	 * @param array an array to contain the output of the iterator.
	 * @return the number of elements unwrapped.
	 */
	public int unwrap(final KeyIterator i, final Object[] array) {
	    return this.unwrap(i, array, 0, array.length);
	}

	@Override
	public boolean isEmpty() {
	    return this.size() == 0;
	}

	@Override
	public String toString() {
	    final StringBuilder s = new StringBuilder();
	    final KeyIterator i = this.iterator();
	    int n = this.size();
	    boolean first = true;
	    s.append("{");
	    while (n-- != 0) {
		if (first) {
		    first = false;
		} else {
		    s.append(", ");
		}
		s.append(i.next());
	    }
	    s.append("}");
	    return s.toString();
	}
    }

    @Override
    public KeySet keySet() {
	if (this.keys == null) {
	    this.keys = new KeySet();
	}
	return this.keys;
    }

    public OrderedSet<K> keysAsOrderedSet() {
	final OrderedSet<K> os = new OrderedSet<>(this.size, this.f, this.hasher);
	for (int i = 0; i < this.size; i++) {
	    os.add(this.keyAt(i));
	}
	return os;
    }

    /**
     * An iterator on values.
     * <p>
     * <P>
     * We simply override the
     * {@link ListIterator#next()}/{@link ListIterator#previous()} methods (and
     * possibly their type-specific counterparts) so that they return values instead
     * of entries.
     */
    public final class ValueIterator extends MapIterator implements ListIterator<V>, Serializable {
	private static final long serialVersionUID = 0L;

	@Override
	public V previous() {
	    return OrderedMap.this.value[this.previousEntry()];
	}

	@Override
	public void set(final V v) {
	    throw new UnsupportedOperationException();
	}

	@Override
	public void add(final V v) {
	    throw new UnsupportedOperationException();
	}

	public ValueIterator() {
	}

	@Override
	public V next() {
	    return OrderedMap.this.value[this.nextEntry()];
	}

	@Override
	public void remove() {
	    super.remove();
	}
    }

    public final class ValueCollection extends AbstractCollection<V> implements Serializable {
	private static final long serialVersionUID = 0L;

	@Override
	public ValueIterator iterator() {
	    return new ValueIterator();
	}

	@Override
	public int size() {
	    return OrderedMap.this.size;
	}

	@Override
	public boolean contains(final Object v) {
	    return OrderedMap.this.containsValue(v);
	}

	@Override
	public void clear() {
	    OrderedMap.this.clear();
	}
    }

    @Override
    public Collection<V> values() {
	if (this.values == null) {
	    this.values = new ValueCollection();
	}
	return this.values;
    }

    public ArrayList<V> valuesAsList() {
	final ArrayList<V> ls = new ArrayList<>(this.size);
	for (int i = 0; i < this.size; i++) {
	    ls.add(this.getAt(i));
	}
	return ls;
    }

    /**
     * A no-op for backward compatibility. The kind of tables implemented by this
     * class never need rehashing.
     * <p>
     * <P>
     * If you need to reduce the table size to fit exactly this set, use
     * {@link #trim()}.
     *
     * @return true.
     * @see #trim()
     * @deprecated A no-op.
     */
    @Deprecated
    public boolean rehash() {
	return true;
    }

    /**
     * Rehashes the map, making the table as small as possible.
     * <p>
     * <P>
     * This method rehashes the table to the smallest size satisfying the load
     * factor. It can be used when the set will not be changed anymore, so to
     * optimize access speed and size.
     * <p>
     * <P>
     * If the table size is already the minimum possible, this method does nothing.
     *
     * @return true if there was enough memory to trim the map.
     * @see #trim(int)
     */
    public boolean trim() {
	final int l = OrderedMap.arraySize(this.size, this.f);
	if (l >= this.n || this.size > OrderedMap.maxFill(l, this.f)) {
	    return true;
	}
	try {
	    this.rehash(l);
	} catch (final Exception cantDoIt) {
	    return false;
	}
	return true;
    }

    /**
     * Rehashes this map if the table is too large.
     * <p>
     * <P>
     * Let <var>N</var> be the smallest table size that can hold
     * <code>max(n,{@link #size()})</code> entries, still satisfying the load
     * factor. If the current table size is smaller than or equal to <var>N</var>,
     * this method does nothing. Otherwise, it rehashes this map in a table of size
     * <var>N</var>.
     * <p>
     * <P>
     * This method is useful when reusing maps. {@linkplain #clear() Clearing a map}
     * leaves the table size untouched. If you are reusing a map many times, you can
     * call this method with a typical size to avoid keeping around a very large
     * table just because of a few large transient maps.
     *
     * @param n the threshold for the trimming.
     * @return true if there was enough memory to trim the map.
     * @see #trim()
     */
    public boolean trim(final int n) {
	final int l = HashCommon.nextPowerOfTwo((int) Math.ceil(n / this.f));
	if (l >= n || this.size > OrderedMap.maxFill(l, this.f)) {
	    return true;
	}
	try {
	    this.rehash(l);
	} catch (final Exception cantDoIt) {
	    return false;
	}
	return true;
    }

    /**
     * Rehashes the map.
     *
     * <P>
     * This method implements the basic rehashing strategy, and may be overriden by
     * subclasses implementing different rehashing strategies (e.g., disk-based
     * rehashing). However, you should not override this method unless you
     * understand the internal workings of this class.
     *
     * @param newN the new size
     */
    @SuppressWarnings("unchecked")
    protected void rehash(final int newN) {
	final K key[] = this.key;
	final V value[] = this.value;
	final int mask = newN - 1; // Note that this is used by the hashing
	// macro
	final K newKey[] = (K[]) new Object[newN + 1];
	final V newValue[] = (V[]) new Object[newN + 1];
	int i, pos;
	final int sz = this.order.size, originalFirst = this.first, originalLast = this.last;
	for (int q = 0; q < sz; q++) {
	    i = this.order.get(q);
	    if (key[i] == null) {
		pos = newN;
	    } else {
		pos = HashCommon.mix(this.hasher.hash(key[i])) & mask;
		while (!(newKey[pos] == null)) {
		    pos = pos + 1 & mask;
		}
	    }
	    newKey[pos] = key[i];
	    newValue[pos] = value[i];
	    this.order.set(q, pos);
	    if (i == originalFirst) {
		this.first = pos;
	    }
	    if (i == originalLast) {
		this.last = pos;
	    }
	}
	this.n = newN;
	this.mask = mask;
	this.maxFill = OrderedMap.maxFill(this.n, this.f);
	this.key = newKey;
	this.value = newValue;
    }

    /*
     * @SuppressWarnings("unchecked") protected void rehash(final int newN) { final
     * K key[] = this.key; final V value[] = this.value; final int mask = newN - 1;
     * // Note that this is used by the hashing // macro final K newKey[] = (K[])
     * new Object[newN + 1]; final V newValue[] = (V[]) new Object[newN + 1]; int i
     * = first, prev = -1, newPrev = -1, t, pos; final long link[] = this.link;
     * final long newLink[] = new long[newN + 1]; first = -1; for (int j = size; j--
     * != 0;) { if (((key[i]) == null)) pos = newN; else { pos =
     * (HashCommon.mix((key[i]).hashCode())) & mask; while (!((newKey[pos]) ==
     * null)) pos = (pos + 1) & mask; } newKey[pos] = key[i]; newValue[pos] =
     * value[i]; if (prev != -1) { newLink[newPrev] ^= ((newLink[newPrev] ^ (pos &
     * 0xFFFFFFFFL)) & 0xFFFFFFFFL); newLink[pos] ^= ((newLink[pos] ^ ((newPrev &
     * 0xFFFFFFFFL) << 32)) & 0xFFFFFFFF00000000L); newPrev = pos; } else { newPrev
     * = first = pos; // Special case of SET(newLink[ pos ], -1, -1); newLink[pos] =
     * -1L; } t = i; i = (int) link[i]; prev = t; } this.link = newLink; this.last =
     * newPrev; if (newPrev != -1) // Special case of SET_NEXT( newLink[ newPrev ],
     * -1 ); newLink[newPrev] |= -1 & 0xFFFFFFFFL; n = newN; this.mask = mask;
     * maxFill = maxFill(n, f); this.key = newKey; this.value = newValue; }
     */
    /**
     * Returns a deep copy of this map.
     *
     * <P>
     * This method performs a deep copy of this OrderedMap; the data stored in the
     * map, however, is not cloned. Note that this makes a difference only for
     * object keys.
     *
     * @return a deep copy of this map.
     */
    @Override
    @SuppressWarnings("unchecked")
    @GwtIncompatible
    public OrderedMap<K, V> clone() {
	OrderedMap<K, V> c;
	try {
	    c = (OrderedMap<K, V>) super.clone();
	    c.key = (K[]) new Object[this.n + 1];
	    System.arraycopy(this.key, 0, c.key, 0, this.n + 1);
	    c.value = (V[]) new Object[this.n + 1];
	    System.arraycopy(this.value, 0, c.value, 0, this.n + 1);
	    c.order = (IntVLA) this.order.clone();
	    c.hasher = this.hasher;
	    return c;
	} catch (final Exception cantHappen) {
	    throw new UnsupportedOperationException(
		    cantHappen + (cantHappen.getMessage() != null ? "; " + cantHappen.getMessage() : ""));
	}
    }

    /**
     * Returns a hash code for this map.
     *
     * This method overrides the generic method provided by the superclass. Since
     * <code>equals()</code> is not overriden, it is important that the value
     * returned by this method is the same value as the one returned by the
     * overriden method.
     *
     * @return a hash code for this map.
     */
    @Override
    public int hashCode() {
	int h = 0;
	for (int j = this.realSize(), i = 0, t = 0; j-- != 0;) {
	    while (this.key[i] == null) {
		i++;
	    }
	    if (this != this.key[i]) {
		t = this.hasher.hash(this.key[i]);
	    }
	    if (this != this.value[i]) {
		t ^= this.value[i] == null ? 0 : this.value[i].hashCode();
	    }
	    h += t;
	    i++;
	}
	// Zero / null keys have hash zero.
	if (this.containsNullKey) {
	    h += this.value[this.n] == null ? 0 : this.value[this.n].hashCode();
	}
	return h;
    }

    /**
     * Returns the maximum number of entries that can be filled before rehashing.
     *
     * @param n the size of the backing array.
     * @param f the load factor.
     * @return the maximum number of entries before rehashing.
     */
    public static int maxFill(final int n, final float f) {
	/*
	 * We must guarantee that there is always at least one free entry (even with
	 * pathological load factors).
	 */
	return Math.min((int) Math.ceil(n * f), n - 1);
    }

    /**
     * Returns the maximum number of entries that can be filled before rehashing.
     *
     * @param n the size of the backing array.
     * @param f the load factor.
     * @return the maximum number of entries before rehashing.
     */
    public static long maxFill(final long n, final float f) {
	/*
	 * We must guarantee that there is always at least one free entry (even with
	 * pathological load factors).
	 */
	return Math.min((long) Math.ceil(n * f), n - 1);
    }

    /**
     * Returns the least power of two smaller than or equal to 2<sup>30</sup> and
     * larger than or equal to <code>Math.ceil( expected / f )</code>.
     *
     * @param expected the expected number of elements in a hash table.
     * @param f        the load factor.
     * @return the minimum possible size for a backing array.
     * @throws IllegalArgumentException if the necessary size is larger than
     *                                  2<sup>30</sup>.
     */
    public static int arraySize(final int expected, final float f) {
	final long s = Math.max(2, HashCommon.nextPowerOfTwo((long) Math.ceil(expected / f)));
	if (s > 1 << 30) {
	    throw new IllegalArgumentException(
		    "Too large (" + expected + " expected elements with load factor " + f + ")");
	}
	return (int) s;
    }

    /**
     * Unwraps an iterator into an array starting at a given offset for a given
     * number of elements.
     *
     * <P>
     * This method iterates over the given type-specific iterator and stores the
     * elements returned, up to a maximum of <code>length</code>, in the given array
     * starting at <code>offset</code>. The number of actually unwrapped elements is
     * returned (it may be less than <code>max</code> if the iterator emits less
     * than <code>max</code> elements).
     *
     * @param i      a type-specific iterator.
     * @param array  an array to contain the output of the iterator.
     * @param offset the first element of the array to be returned.
     * @param max    the maximum number of elements to unwrap.
     * @return the number of elements unwrapped.
     */
    private static <K> int objectUnwrap(final Iterator<? extends K> i, final K array[], int offset, final int max) {
	if (max < 0) {
	    throw new IllegalArgumentException("The maximum number of elements (" + max + ") is negative");
	}
	if (offset < 0 || offset + max > array.length) {
	    throw new IllegalArgumentException();
	}
	int j = max;
	while (j-- != 0 && i.hasNext()) {
	    array[offset++] = i.next();
	}
	return max - j - 1;
    }

    /**
     * Unwraps an iterator into an array.
     *
     * <P>
     * This method iterates over the given type-specific iterator and stores the
     * elements returned in the given array. The iteration will stop when the
     * iterator has no more elements or when the end of the array has been reached.
     *
     * @param i     a type-specific iterator.
     * @param array an array to contain the output of the iterator.
     * @return the number of elements unwrapped.
     */
    private static <K> int objectUnwrap(final Iterator<? extends K> i, final K array[]) {
	return OrderedMap.objectUnwrap(i, array, 0, array.length);
    }

    @Override
    public String toString() {
	final StringBuilder s = new StringBuilder();
	final int n = this.size();
	int i = 0;
	boolean first = true;
	s.append("OrderedMap{");
	while (i < n) {
	    if (first) {
		first = false;
	    } else {
		s.append(", ");
	    }
	    s.append(this.entryAt(i++));
	}
	s.append("}");
	return s.toString();
    }

    @Override
    public boolean equals(final Object o) {
	if (o == this) {
	    return true;
	}
	if (!(o instanceof Map)) {
	    return false;
	}
	final Map<?, ?> m = (Map<?, ?>) o;
	if (m.size() != this.size()) {
	    return false;
	}
	return this.entrySet().containsAll(m.entrySet());
    }

    @GwtIncompatible
    private void writeObject(final java.io.ObjectOutputStream s) throws java.io.IOException {
	final K key[] = this.key;
	final V value[] = this.value;
	final MapIterator i = new MapIterator();
	s.defaultWriteObject();
	s.writeObject(this.hasher);
	for (int j = this.size, e; j-- != 0;) {
	    e = i.nextEntry();
	    s.writeObject(key[e]);
	    s.writeObject(value[e]);
	}
    }

    @GwtIncompatible
    @SuppressWarnings("unchecked")
    private void readObject(final java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException {
	s.defaultReadObject();
	this.hasher = (CrossHash.IHasher) s.readObject();
	this.n = OrderedMap.arraySize(this.size, this.f);
	this.maxFill = OrderedMap.maxFill(this.n, this.f);
	this.mask = this.n - 1;
	final K key[] = this.key = (K[]) new Object[this.n + 1];
	final V value[] = this.value = (V[]) new Object[this.n + 1];
	final IntVLA order = this.order = new IntVLA(this.n + 1);
	int prev = -1;
	this.first = this.last = -1;
	K k;
	V v;
	for (int i = this.size, pos; i-- != 0;) {
	    k = (K) s.readObject();
	    v = (V) s.readObject();
	    if (k == null) {
		pos = this.n;
		this.containsNullKey = true;
	    } else {
		pos = HashCommon.mix(this.hasher.hash(k)) & this.mask;
		while (!(key[pos] == null)) {
		    pos = pos + 1 & this.mask;
		}
	    }
	    key[pos] = k;
	    value[pos] = v;
	    if (this.first != -1) {
		prev = pos;
	    } else {
		prev = this.first = pos;
	    }
	    order.add(pos);
	}
	this.last = prev;
    }

    /**
     * Gets the value at the given index in the iteration order in constant time
     * (random-access).
     *
     * @param idx the index in the iteration order of the value to fetch
     * @return the value at the index, if the index is valid, otherwise the default
     *         return value
     */
    public V getAt(final int idx) {
	int pos;
	if (idx < 0 || idx >= this.order.size) {
	    return this.defRetValue;
	}
	// The starting point.
	if (this.key[pos = this.order.get(idx)] == null) {
	    return this.containsNullKey ? this.value[this.n] : this.defRetValue;
	}
	return this.value[pos];
    }

    /**
     * Gets the key at the given index in the iteration order in constant time
     * (random-access).
     *
     * @param idx the index in the iteration order of the key to fetch
     * @return the key at the index, if the index is valid, otherwise null
     */
    public K keyAt(final int idx) {
	if (idx < 0 || idx >= this.order.size) {
	    return null;
	}
	// The starting point.
	return this.key[this.order.get(idx)];
    }

    /**
     * Gets the key-value Map.Entry at the given index in the iteration order in
     * constant time (random-access).
     *
     * @param idx the index in the iteration order of the entry to fetch
     * @return the key-value entry at the index, if the index is valid, otherwise
     *         null
     */
    public Entry<K, V> entryAt(final int idx) {
	if (idx < 0 || idx >= this.order.size) {
	    return null;
	}
	return new MapEntry(this.order.get(idx));
    }

    /**
     * Removes the key and value at the given index in the iteration order in
     * not-exactly constant time (though it still should be efficient).
     *
     * @param idx the index in the iteration order of the key and value to remove
     * @return the value removed, if there was anything removed, or the default
     *         return value otherwise (often null)
     */
    public V removeAt(final int idx) {
	if (idx < 0 || idx >= this.order.size) {
	    return this.defRetValue;
	}
	final int pos = this.order.get(idx);
	if (this.key[pos] == null) {
	    if (this.containsNullKey) {
		return this.removeNullEntry();
	    }
	    return this.defRetValue;
	}
	return this.removeEntry(pos);
    }

    /**
     * Gets a random value from this OrderedMap in constant time, using the given
     * RNG to generate a random number.
     *
     * @param rng used to generate a random index for a value
     * @return a random value from this OrderedMap
     */
    public V randomValue(final RNG rng) {
	return this.getAt(rng.nextInt(this.order.size));
    }

    /**
     * Gets a random key from this OrderedMap in constant time, using the given RNG
     * to generate a random number.
     *
     * @param rng used to generate a random index for a key
     * @return a random key from this OrderedMap
     */
    public K randomKey(final RNG rng) {
	return this.keyAt(rng.nextInt(this.order.size));
    }

    /**
     * Gets a random entry from this OrderedMap in constant time, using the given
     * RNG to generate a random number.
     *
     * @param rng used to generate a random index for a entry
     * @return a random key-value entry from this OrderedMap
     */
    public Entry<K, V> randomEntry(final RNG rng) {
	return new MapEntry(this.order.getRandomElement(rng));
    }

    /**
     * Randomly alters the iteration order for this OrderedMap using the given RNG
     * to shuffle.
     *
     * @param rng used to generate a random ordering
     * @return this for chaining
     */
    public OrderedMap<K, V> shuffle(final RNG rng) {
	if (this.size < 2) {
	    return this;
	}
	this.order.shuffle(rng);
	this.first = this.order.get(0);
	this.last = this.order.peek();
	return this;
    }

    /**
     * Given an array or varargs of replacement indices for this OrderedMap's
     * iteration order, reorders this so the first item in the returned version is
     * the same as {@code getAt(ordering[0])} (with some care taken for negative or
     * too-large indices), the second item in the returned version is the same as
     * {@code getAt(ordering[1])}, etc. <br>
     * Negative indices are considered reversed distances from the end of ordering,
     * so -1 refers to the same index as {@code ordering[ordering.length - 1]}. If
     * ordering is smaller than {@code size()}, only the indices up to the length of
     * ordering will be modified. If ordering is larger than {@code size()}, only as
     * many indices will be affected as {@code size()}, and reversed distances are
     * measured from the end of this Map's entries instead of the end of ordering.
     * Duplicate values in ordering will produce duplicate values in the returned
     * Map. <br>
     * This method modifies this OrderedMap in-place and also returns it for
     * chaining.
     *
     * @param ordering an array or varargs of int indices, where the nth item in
     *                 ordering changes the nth item in this Map to have the value
     *                 currently in this Map at the index specified by the value in
     *                 ordering
     * @return this for chaining, after modifying it in-place
     */
    public OrderedMap<K, V> reorder(final int... ordering) {
	this.order.reorder(ordering);
	this.first = this.order.get(0);
	this.last = this.order.peek();
	return this;
    }

    /*
     * public V alter(final K original, final K replacement) { if (original == null)
     * { if (containsNullKey) { return alterNullEntry(replacement); } else return
     * put(replacement, null); } else if(hasher.areEqual(original, replacement))
     * return get(original); K curr; final K[] key = this.key; int pos;
     *
     * if ((curr = key[pos = HashCommon.mix(hasher.hash(original)) & mask]) == null)
     * return put(replacement, null); if (hasher.areEqual(original, curr)) return
     * alterEntry(pos, replacement); while (true) { if ((curr = key[pos = (pos + 1)
     * & mask]) == null) return put(replacement, null); if
     * (hasher.areEqual(original, curr)) return alterEntry(pos, replacement); } }
     */
    private int alterEntry(final int pos) {
	this.value[pos] = null;
	this.size--;
	final int idx = this.fixOrder(pos);
	this.shiftKeys(pos);
	return idx;
    }

    private int alterNullEntry() {
	this.containsNullKey = false;
	this.key[this.n] = null;
	this.value[this.n] = null;
	this.size--;
	final int idx = this.fixOrder(this.n);
	return idx;
    }

    /**
     * Swaps a key, original, for another key, replacement, while keeping
     * replacement at the same point in the iteration order as original and keeping
     * it associated with the same value (which also keeps its iteration index).
     * Unlike the similar method {@link #alter(Object, Object)}, this will not
     * change this OrderedMap if replacement is already present. To contrast,
     * alter() can reduce the size of the OrderedMap if both original and
     * replacement are already in the Map. If replacement is found, this returns the
     * default return value, otherwise it switches out original for replacement and
     * returns whatever was associated with original.
     *
     * @param original    the key to find and swap out
     * @param replacement the key to replace original with
     * @return the value associated with original before, and replacement now
     */
    public V alterCarefully(final K original, final K replacement) {
	if (!this.containsKey(replacement)) {
	    return this.alter(original, replacement);
	} else {
	    return this.defRetValue;
	}
    }

    /**
     * Swaps a key, original, for another key, replacement, while keeping
     * replacement at the same point in the iteration order as original and keeping
     * it associated with the same value (which also keeps its iteration index). Be
     * aware that if both original and replacement are present in the OrderedMap,
     * this will still replace original with replacement but will also remove the
     * other occurrence of replacement to avoid duplicate keys. This can throw off
     * the expected order because the duplicate could be at any point in the
     * ordering when it is removed. You may want to prefer
     * {@link #alterCarefully(Object, Object)} if you don't feel like checking by
     * hand for whether replacement is already present, but using this method is
     * perfectly reasonable if you know overlaps won't happen.
     *
     * @param original    the key to find and swap out
     * @param replacement the key to replace original with
     * @return the value associated with original before, and replacement now
     */
    public V alter(final K original, final K replacement) {
	V v;
	int idx;
	if (original == null) {
	    if (this.containsNullKey) {
		v = this.value[this.n];
		idx = this.alterNullEntry();
		this.putAt(replacement, v, idx);
		return v;
	    } else {
		v = this.defRetValue;
	    }
	    return v;
	}
	K curr;
	final K[] key = this.key;
	int pos;
	// The starting point.
	if ((curr = key[pos = HashCommon.mix(this.hasher.hash(original)) & this.mask]) == null) {
	    return this.defRetValue;
	}
	if (this.hasher.areEqual(original, curr)) {
	    v = this.value[pos];
	    idx = this.alterEntry(pos);
	    this.putAt(replacement, v, idx);
	    return v;
	}
	while (true) {
	    if ((curr = key[pos = pos + 1 & this.mask]) == null) {
		return this.defRetValue;
	    }
	    if (this.hasher.areEqual(original, curr)) {
		v = this.value[pos];
		idx = this.alterEntry(pos);
		this.putAt(replacement, v, idx);
		return v;
	    }
	}
    }

    public List<V> getMany(final Collection<K> keys) {
	if (keys == null) {
	    return new ArrayList<>(1);
	}
	final ArrayList<V> vals = new ArrayList<>(keys.size());
	for (final K k : keys) {
	    vals.add(this.get(k));
	}
	return vals;
    }

    /**
     * Changes the K at the given index to replacement while keeping replacement at
     * the same point in the ordering. Be aware that if replacement is present in
     * the OrderedMap, this will still replace the given index with replacement but
     * will also remove the other occurrence of replacement to avoid duplicate keys.
     * This can throw off the expected order because the duplicate could be at any
     * point in the ordering when it is removed. You may want to prefer
     * {@link #alterAtCarefully(int, Object)} if you don't feel like checking by
     * hand for whether replacement is already present, but using this method is
     * perfectly reasonable if you know overlaps won't happen.
     *
     * @param index       an index to replace the K key at
     * @param replacement another K key that will replace the original at the
     *                    remembered index
     * @return the value associated with the possibly-altered key
     */
    public V alterAt(final int index, final K replacement) {
	return this.alter(this.keyAt(index), replacement);
    }

    /**
     * Changes the K at the given index to replacement while keeping replacement at
     * the same point in the ordering. Unlike the similar method
     * {@link #alterAt(int, Object)}, this will not change this OrderedMap if
     * replacement is already present. To contrast, alterAt() can reduce the size of
     * the OrderedMap if replacement is already in the Map. If replacement is found,
     * this returns the default return value, otherwise it switches out the index
     * for replacement and returns whatever value was at the index before.
     *
     * @param index       an index to replace the K key at
     * @param replacement another K key that will replace the original at the
     *                    remembered index
     * @return the value associated with the key at the altered index before, and
     *         replacement now
     */
    public V alterAtCarefully(final int index, final K replacement) {
	return this.alterCarefully(this.keyAt(index), replacement);
    }

    /**
     * If the specified key is not already associated with a value (or is mapped to
     * {@code null}) associates it with the given value and returns {@code null},
     * else returns the current value.
     *
     * @param key   key with which the specified value is to be associated
     * @param value value to be associated with the specified key
     * @return the previous value associated with the specified key, or {@code null}
     *         if there was no mapping for the key. (A {@code null} return can also
     *         indicate that the map previously associated {@code null} with the
     *         key.)
     */
    @Override
    public V putIfAbsent(final K key, final V value) {
	V v = this.get(key);
	if (v == null) {
	    v = this.put(key, value);
	}
	return v;
    }

    /**
     * Removes the entry for the specified key only if it is currently mapped to the
     * specified value.
     *
     * @param key   key with which the specified value is associated
     * @param value value expected to be associated with the specified key
     * @return {@code true} if the value was removed
     */
    @Override
    public boolean remove(final Object key, final Object value) {
	if (this.containsKey(key) && Objects.equals(this.get(key), value)) {
	    this.remove(key);
	    return true;
	} else {
	    return false;
	}
    }

    /**
     * Replaces the entry for the specified key only if currently mapped to the
     * specified value. The position in the iteration order is retained.
     *
     * @param key      key with which the specified value is associated
     * @param oldValue value expected to be associated with the specified key
     * @param newValue value to be associated with the specified key
     * @return {@code true} if the value was replaced
     */
    @Override
    public boolean replace(final K key, final V oldValue, final V newValue) {
	if (this.containsKey(key) && Objects.equals(this.get(key), this.value)) {
	    this.put(key, newValue);
	    return true;
	} else {
	    return false;
	}
    }

    /**
     * Replaces the entry for the specified key only if it is currently mapped to
     * some value. Preserves the existing key's position in the iteration order.
     *
     * @param key   key with which the specified value is associated
     * @param value value to be associated with the specified key
     * @return the previous value associated with the specified key, or {@code null}
     *         if there was no mapping for the key. (A {@code null} return can also
     *         indicate that the map previously associated {@code null} with the
     *         key.)
     */
    @Override
    public V replace(final K key, final V value) {
	if (this.containsKey(key)) {
	    return this.put(key, value);
	} else {
	    return null;
	}
    }
}
