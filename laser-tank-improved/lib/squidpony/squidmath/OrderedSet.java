/*
 * Copyright (C) 2002-2015 Sebastiano Vigna
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package squidpony.squidmath;

import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.ListIterator;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.SortedSet;

import squidpony.annotation.GwtIncompatible;

/**
 * A generic linked hash set with with a fast implementation, originally from
 * fastutil as ObjectLinkedOpenHashSet but modified to support indexed access of
 * items, reordering, and optional hash strategies for array keys (which
 * fastutil does differently).
 * <p>
 * Instances of this class use a hash table to represent a set. The table is
 * filled up to a specified <em>load factor</em>, and then doubled in size to
 * accommodate new entries. If the table is emptied below <em>one fourth</em> of
 * the load factor, it is halved in size. However, halving is not performed when
 * deleting entries from an iterator, as it would interfere with the iteration
 * process.
 * </p>
 * <p>
 * Note that {@link #clear()} does not modify the hash table size. Rather, a
 * family of {@linkplain #trim() trimming methods} lets you control the size of
 * the table; this is particularly useful if you reuse instances of this class.
 * </p>
 * <p>
 * Iterators generated by this set will enumerate elements in the same order in
 * which they have been added to the set (addition of elements already present
 * in the set does not change the iteration order). Note that this order has
 * nothing in common with the natural order of the keys. The order is kept by
 * means of an array list, represented <i>via</i> an IntVLA parallel to the
 * table that can be modified with methods like {@link #shuffle(RNG)}.
 * </p>
 * <p>
 * This class implements the interface of a sorted set, so to allow easy access
 * of the iteration order: for instance, you can get the first element in
 * iteration order with {@code first()} without having to create an iterator;
 * however, this class partially violates the {@link java.util.SortedSet}
 * contract because all subset methods throw an exception and
 * {@link #comparator()} returns always <code>null</code>.
 * <p>
 * <p>
 * Additional methods, such as <code>addAndMoveToFirst()</code>, make it easy to
 * use instances of this class as a cache (e.g., with LRU policy).
 * </p>
 * <p>
 * This class allows approximately constant-time lookup of keys or values by
 * their index in the ordering, which can allow some novel usage of the data
 * structure. OrderedSet can be used like a list of unique elements, keeping
 * order like a list does but also allowing rapid checks for whether an item
 * exists in the OrderedSet, and {@link OrderedMap} can be used like that but
 * with values associated as well (where OrderedSet uses contains(), OrderedMap
 * uses containsKey()). You can also set the item at a position with
 * {@link #addAt(Object, int)}, or alter an item while keeping index the same
 * with {@link #alter(Object, Object)}. Reordering works here too, both with
 * completely random orders from {@link #shuffle(RNG)} or with a
 * previously-generated ordering from {@link #reorder(int...)} (you can produce
 * such an ordering for a given size and reuse it across multiple Ordered data
 * structures with {@link RNG#randomOrdering(int)}).
 * </p>
 * <p>
 * You can pass an {@link CrossHash.IHasher} instance such as
 * {@link CrossHash#generalHasher} as an extra parameter to most of this class'
 * constructors, which allows the OrderedSet to use arrays (usually primitive
 * arrays) as items. If you expect only one type of array, you can use an
 * instance like {@link CrossHash#intHasher} to hash int arrays, or the
 * aforementioned generalHasher to hash most kinds of arrays (it can't handle
 * most multi-dimensional arrays well). If you aren't using array items, you
 * don't need to give an IHasher to the constructor and can ignore this feature.
 * </p>
 * <br>
 * Thank you, Sebastiano Vigna, for making FastUtil available to the public with
 * such high quality. <br>
 * See https://github.com/vigna/fastutil for the original library.
 *
 * @author Sebastiano Vigna (responsible for all the hard parts)
 * @author Tommy Ettinger (mostly responsible for squashing several layers of
 *         parent classes into one monster class)
 */
public class OrderedSet<K> implements SortedSet<K>, java.io.Serializable, Cloneable {
    private static final long serialVersionUID = 0L;
    /**
     * The array of keys.
     */
    protected K[] key;
    /**
     * The array of values.
     */
    // protected V[] value;
    /**
     * The mask for wrapping a position counter.
     */
    protected int mask;
    /**
     * Whether this set contains the key zero.
     */
    protected boolean containsNull;
    /**
     * The index of the first entry in iteration order. It is valid iff
     * {@link #size} is nonzero; otherwise, it contains -1.
     */
    protected int first = -1;
    /**
     * The index of the last entry in iteration order. It is valid iff {@link #size}
     * is nonzero; otherwise, it contains -1.
     */
    protected int last = -1;
    /*
     * For each entry, the next and the previous entry in iteration order, stored as
     * <code>((prev & 0xFFFFFFFFL) << 32) | (next & 0xFFFFFFFFL)</code>. The first
     * entry contains predecessor -1, and the last entry contains successor -1.
     */
    // protected long[] link;
    protected IntVLA order;
    /**
     * The current table size.
     */
    protected int n;
    /**
     * Threshold after which we rehash. It must be the table size times {@link #f}.
     */
    protected int maxFill;
    /**
     * Number of entries in the set (including the key zero, if present).
     */
    protected int size;
    /**
     * The acceptable load factor.
     */
    public final float f;
    /**
     * The initial default size of a hash table.
     */
    public static final int DEFAULT_INITIAL_SIZE = 16;
    /**
     * The default load factor of a hash table.
     */
    public static final float DEFAULT_LOAD_FACTOR = .375f; // .1875f; // .75f;
    /**
     * The load factor for a (usually small) table that is meant to be particularly
     * fast.
     */
    public static final float FAST_LOAD_FACTOR = .5f;
    /**
     * The load factor for a (usually very small) table that is meant to be
     * extremely fast.
     */
    public static final float VERY_FAST_LOAD_FACTOR = .25f;
    protected CrossHash.IHasher hasher = null;

    /**
     * Creates a new hash map.
     * <p>
     * <p>
     * The actual table size will be the least power of two greater than
     * <code>expected</code>/<code>f</code>.
     *
     * @param expected the expected number of elements in the hash set.
     * @param f        the load factor.
     */
    @SuppressWarnings("unchecked")
    public OrderedSet(final int expected, final float f) {
	if (f <= 0 || f > 1) {
	    throw new IllegalArgumentException("Load factor must be greater than 0 and smaller than or equal to 1");
	}
	if (expected < 0) {
	    throw new IllegalArgumentException("The expected number of elements must be nonnegative");
	}
	this.f = f;
	this.n = OrderedSet.arraySize(expected, f);
	this.mask = this.n - 1;
	this.maxFill = OrderedSet.maxFill(this.n, f);
	this.key = (K[]) new Object[this.n + 1];
	// link = new long[n + 1];
	this.order = new IntVLA(expected);
	this.hasher = CrossHash.defaultHasher;
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load factor.
     *
     * @param expected the expected number of elements in the hash set.
     */
    public OrderedSet(final int expected) {
	this(expected, OrderedSet.DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new hash set with initial expected {@link #DEFAULT_INITIAL_SIZE}
     * elements and {@link #DEFAULT_LOAD_FACTOR} as load factor.
     */
    public OrderedSet() {
	this(OrderedSet.DEFAULT_INITIAL_SIZE, OrderedSet.DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new hash set copying a given collection.
     *
     * @param c a {@link Collection} to be copied into the new hash set.
     * @param f the load factor.
     */
    public OrderedSet(final Collection<? extends K> c, final float f) {
	this(c.size(), f, c instanceof OrderedSet ? ((OrderedSet) c).hasher : CrossHash.defaultHasher);
	this.addAll(c);
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load factor
     * copying a given collection.
     *
     * @param c a {@link Collection} to be copied into the new hash set.
     */
    public OrderedSet(final Collection<? extends K> c) {
	this(c, c instanceof OrderedSet ? ((OrderedSet) c).f : OrderedSet.DEFAULT_LOAD_FACTOR,
		c instanceof OrderedSet ? ((OrderedSet) c).hasher : CrossHash.defaultHasher);
    }

    /**
     * Creates a new hash set using elements provided by a type-specific iterator.
     *
     * @param i a type-specific iterator whose elements will fill the set.
     * @param f the load factor.
     */
    public OrderedSet(final Iterator<? extends K> i, final float f) {
	this(OrderedSet.DEFAULT_INITIAL_SIZE, f);
	while (i.hasNext()) {
	    this.add(i.next());
	}
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load factor using
     * elements provided by a type-specific iterator.
     *
     * @param i a type-specific iterator whose elements will fill the set.
     */
    public OrderedSet(final Iterator<? extends K> i) {
	this(i, OrderedSet.DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new hash set and fills it with the elements of a given array.
     *
     * @param a      an array whose elements will be used to fill the set.
     * @param offset the first element to use.
     * @param length the number of elements to use.
     * @param f      the load factor.
     */
    public OrderedSet(final K[] a, final int offset, final int length, final float f) {
	this(length < 0 ? 0 : length, f);
	if (a == null) {
	    throw new NullPointerException("Array passed to OrderedSet constructor cannot be null");
	}
	if (offset < 0) {
	    throw new ArrayIndexOutOfBoundsException("Offset (" + offset + ") is negative");
	}
	if (length < 0) {
	    throw new IllegalArgumentException("Length (" + length + ") is negative");
	}
	if (offset + length > a.length) {
	    throw new ArrayIndexOutOfBoundsException(
		    "Last index (" + (offset + length) + ") is greater than array length (" + a.length + ")");
	}
	for (int i = 0; i < length; i++) {
	    this.add(a[offset + i]);
	}
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load factor and
     * fills it with the elements of a given array.
     *
     * @param a      an array whose elements will be used to fill the set.
     * @param offset the first element to use.
     * @param length the number of elements to use.
     */
    public OrderedSet(final K[] a, final int offset, final int length) {
	this(a, offset, length, OrderedSet.DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new hash set copying the elements of an array.
     *
     * @param a an array to be copied into the new hash set.
     * @param f the load factor.
     */
    public OrderedSet(final K[] a, final float f) {
	this(a, 0, a.length, f);
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load factor
     * copying the elements of an array.
     *
     * @param a an array to be copied into the new hash set.
     */
    public OrderedSet(final K[] a) {
	this(a, OrderedSet.DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new hash map.
     * <p>
     * <p>
     * The actual table size will be the least power of two greater than
     * <code>expected</code>/<code>f</code>.
     *
     * @param expected the expected number of elements in the hash set.
     * @param f        the load factor.
     * @param hasher   used to hash items; typically only needed when K is an array,
     *                 where CrossHash has implementations
     */
    @SuppressWarnings("unchecked")
    public OrderedSet(final int expected, final float f, final CrossHash.IHasher hasher) {
	if (f <= 0 || f > 1) {
	    throw new IllegalArgumentException("Load factor must be greater than 0 and smaller than or equal to 1");
	}
	if (expected < 0) {
	    throw new IllegalArgumentException("The expected number of elements must be nonnegative");
	}
	this.f = f;
	this.n = OrderedSet.arraySize(expected, f);
	this.mask = this.n - 1;
	this.maxFill = OrderedSet.maxFill(this.n, f);
	this.key = (K[]) new Object[this.n + 1];
	// link = new long[n + 1];
	this.order = new IntVLA(expected);
	this.hasher = hasher == null ? CrossHash.defaultHasher : hasher;
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load factor.
     *
     * @param hasher used to hash items; typically only needed when K is an array,
     *               where CrossHash has implementations
     */
    public OrderedSet(final CrossHash.IHasher hasher) {
	this(OrderedSet.DEFAULT_INITIAL_SIZE, OrderedSet.DEFAULT_LOAD_FACTOR, hasher);
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load factor.
     *
     * @param hasher used to hash items; typically only needed when K is an array,
     *               where CrossHash has implementations
     */
    public OrderedSet(final int expected, final CrossHash.IHasher hasher) {
	this(expected, OrderedSet.DEFAULT_LOAD_FACTOR, hasher);
    }

    /**
     * Creates a new hash set copying a given collection.
     *
     * @param c      a {@link Collection} to be copied into the new hash set.
     * @param f      the load factor.
     * @param hasher used to hash items; typically only needed when K is an array,
     *               where CrossHash has implementations
     */
    public OrderedSet(final Collection<? extends K> c, final float f, final CrossHash.IHasher hasher) {
	this(c.size(), f, hasher);
	this.addAll(c);
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load factor
     * copying a given collection.
     *
     * @param c      a {@link Collection} to be copied into the new hash set.
     * @param hasher used to hash items; typically only needed when K is an array,
     *               where CrossHash has implementations
     */
    public OrderedSet(final Collection<? extends K> c, final CrossHash.IHasher hasher) {
	this(c, OrderedSet.DEFAULT_LOAD_FACTOR, hasher);
    }

    /**
     * Creates a new hash set and fills it with the elements of a given array.
     *
     * @param a      an array whose elements will be used to fill the set.
     * @param offset the first element to use.
     * @param length the number of elements to use.
     * @param f      the load factor.
     */
    public OrderedSet(final K[] a, final int offset, final int length, final float f, final CrossHash.IHasher hasher) {
	this(length < 0 ? 0 : length, f, hasher);
	if (a == null) {
	    throw new NullPointerException("Array passed to OrderedSet constructor cannot be null");
	}
	if (offset < 0) {
	    throw new ArrayIndexOutOfBoundsException("Offset (" + offset + ") is negative");
	}
	if (length < 0) {
	    throw new IllegalArgumentException("Length (" + length + ") is negative");
	}
	if (offset + length > a.length) {
	    throw new ArrayIndexOutOfBoundsException(
		    "Last index (" + (offset + length) + ") is greater than array length (" + a.length + ")");
	}
	for (int i = 0; i < length; i++) {
	    this.add(a[offset + i]);
	}
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load factor and
     * fills it with the elements of a given array.
     *
     * @param a      an array whose elements will be used to fill the set.
     * @param offset the first element to use.
     * @param length the number of elements to use.
     */
    public OrderedSet(final K[] a, final int offset, final int length, final CrossHash.IHasher hasher) {
	this(a, offset, length, OrderedSet.DEFAULT_LOAD_FACTOR, hasher);
    }

    /**
     * Creates a new hash set copying the elements of an array.
     *
     * @param a an array to be copied into the new hash set.
     * @param f the load factor.
     */
    public OrderedSet(final K[] a, final float f, final CrossHash.IHasher hasher) {
	this(a, 0, a.length, f, hasher);
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load factor
     * copying the elements of an array.
     *
     * @param a an array to be copied into the new hash set.
     */
    public OrderedSet(final K[] a, final CrossHash.IHasher hasher) {
	this(a, OrderedSet.DEFAULT_LOAD_FACTOR, hasher);
    }

    private int realSize() {
	return this.containsNull ? this.size - 1 : this.size;
    }

    private void ensureCapacity(final int capacity) {
	final int needed = OrderedSet.arraySize(capacity, this.f);
	if (needed > this.n) {
	    this.rehash(needed);
	}
    }

    private void tryCapacity(final long capacity) {
	final int needed = (int) Math.min(1 << 30,
		Math.max(2, HashCommon.nextPowerOfTwo((long) Math.ceil(capacity / this.f))));
	if (needed > this.n) {
	    this.rehash(needed);
	}
    }

    @Override
    public boolean addAll(final Collection<? extends K> c) {
	int n = c.size();
	// The resulting collection will be at least c.size() big
	if (this.f <= .5) {
	    this.ensureCapacity(n); // The resulting collection will be sized
	    // for c.size() elements
	} else {
	    this.tryCapacity(this.size() + n); // The resulting collection will be
	}
	// tentatively sized for size() + c.size() elements
	boolean retVal = false;
	final Iterator<? extends K> i = c.iterator();
	while (n-- != 0) {
	    if (this.add(i.next())) {
		retVal = true;
	    }
	}
	return retVal;
    }

    public boolean addAll(final K[] a) {
	if (a == null) {
	    return false;
	}
	final int n = a.length;
	// The resulting collection will be at least a.length big
	if (this.f <= .5) {
	    this.ensureCapacity(n); // The resulting collection will be sized
	    // for a.length elements
	} else {
	    this.tryCapacity(this.size() + n); // The resulting collection will be
	}
	// tentatively sized for size() + a.length elements
	boolean retVal = false;
	for (int i = 0; i < n; i++) {
	    if (this.add(a[i])) {
		retVal = true;
	    }
	}
	return retVal;
    }

    @Override
    public boolean add(final K k) {
	int pos;
	if (k == null) {
	    if (this.containsNull) {
		return false;
	    }
	    pos = this.n;
	    this.containsNull = true;
	} else {
	    K curr;
	    final K[] key = this.key;
	    // The starting point.
	    if (!((curr = key[pos = HashCommon.mix(this.hasher.hash(k)) & this.mask]) == null)) {
		if (this.hasher.areEqual(curr, k)) {
		    return false;
		}
		while (!((curr = key[pos = pos + 1 & this.mask]) == null)) {
		    if (this.hasher.areEqual(curr, k)) {
			return false;
		    }
		}
	    }
	    key[pos] = k;
	}
	if (this.size == 0) {
	    this.first = this.last = pos;
	} else {
	    this.last = pos;
	}
	this.order.add(pos);
	if (this.size++ >= this.maxFill) {
	    this.rehash(OrderedSet.arraySize(this.size + 1, this.f));
	}
	return true;
    }

    public boolean addAt(final K k, final int idx) {
	if (idx <= 0) {
	    return this.addAndMoveToFirst(k);
	} else if (idx >= this.size) {
	    return this.addAndMoveToLast(k);
	}
	int pos;
	if (k == null) {
	    if (this.containsNull) {
		return false;
	    }
	    pos = this.n;
	    this.containsNull = true;
	} else {
	    K curr;
	    final K[] key = this.key;
	    // The starting point.
	    if (!((curr = key[pos = HashCommon.mix(this.hasher.hash(k)) & this.mask]) == null)) {
		if (this.hasher.areEqual(curr, k)) {
		    return false;
		}
		while (!((curr = key[pos = pos + 1 & this.mask]) == null)) {
		    if (this.hasher.areEqual(curr, k)) {
			return false;
		    }
		}
	    }
	    key[pos] = k;
	}
	this.order.insert(idx, pos);
	if (this.size++ >= this.maxFill) {
	    this.rehash(OrderedSet.arraySize(this.size + 1, this.f));
	}
	return true;
    }

    /**
     * Add a random element if not present, get the existing value if already
     * present.
     * <p>
     * This is equivalent to (but faster than) doing a:
     * <p>
     *
     * <pre>
     * K exist = set.get(k);
     * if (exist == null) {
     *     set.add(k);
     *     exist = k;
     * }
     * </pre>
     */
    public K addOrGet(final K k) {
	int pos;
	if (k == null) {
	    if (this.containsNull) {
		return this.key[this.n];
	    }
	    pos = this.n;
	    this.containsNull = true;
	} else {
	    K curr;
	    final K[] key = this.key;
	    // The starting point.
	    if (!((curr = key[pos = HashCommon.mix(this.hasher.hash(k)) & this.mask]) == null)) {
		if (this.hasher.areEqual(curr, k)) {
		    return curr;
		}
		while (!((curr = key[pos = pos + 1 & this.mask]) == null)) {
		    if (this.hasher.areEqual(curr, k)) {
			return curr;
		    }
		}
	    }
	    key[pos] = k;
	}
	if (this.size == 0) {
	    this.first = this.last = pos;
	    // Special case of SET_UPPER_LOWER( link[ pos ], -1, -1 );
	    // link[pos] = -1L;
	} else {
	    // link[last] ^= ((link[last] ^ (pos & 0xFFFFFFFFL)) & 0xFFFFFFFFL);
	    // link[pos] = ((last & 0xFFFFFFFFL) << 32) | (-1 & 0xFFFFFFFFL);
	    this.last = pos;
	}
	this.order.add(pos);
	if (this.size++ >= this.maxFill) {
	    this.rehash(OrderedSet.arraySize(this.size + 1, this.f));
	}
	return k;
    }

    /**
     * Shifts left entries with the specified hash code, starting at the specified
     * position, and empties the resulting free entry.
     *
     * @param pos a starting position.
     */
    protected final void shiftKeys(int pos) {
	// Shift entries with the same hash.
	int last, slot;
	K curr;
	final K[] key = this.key;
	for (;;) {
	    pos = (last = pos) + 1 & this.mask;
	    for (;;) {
		if ((curr = key[pos]) == null) {
		    key[last] = null;
		    return;
		}
		slot = HashCommon.mix(this.hasher.hash(curr)) & this.mask;
		if (last <= pos ? last >= slot || slot > pos : last >= slot && slot > pos) {
		    break;
		}
		pos = pos + 1 & this.mask;
	    }
	    key[last] = curr;
	    this.fixOrder(pos, last);
	}
    }

    private boolean removeEntry(final int pos) {
	this.size--;
	this.fixOrder(pos);
	this.shiftKeys(pos);
	if (this.size < this.maxFill / 4 && this.n > OrderedSet.DEFAULT_INITIAL_SIZE) {
	    this.rehash(this.n / 2);
	}
	return true;
    }

    private boolean removeNullEntry() {
	this.containsNull = false;
	this.key[this.n] = null;
	this.size--;
	this.fixOrder(this.n);
	if (this.size < this.maxFill / 4 && this.n > OrderedSet.DEFAULT_INITIAL_SIZE) {
	    this.rehash(this.n / 2);
	}
	return true;
    }

    @SuppressWarnings("unchecked")
    protected boolean rem(final Object k) {
	if (k == null) {
	    return this.containsNull && this.removeNullEntry();
	}
	K curr;
	final K[] key = this.key;
	int pos;
	// The starting point.
	if ((curr = key[pos = HashCommon.mix(this.hasher.hash(k)) & this.mask]) == null) {
	    return false;
	}
	if (this.hasher.areEqual(k, curr)) {
	    return this.removeEntry(pos);
	}
	while (true) {
	    if ((curr = key[pos = pos + 1 & this.mask]) == null) {
		return false;
	    }
	    if (this.hasher.areEqual(k, curr)) {
		return this.removeEntry(pos);
	    }
	}
    }

    @Override
    public boolean remove(final Object o) {
	return this.rem(o);
    }

    /**
     * Removes the first key in iteration order.
     *
     * @return the first key.
     * @throws NoSuchElementException is this set is empty.
     */
    public K removeFirst() {
	if (this.size == 0) {
	    throw new NoSuchElementException();
	}
	final int pos = this.first;
	this.order.removeIndex(0);
	if (this.order.size > 0) {
	    this.first = this.order.get(0);
	} else {
	    this.first = -1;
	}
	// Abbreviated version of fixOrder(pos)
	/*
	 * first = (int) link[pos]; if (0 <= first) { // Special case of SET_PREV( link[
	 * first ], -1 ) link[first] |= (-1 & 0xFFFFFFFFL) << 32; }
	 */
	final K k = this.key[pos];
	this.size--;
	if (k == null) {
	    this.containsNull = false;
	    this.key[this.n] = null;
	} else {
	    this.shiftKeys(pos);
	}
	if (this.size < this.maxFill / 4 && this.n > OrderedSet.DEFAULT_INITIAL_SIZE) {
	    this.rehash(this.n / 2);
	}
	return k;
    }

    /**
     * Removes the the last key in iteration order.
     *
     * @return the last key.
     * @throws NoSuchElementException is this set is empty.
     */
    public K removeLast() {
	if (this.size == 0) {
	    throw new NoSuchElementException();
	}
	final int pos = this.last;
	this.order.pop();
	if (this.order.size > 0) {
	    this.last = this.order.get(this.order.size - 1);
	} else {
	    this.last = -1;
	}
	// Abbreviated version of fixOrder(pos)
	/*
	 * last = (int) (link[pos] >>> 32); if (0 <= last) { // Special case of
	 * SET_NEXT( link[ last ], -1 ) link[last] |= -1 & 0xFFFFFFFFL; }
	 */
	final K k = this.key[pos];
	this.size--;
	if (k == null) {
	    this.containsNull = false;
	    this.key[this.n] = null;
	} else {
	    this.shiftKeys(pos);
	}
	if (this.size < this.maxFill / 4 && this.n > OrderedSet.DEFAULT_INITIAL_SIZE) {
	    this.rehash(this.n / 2);
	}
	return k;
    }

    private void moveIndexToFirst(final int i) {
	if (this.size <= 1 || this.first == i) {
	    return;
	}
	this.order.moveToFirst(i);
	if (this.last == i) {
	    this.last = this.order.peek();
	    // last = (int) (link[i] >>> 32);
	    // Special case of SET_NEXT( link[ last ], -1 );
	    // link[last] |= -1 & 0xFFFFFFFFL;
	} /*
	   * else { final long linki = link[i]; final int prev = (int) (linki >>> 32);
	   * final int next = (int) linki; link[prev] ^= ((link[prev] ^ (linki &
	   * 0xFFFFFFFFL)) & 0xFFFFFFFFL); link[next] ^= ((link[next] ^ (linki &
	   * 0xFFFFFFFF00000000L)) & 0xFFFFFFFF00000000L); } link[first] ^= ((link[first]
	   * ^ ((i & 0xFFFFFFFFL) << 32)) & 0xFFFFFFFF00000000L); link[i] = ((-1 &
	   * 0xFFFFFFFFL) << 32) | (first & 0xFFFFFFFFL);
	   */
	this.first = i;
    }

    private void moveIndexToLast(final int i) {
	if (this.size <= 1 || this.last == i) {
	    return;
	}
	this.order.moveToLast(i);
	if (this.first == i) {
	    this.first = this.order.get(0);
	    // first = (int) link[i];
	    // Special case of SET_PREV( link[ first ], -1 );
	    // link[first] |= (-1 & 0xFFFFFFFFL) << 32;
	} /*
	   * else { final long linki = link[i]; final int prev = (int) (linki >>> 32);
	   * final int next = (int) linki; link[prev] ^= ((link[prev] ^ (linki &
	   * 0xFFFFFFFFL)) & 0xFFFFFFFFL); link[next] ^= ((link[next] ^ (linki &
	   * 0xFFFFFFFF00000000L)) & 0xFFFFFFFF00000000L); } link[last] ^= ((link[last] ^
	   * (i & 0xFFFFFFFFL)) & 0xFFFFFFFFL); link[i] = ((last & 0xFFFFFFFFL) << 32) |
	   * (-1 & 0xFFFFFFFFL);
	   */
	this.last = i;
    }

    /**
     * Adds a key to the set; if the key is already present, it is moved to the
     * first position of the iteration order.
     *
     * @param k the key.
     * @return true if the key was not present.
     */
    public boolean addAndMoveToFirst(final K k) {
	int pos;
	if (k == null) {
	    if (this.containsNull) {
		this.moveIndexToFirst(this.n);
		return false;
	    }
	    this.containsNull = true;
	    pos = this.n;
	} else {
	    // The starting point.
	    final K key[] = this.key;
	    pos = HashCommon.mix(this.hasher.hash(k)) & this.mask;
	    while (!(key[pos] == null)) {
		if (this.hasher.areEqual(k, key[pos])) {
		    this.moveIndexToFirst(pos);
		    return false;
		}
		pos = pos + 1 & this.mask;
	    }
	}
	this.key[pos] = k;
	if (this.size == 0) {
	    this.first = this.last = pos;
	    // Special case of SET_UPPER_LOWER( link[ pos ], -1, -1 );
	    // link[pos] = -1L;
	} else {
	    // link[first] ^= ((link[first] ^ ((pos & 0xFFFFFFFFL) << 32)) &
	    // 0xFFFFFFFF00000000L);
	    // link[pos] = ((-1 & 0xFFFFFFFFL) << 32) | (first & 0xFFFFFFFFL);
	    this.first = pos;
	}
	this.order.insert(0, pos);
	if (this.size++ >= this.maxFill) {
	    this.rehash(OrderedSet.arraySize(this.size, this.f));
	}
	return true;
    }

    /**
     * Adds a key to the set; if the key is already present, it is moved to the last
     * position of the iteration order.
     *
     * @param k the key.
     * @return true if the key was not present.
     */
    public boolean addAndMoveToLast(final K k) {
	int pos;
	if (k == null) {
	    if (this.containsNull) {
		this.moveIndexToLast(this.n);
		return false;
	    }
	    this.containsNull = true;
	    pos = this.n;
	} else {
	    // The starting point.
	    final K key[] = this.key;
	    pos = HashCommon.mix(this.hasher.hash(k)) & this.mask;
	    // There's always an unused entry.
	    while (!(key[pos] == null)) {
		if (this.hasher.areEqual(k, key[pos])) {
		    this.moveIndexToLast(pos);
		    return false;
		}
		pos = pos + 1 & this.mask;
	    }
	}
	this.key[pos] = k;
	if (this.size == 0) {
	    this.first = this.last = pos;
	    // Special case of SET_UPPER_LOWER( link[ pos ], -1, -1 );
	    // link[pos] = -1L;
	} else {
	    // link[last] ^= ((link[last] ^ (pos & 0xFFFFFFFFL)) & 0xFFFFFFFFL);
	    // link[pos] = ((last & 0xFFFFFFFFL) << 32) | (-1 & 0xFFFFFFFFL);
	    this.last = pos;
	}
	this.order.add(pos);
	if (this.size++ >= this.maxFill) {
	    this.rehash(OrderedSet.arraySize(this.size, this.f));
	}
	return true;
    }

    /**
     * Returns the element of this set that is equal to the given key, or
     * <code>null</code>.
     *
     * @return the element of this set that is equal to the given key, or
     *         <code>null</code>.
     */
    public K get(final Object k) {
	if (k == null) {
	    return this.key[this.n]; // This is correct independently of the value of
	}
	// containsNull and of the map being custom
	K curr;
	final K[] key = this.key;
	int pos;
	// The starting point.
	if ((curr = key[pos = HashCommon.mix(this.hasher.hash(k)) & this.mask]) == null) {
	    return null;
	}
	if (this.hasher.areEqual(k, curr)) {
	    return curr;
	}
	// There's always an unused entry.
	while (true) {
	    if ((curr = key[pos = pos + 1 & this.mask]) == null) {
		return null;
	    }
	    if (this.hasher.areEqual(k, curr)) {
		return curr;
	    }
	}
    }

    @Override
    public boolean contains(final Object k) {
	if (k == null) {
	    return this.containsNull;
	}
	K curr;
	final K[] key = this.key;
	int pos;
	// The starting point.
	if ((curr = key[pos = HashCommon.mix(this.hasher.hash(k)) & this.mask]) == null) {
	    return false;
	}
	if (this.hasher.areEqual(k, curr)) {
	    return true;
	}
	// There's always an unused entry.
	while (true) {
	    if ((curr = key[pos = pos + 1 & this.mask]) == null) {
		return false;
	    }
	    if (this.hasher.areEqual(k, curr)) {
		return true;
	    }
	}
    }

    protected int positionOf(final Object k) {
	if (k == null) {
	    if (this.containsNull) {
		return this.n;
	    } else {
		return -1;
	    }
	}
	K curr;
	final K[] key = this.key;
	int pos;
	// The starting point.
	if ((curr = key[pos = HashCommon.mix(this.hasher.hash(k)) & this.mask]) == null) {
	    return -1;
	}
	if (this.hasher.areEqual(k, curr)) {
	    return pos;
	}
	// There's always an unused entry.
	while (true) {
	    if ((curr = key[pos = pos + 1 & this.mask]) == null) {
		return -1;
	    }
	    if (this.hasher.areEqual(k, curr)) {
		return pos;
	    }
	}
    }

    /**
     * Gets the position in the ordering of the given key, though not as efficiently
     * as some data structures can do it (e.g. {@link Arrangement} can access
     * ordering position very quickly but doesn't store other values on its own).
     * Returns a value that is at least 0 if it found k, or -1 if k was not present.
     *
     * @param k a key or possible key that this should find the index of
     * @return the index of k, if present, or -1 if it is not present in this
     *         OrderedSet
     */
    public int indexOf(final Object k) {
	final int pos = this.positionOf(k);
	return pos < 0 ? -1 : this.order.indexOf(pos);
    }

    /**
     * Swaps the positions in the ordering for the given items, if they are both
     * present. Returns true if the ordering changed as a result of this call, or
     * false if it stayed the same (which can be because left or right was not
     * present, or because left and right are the same reference (so swapping would
     * do nothing)).
     *
     * @param left  an item that should be present in this OrderedSet
     * @param right an item that should be present in this OrderedSet
     * @return true if this OrderedSet changed in ordering as a result of this call,
     *         or false otherwise
     */
    public boolean swap(final K left, final K right) {
	if (left == right) {
	    return false;
	}
	final int l = this.indexOf(left);
	if (l < 0) {
	    return false;
	}
	final int r = this.indexOf(right);
	if (r < 0) {
	    return false;
	}
	this.order.swap(l, r);
	return true;
    }

    /**
     * Swaps the given indices in the ordering, if they are both ints between 0 and
     * size. Returns true if the ordering changed as a result of this call, or false
     * if it stayed the same (which can be because left or right referred to an
     * out-of-bounds index, or because left and right are equal (so swapping would
     * do nothing)).
     *
     * @param left  an index of an item in this OrderedSet, at least 0 and less than
     *              {@link #size()}
     * @param right an index of an item in this OrderedSet, at least 0 and less than
     *              {@link #size()}
     * @return true if this OrderedSet changed in ordering as a result of this call,
     *         or false otherwise
     */
    public boolean swapIndices(final int left, final int right) {
	if (left < 0 || right < 0 || left >= this.order.size || right >= this.order.size || left == right) {
	    return false;
	}
	this.order.swap(left, right);
	return true;
    }

    /*
     * Removes all elements from this set.
     *
     * <P>To increase object reuse, this method does not change the table size. If
     * you want to reduce the table size, you must use {@link #trim()}.
     */
    @Override
    public void clear() {
	if (this.size == 0) {
	    return;
	}
	this.size = 0;
	this.containsNull = false;
	Arrays.fill(this.key, null);
	this.first = this.last = -1;
	this.order.clear();
    }

    @Override
    public int size() {
	return this.size;
    }

    /**
     * Checks whether this collection contains all elements from the given
     * collection.
     *
     * @param c a collection.
     * @return <code>true</code> if this collection contains all elements of the
     *         argument.
     */
    @Override
    public boolean containsAll(final Collection<?> c) {
	int n = c.size();
	final Iterator<?> i = c.iterator();
	while (n-- != 0) {
	    if (!this.contains(i.next())) {
		return false;
	    }
	}
	return true;
    }

    /**
     * Retains in this collection only elements from the given collection.
     *
     * @param c a collection.
     * @return <code>true</code> if this collection changed as a result of the call.
     */
    @Override
    public boolean retainAll(final Collection<?> c) {
	boolean retVal = false;
	int n = this.size();
	final Iterator<?> i = this.iterator();
	while (n-- != 0) {
	    if (!c.contains(i.next())) {
		i.remove();
		retVal = true;
	    }
	}
	return retVal;
    }

    /**
     * Remove from this collection all elements in the given collection. If the
     * collection is an instance of this class, it uses faster iterators.
     *
     * @param c a collection.
     * @return <code>true</code> if this collection changed as a result of the call.
     */
    @Override
    public boolean removeAll(final Collection<?> c) {
	boolean retVal = false;
	int n = c.size();
	final Iterator<?> i = c.iterator();
	while (n-- != 0) {
	    if (this.remove(i.next())) {
		retVal = true;
	    }
	}
	return retVal;
    }

    @Override
    public boolean isEmpty() {
	return this.size() == 0;
    }

    /**
     * Modifies the link vector so that the given entry is removed. This method will
     * complete in linear time.
     *
     * @param i the index of an entry.
     */
    protected int fixOrder(final int i) {
	if (this.size == 0) {
	    this.order.clear();
	    this.first = this.last = -1;
	    return 0;
	}
	final int idx = this.order.removeValue(i);
	if (this.first == i) {
	    this.first = this.order.get(0);
	}
	if (this.last == i) {
	    this.last = this.order.peek();
	}
	return idx;
    }

    /**
     * Modifies the ordering for a shift from s to d. <br>
     * This method will complete in linear time or better.
     *
     * @param s the source position.
     * @param d the destination position.
     */
    protected void fixOrder(final int s, final int d) {
	if (this.size == 1) {
	    this.first = this.last = d;
	    this.order.set(0, d);
	} else if (this.first == s) {
	    this.first = d;
	    this.order.set(0, d);
	} else if (this.last == s) {
	    this.last = d;
	    this.order.set(this.order.size - 1, d);
	} else {
	    this.order.set(this.order.indexOf(s), d);
	}
    }

    /**
     * Returns the first element of this set in iteration order.
     *
     * @return the first element in iteration order.
     */
    @Override
    public K first() {
	if (this.size == 0) {
	    throw new NoSuchElementException();
	}
	return this.key[this.first];
    }

    /**
     * Returns the last element of this set in iteration order.
     *
     * @return the last element in iteration order.
     */
    @Override
    public K last() {
	if (this.size == 0) {
	    throw new NoSuchElementException();
	}
	return this.key[this.last];
    }

    @Override
    public SortedSet<K> tailSet(final K from) {
	throw new UnsupportedOperationException();
    }

    @Override
    public SortedSet<K> headSet(final K to) {
	throw new UnsupportedOperationException();
    }

    @Override
    public SortedSet<K> subSet(final K from, final K to) {
	throw new UnsupportedOperationException();
    }

    @Override
    public Comparator<? super K> comparator() {
	return null;
    }

    /**
     * A list iterator over a linked set.
     * <p>
     * <p>
     * This class provides a list iterator over a linked hash set. The constructor
     * runs in constant time.
     */
    private class SetIterator implements ListIterator<K> {
	/**
	 * The entry that will be returned by the next call to
	 * {@link java.util.ListIterator#previous()} (or <code>null</code> if no
	 * previous entry exists).
	 */
	int prev = -1;
	/**
	 * The entry that will be returned by the next call to
	 * {@link java.util.ListIterator#next()} (or <code>null</code> if no next entry
	 * exists).
	 */
	int next = -1;
	/**
	 * The last entry that was returned (or -1 if we did not iterate or used
	 * {@link #remove()}).
	 */
	int curr = -1;
	/**
	 * The current index (in the sense of a {@link java.util.ListIterator}). When
	 * -1, we do not know the current index.
	 */
	int index = -1;

	SetIterator() {
	    this.next = OrderedSet.this.first;
	    this.index = 0;
	}

	@Override
	public boolean hasNext() {
	    return this.next != -1;
	}

	@Override
	public boolean hasPrevious() {
	    return this.prev != -1;
	}

	@Override
	public K next() {
	    if (!this.hasNext()) {
		throw new NoSuchElementException();
	    }
	    this.curr = this.next;
	    if (++this.index >= OrderedSet.this.order.size) {
		this.next = -1;
	    } else {
		this.next = OrderedSet.this.order.get(this.index);// (int) link[curr];
	    }
	    this.prev = this.curr;
	    return OrderedSet.this.key[this.curr];
	}

	@Override
	public K previous() {
	    if (!this.hasPrevious()) {
		throw new NoSuchElementException();
	    }
	    this.curr = this.prev;
	    if (--this.index < 1) {
		this.prev = -1;
	    } else {
		this.prev = OrderedSet.this.order.get(this.index - 1);
	    }
	    this.next = this.curr;
	    return OrderedSet.this.key[this.curr];
	}

	private void ensureIndexKnown() {
	    if (this.index >= 0) {
		return;
	    }
	    if (this.prev == -1) {
		this.index = 0;
		return;
	    }
	    if (this.next == -1) {
		this.index = OrderedSet.this.size;
		return;
	    }
	    this.index = 0;
	}

	@Override
	public int nextIndex() {
	    this.ensureIndexKnown();
	    return this.index + 1;
	}

	@Override
	public int previousIndex() {
	    this.ensureIndexKnown();
	    return this.index - 1;
	}

	@Override
	public void remove() {
	    this.ensureIndexKnown();
	    if (this.curr == -1) {
		throw new IllegalStateException();
	    }
	    if (this.curr == this.prev) {
		/*
		 * If the last operation was a next(), we are removing an entry that precedes
		 * the current index, and thus we must decrement it.
		 */
		if (--this.index >= 1) {
		    this.prev = OrderedSet.this.order.get(this.index - 1); // (int) (link[curr] >>> 32);
		} else {
		    this.prev = -1;
		}
	    } else {
		if (this.index < OrderedSet.this.order.size - 1) {
		    this.next = OrderedSet.this.order.get(this.index + 1);
		} else {
		    this.next = -1;
		}
	    }
	    /*
	     * Now we manually fix the pointers. Because of our knowledge of next and prev,
	     * this is going to be faster than calling fixOrder().
	     */
	    if (this.prev == -1) {
		OrderedSet.this.first = this.next;
	    }
	    if (this.next == -1) {
		OrderedSet.this.last = this.prev;
	    }
	    OrderedSet.this.order.removeIndex(this.index);
	    OrderedSet.this.size--;
	    int last, slot, pos = this.curr;
	    this.curr = -1;
	    if (pos == OrderedSet.this.n) {
		OrderedSet.this.containsNull = false;
		OrderedSet.this.key[OrderedSet.this.n] = null;
		// order.removeValue(pos);
	    } else {
		K curr;
		final K[] key = OrderedSet.this.key;
		// We have to horribly duplicate the shiftKeys() code because we
		// need to update next/prev.
		for (;;) {
		    pos = (last = pos) + 1 & OrderedSet.this.mask;
		    for (;;) {
			if ((curr = key[pos]) == null) {
			    key[last] = null;
			    return;
			}
			slot = HashCommon.mix(OrderedSet.this.hasher.hash(curr)) & OrderedSet.this.mask;
			if (last <= pos ? last >= slot || slot > pos : last >= slot && slot > pos) {
			    break;
			}
			pos = pos + 1 & OrderedSet.this.mask;
		    }
		    key[last] = curr;
		    if (this.next == pos) {
			this.next = last;
		    }
		    if (this.prev == pos) {
			this.prev = last;
		    }
		    OrderedSet.this.fixOrder(pos, last);
		}
	    }
	}

	/**
	 * Replaces the last element returned by {@link #next} or {@link #previous} with
	 * the specified element (optional operation). This call can be made only if
	 * neither {@link #remove} nor {@link #add} have been called after the last call
	 * to {@code next} or {@code previous}.
	 *
	 * @param k the element with which to replace the last element returned by
	 *          {@code next} or {@code previous}
	 * @throws UnsupportedOperationException if the {@code set} operation is not
	 *                                       supported by this list iterator
	 * @throws ClassCastException            if the class of the specified element
	 *                                       prevents it from being added to this
	 *                                       list
	 * @throws IllegalArgumentException      if some aspect of the specified element
	 *                                       prevents it from being added to this
	 *                                       list
	 * @throws IllegalStateException         if neither {@code next} nor
	 *                                       {@code previous} have been called, or
	 *                                       {@code remove} or {@code add} have been
	 *                                       called after the last call to
	 *                                       {@code next} or {@code previous}
	 */
	@Override
	public void set(final K k) {
	    throw new UnsupportedOperationException("set() not supported on OrderedSet iterator");
	}

	/**
	 * Inserts the specified element into the list (optional operation). The element
	 * is inserted immediately before the element that would be returned by
	 * {@link #next}, if any, and after the element that would be returned by
	 * {@link #previous}, if any. (If the list contains no elements, the new element
	 * becomes the sole element on the list.) The new element is inserted before the
	 * implicit cursor: a subsequent call to {@code next} would be unaffected, and a
	 * subsequent call to {@code previous} would return the new element. (This call
	 * increases by one the value that would be returned by a call to
	 * {@code nextIndex} or {@code previousIndex}.)
	 *
	 * @param k the element to insert
	 * @throws UnsupportedOperationException if the {@code add} method is not
	 *                                       supported by this list iterator
	 * @throws ClassCastException            if the class of the specified element
	 *                                       prevents it from being added to this
	 *                                       list
	 * @throws IllegalArgumentException      if some aspect of this element prevents
	 *                                       it from being added to this list
	 */
	@Override
	public void add(final K k) {
	    throw new UnsupportedOperationException("add() not supported on OrderedSet iterator");
	}
    }

    @Override
    public ListIterator<K> iterator() {
	return new SetIterator();
    }

    /**
     * A no-op for backward compatibility. The kind of tables implemented by this
     * class never need rehashing.
     * <p>
     * <P>
     * If you need to reduce the table size to fit exactly this set, use
     * {@link #trim()}.
     *
     * @return true.
     * @see #trim()
     * @deprecated A no-op.
     */
    @Deprecated
    public boolean rehash() {
	return true;
    }

    /**
     * Rehashes the map, making the table as small as possible.
     * <p>
     * <P>
     * This method rehashes the table to the smallest size satisfying the load
     * factor. It can be used when the set will not be changed anymore, so to
     * optimize access speed and size.
     * <p>
     * <P>
     * If the table size is already the minimum possible, this method does nothing.
     *
     * @return true if there was enough memory to trim the map.
     * @see #trim(int)
     */
    public boolean trim() {
	final int l = OrderedSet.arraySize(this.size, this.f);
	if (l >= this.n || this.size > OrderedSet.maxFill(l, this.f)) {
	    return true;
	}
	try {
	    this.rehash(l);
	} catch (final Exception cantDoIt) {
	    return false;
	}
	return true;
    }

    /**
     * Rehashes this map if the table is too large.
     * <p>
     * <P>
     * Let <var>N</var> be the smallest table size that can hold
     * <code>max(n,{@link #size()})</code> entries, still satisfying the load
     * factor. If the current table size is smaller than or equal to <var>N</var>,
     * this method does nothing. Otherwise, it rehashes this map in a table of size
     * <var>N</var>.
     * <p>
     * <P>
     * This method is useful when reusing maps. {@linkplain #clear() Clearing a map}
     * leaves the table size untouched. If you are reusing a map many times, you can
     * call this method with a typical size to avoid keeping around a very large
     * table just because of a few large transient maps.
     *
     * @param n the threshold for the trimming.
     * @return true if there was enough memory to trim the map.
     * @see #trim()
     */
    public boolean trim(final int n) {
	final int l = HashCommon.nextPowerOfTwo((int) Math.ceil(n / this.f));
	if (l >= n || this.size > OrderedSet.maxFill(l, this.f)) {
	    return true;
	}
	try {
	    this.rehash(l);
	} catch (final Exception cantDoIt) {
	    return false;
	}
	return true;
    }

    /**
     * Rehashes the map.
     * <p>
     * <p>
     * This method implements the basic rehashing strategy, and may be overriden by
     * subclasses implementing different rehashing strategies (e.g., disk-based
     * rehashing). However, you should not override this method unless you
     * understand the internal workings of this class.
     *
     * @param newN the new size
     */
    @SuppressWarnings("unchecked")
    protected void rehash(final int newN) {
	final K key[] = this.key;
	final int mask = newN - 1; // Note that this is used by the hashing
	// macro
	final K newKey[] = (K[]) new Object[newN + 1];
	int i, pos;
	final int sz = this.order.size, originalFirst = this.first, originalLast = this.last;
	for (int q = 0; q < sz; q++) {
	    i = this.order.get(q);
	    if (key[i] == null) {
		pos = newN;
	    } else {
		pos = HashCommon.mix(this.hasher.hash(key[i])) & mask;
		while (!(newKey[pos] == null)) {
		    pos = pos + 1 & mask;
		}
	    }
	    newKey[pos] = key[i];
	    this.order.set(q, pos);
	    if (i == originalFirst) {
		this.first = pos;
	    }
	    if (i == originalLast) {
		this.last = pos;
	    }
	}
	this.n = newN;
	this.mask = mask;
	this.maxFill = OrderedSet.maxFill(this.n, this.f);
	this.key = newKey;
    }
    /*
     * @SuppressWarnings("unchecked") protected void rehash(final int newN) { final
     * K key[] = this.key; final V value[] = this.value; final int mask = newN - 1;
     * // Note that this is used by the hashing // macro final K newKey[] = (K[])
     * new Object[newN + 1]; final V newValue[] = (V[]) new Object[newN + 1]; int i
     * = first, prev = -1, newPrev = -1, t, pos; final long link[] = this.link;
     * final long newLink[] = new long[newN + 1]; first = -1; for (int j = size; j--
     * != 0;) { if (((key[i]) == null)) pos = newN; else { pos =
     * (HashCommon.mix((key[i]).hashCode())) & mask; while (!((newKey[pos]) ==
     * null)) pos = (pos + 1) & mask; } newKey[pos] = key[i]; newValue[pos] =
     * value[i]; if (prev != -1) { newLink[newPrev] ^= ((newLink[newPrev] ^ (pos &
     * 0xFFFFFFFFL)) & 0xFFFFFFFFL); newLink[pos] ^= ((newLink[pos] ^ ((newPrev &
     * 0xFFFFFFFFL) << 32)) & 0xFFFFFFFF00000000L); newPrev = pos; } else { newPrev
     * = first = pos; // Special case of SET(newLink[ pos ], -1, -1); newLink[pos] =
     * -1L; } t = i; i = (int) link[i]; prev = t; } this.link = newLink; this.last =
     * newPrev; if (newPrev != -1) // Special case of SET_NEXT( newLink[ newPrev ],
     * -1 ); newLink[newPrev] |= -1 & 0xFFFFFFFFL; n = newN; this.mask = mask;
     * maxFill = maxFill(n, f); this.key = newKey; this.value = newValue; }
     */

    /**
     * Returns a deep copy of this map.
     * <p>
     * <p>
     * This method performs a deep copy of this hash map; the data stored in the
     * map, however, is not cloned. Note that this makes a difference only for
     * object keys.
     *
     * @return a deep copy of this map.
     */
    @Override
    @SuppressWarnings("unchecked")
    @GwtIncompatible
    public Object clone() {
	OrderedSet<K> c;
	try {
	    c = (OrderedSet<K>) super.clone();
	    c.key = (K[]) new Object[this.n + 1];
	    System.arraycopy(this.key, 0, c.key, 0, this.n + 1);
	    c.order = (IntVLA) this.order.clone();
	    c.hasher = this.hasher;
	    return c;
	} catch (final Exception cantHappen) {
	    throw new UnsupportedOperationException(
		    cantHappen + (cantHappen.getMessage() != null ? "; " + cantHappen.getMessage() : ""));
	}
    }

    /**
     * Returns a hash code for this set.
     * <p>
     * This method overrides the generic method provided by the superclass. Since
     * <code>equals()</code> is not overriden, it is important that the value
     * returned by this method is the same value as the one returned by the
     * overriden method.
     *
     * @return a hash code for this set.
     */
    @Override
    public int hashCode() {
	int h = 0;
	for (int j = this.realSize(), i = 0; j-- != 0;) {
	    while (this.key[i] == null) {
		i++;
	    }
	    if (this != this.key[i]) {
		h += this.hasher.hash(this.key[i]);
	    }
	    i++;
	}
	// Zero / null have hash zero.
	return h;
    }

    /**
     * Returns the maximum number of entries that can be filled before rehashing.
     *
     * @param n the size of the backing array.
     * @param f the load factor.
     * @return the maximum number of entries before rehashing.
     */
    public static int maxFill(final int n, final float f) {
	/*
	 * We must guarantee that there is always at least one free entry (even with
	 * pathological load factors).
	 */
	return Math.min((int) Math.ceil(n * f), n - 1);
    }

    /**
     * Returns the maximum number of entries that can be filled before rehashing.
     *
     * @param n the size of the backing array.
     * @param f the load factor.
     * @return the maximum number of entries before rehashing.
     */
    public static long maxFill(final long n, final float f) {
	/*
	 * We must guarantee that there is always at least one free entry (even with
	 * pathological load factors).
	 */
	return Math.min((long) Math.ceil(n * f), n - 1);
    }

    /**
     * Returns the least power of two smaller than or equal to 2<sup>30</sup> and
     * larger than or equal to <code>Math.ceil( expected / f )</code>.
     *
     * @param expected the expected number of elements in a hash table.
     * @param f        the load factor.
     * @return the minimum possible size for a backing array.
     * @throws IllegalArgumentException if the necessary size is larger than
     *                                  2<sup>30</sup>.
     */
    public static int arraySize(final int expected, final float f) {
	final long s = Math.max(2, HashCommon.nextPowerOfTwo((long) Math.ceil(expected / f)));
	if (s > 1 << 30) {
	    throw new IllegalArgumentException(
		    "Too large (" + expected + " expected elements with load factor " + f + ")");
	}
	return (int) s;
    }

    @Override
    public Object[] toArray() {
	final Object[] a = new Object[this.size()];
	OrderedSet.objectUnwrap(this.iterator(), a);
	return a;
    }

    @SuppressWarnings("unchecked")
    @Override
    public <T> T[] toArray(final T[] a) {
	final int size = this.size();
	OrderedSet.objectUnwrap(this.iterator(), a);
	if (size < a.length) {
	    a[size] = null;
	}
	return a;
    }

    /**
     * Unwraps an iterator into an array starting at a given offset for a given
     * number of elements.
     * <p>
     * <P>
     * This method iterates over the given type-specific iterator and stores the
     * elements returned, up to a maximum of <code>length</code>, in the given array
     * starting at <code>offset</code>. The number of actually unwrapped elements is
     * returned (it may be less than <code>max</code> if the iterator emits less
     * than <code>max</code> elements).
     *
     * @param i      a type-specific iterator.
     * @param array  an array to contain the output of the iterator.
     * @param offset the first element of the array to be returned.
     * @param max    the maximum number of elements to unwrap.
     * @return the number of elements unwrapped.
     */
    private static <K> int objectUnwrap(final Iterator<? extends K> i, final K array[], int offset, final int max) {
	if (max < 0) {
	    throw new IllegalArgumentException("The maximum number of elements (" + max + ") is negative");
	}
	if (offset < 0 || offset + max > array.length) {
	    throw new IllegalArgumentException();
	}
	int j = max;
	while (j-- != 0 && i.hasNext()) {
	    array[offset++] = i.next();
	}
	return max - j - 1;
    }

    /**
     * Unwraps an iterator into an array.
     * <p>
     * <P>
     * This method iterates over the given type-specific iterator and stores the
     * elements returned in the given array. The iteration will stop when the
     * iterator has no more elements or when the end of the array has been reached.
     *
     * @param i     a type-specific iterator.
     * @param array an array to contain the output of the iterator.
     * @return the number of elements unwrapped.
     */
    private static <K> int objectUnwrap(final Iterator<? extends K> i, final K array[]) {
	return OrderedSet.objectUnwrap(i, array, 0, array.length);
    }

    @Override
    public String toString() {
	final StringBuilder s = new StringBuilder();
	final int n = this.size();
	int i = 0;
	boolean first = true;
	s.append("OrderedSet{");
	while (i < n) {
	    if (first) {
		first = false;
	    } else {
		s.append(", ");
	    }
	    s.append(this.getAt(i++));
	}
	s.append("}");
	return s.toString();
    }

    @Override
    public boolean equals(final Object o) {
	if (o == this) {
	    return true;
	}
	if (!(o instanceof Set)) {
	    return false;
	}
	final Set<?> s = (Set<?>) o;
	if (s.size() != this.size()) {
	    return false;
	}
	return this.containsAll(s);
    }

    @GwtIncompatible
    private void writeObject(final java.io.ObjectOutputStream s) throws java.io.IOException {
	final ListIterator<K> i = this.iterator();
	s.defaultWriteObject();
	s.writeObject(this.hasher);
	for (int j = this.size; j-- != 0;) {
	    s.writeObject(i.next());
	}
    }

    @GwtIncompatible
    @SuppressWarnings("unchecked")
    private void readObject(final java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException {
	s.defaultReadObject();
	this.hasher = (CrossHash.IHasher) s.readObject();
	this.n = OrderedSet.arraySize(this.size, this.f);
	this.maxFill = OrderedSet.maxFill(this.n, this.f);
	this.mask = this.n - 1;
	final K key[] = this.key = (K[]) new Object[this.n + 1];
	final IntVLA order = this.order = new IntVLA(this.n + 1);
	this.first = this.last = -1;
	K k;
	for (int i = this.size, pos; i-- != 0;) {
	    k = (K) s.readObject();
	    if (k == null) {
		pos = this.n;
		this.containsNull = true;
	    } else {
		if (!(key[pos = HashCommon.mix(this.hasher.hash(k)) & this.mask] == null)) {
		    while (!(key[pos = pos + 1 & this.mask] == null)) {
		    }
		}
	    }
	    key[pos] = k;
	    if (this.first != -1) {
		this.last = pos;
	    } else {
		this.first = this.last = pos;
	    }
	    order.add(pos);
	}
    }

    /**
     * Gets the item at the given index in the iteration order in constant time
     * (random-access).
     *
     * @param idx the index in the iteration order of the key to fetch
     * @return the key at the index, if the index is valid, otherwise null
     */
    public K getAt(final int idx) {
	if (idx < 0 || idx >= this.order.size) {
	    return null;
	}
	final K[] key = this.key;
	// The starting point.
	return key[this.order.get(idx)];
    }

    /**
     * Removes the item at the given index in the iteration order in not-exactly
     * constant time (though it still should be efficient).
     *
     * @param idx the index in the iteration order of the item to remove
     * @return true if this Set was changed as a result of this call, or false if
     *         nothing changed.
     */
    public boolean removeAt(final int idx) {
	if (idx < 0 || idx >= this.order.size) {
	    throw new NoSuchElementException();
	}
	final int pos = this.order.get(idx);
	if (this.key[pos] == null) {
	    if (this.containsNull) {
		return this.removeNullEntry();
	    }
	    return false;
	}
	return this.removeEntry(pos);
    }

    /**
     * Gets a random value from this OrderedSet in constant time, using the given
     * RNG to generate a random number.
     *
     * @param rng used to generate a random index for a value
     * @return a random value from this OrderedSet
     */
    public K randomItem(final RNG rng) {
	return this.getAt(rng.nextInt(this.order.size));
    }

    /**
     * Randomly alters the iteration order for this OrderedSet using the given RNG
     * to shuffle.
     *
     * @param rng used to generate a random ordering
     * @return this for chaining
     */
    public OrderedSet<K> shuffle(final RNG rng) {
	if (this.size < 2 || rng == null) {
	    return this;
	}
	this.order.shuffle(rng);
	this.first = this.order.get(0);
	this.last = this.order.peek();
	return this;
    }

    /**
     * Given an array or varargs of replacement indices for this OrderedSet's
     * iteration order, reorders this so the first item in the returned version is
     * the same as {@code getAt(ordering[0])} (with some care taken for negative or
     * too-large indices), the second item in the returned version is the same as
     * {@code getAt(ordering[1])}, etc. <br>
     * Negative indices are considered reversed distances from the end of ordering,
     * so -1 refers to the same index as {@code ordering[ordering.length - 1]}. If
     * ordering is smaller than {@code size()}, only the indices up to the length of
     * ordering will be modified. If ordering is larger than {@code size()}, only as
     * many indices will be affected as {@code size()}, and reversed distances are
     * measured from the end of this Set's entries instead of the end of ordering.
     * Duplicate values in ordering will produce duplicate values in the returned
     * Set. <br>
     * This method modifies this OrderedSet in-place and also returns it for
     * chaining.
     *
     * @param ordering an array or varargs of int indices, where the nth item in
     *                 ordering changes the nth item in this Set to have the value
     *                 currently in this Set at the index specified by the value in
     *                 ordering
     * @return this for chaining, after modifying it in-place
     */
    public OrderedSet<K> reorder(final int... ordering) {
	this.order.reorder(ordering);
	this.first = this.order.get(0);
	this.last = this.order.peek();
	return this;
    }

    /*
     * public boolean alter(K original, K replacement) { if (original == null) { if
     * (containsNull) { return replacement != null && alterNullEntry(replacement); }
     * else return add(replacement); } else if(hasher.areEqual(original,
     * replacement)) return false; K curr; final K[] key = this.key; int pos; // The
     * starting point. if ((curr = key[pos = HashCommon.mix(hasher.hash(original)) &
     * mask]) == null) return add(replacement); if (hasher.areEqual(original, curr))
     * return alterEntry(pos, replacement); while (true) { if ((curr = key[pos =
     * (pos + 1) & mask]) == null) return add(replacement); if
     * (hasher.areEqual(original, curr)) return alterEntry(pos, replacement); } }
     */
    private int alterEntry(final int pos) {
	this.size--;
	final int idx = this.fixOrder(pos);
	this.shiftKeys(pos);
	if (this.size < this.maxFill / 4 && this.n > OrderedSet.DEFAULT_INITIAL_SIZE) {
	    this.rehash(this.n / 2);
	}
	return idx;
    }

    private int alterNullEntry() {
	this.containsNull = false;
	this.key[this.n] = null;
	this.size--;
	final int idx = this.fixOrder(this.n);
	if (this.size < this.maxFill / 4 && this.n > OrderedSet.DEFAULT_INITIAL_SIZE) {
	    this.rehash(this.n / 2);
	}
	return idx;
    }

    /**
     * Changes a K, original, to another, replacement, while keeping replacement at
     * the same point in the ordering.
     *
     * @param original    a K value that will be removed from this Set if present,
     *                    and its iteration index remembered
     * @param replacement another K value that will replace original at the
     *                    remembered index
     * @return true if the Set changed, or false if it didn't (such as if the two
     *         arguments are equal, or replacement was already in the Set but
     *         original was not)
     */
    public boolean alter(final K original, final K replacement) {
	int idx;
	if (original == null) {
	    if (this.containsNull) {
		if (replacement != null) {
		    idx = this.alterNullEntry();
		    this.addAt(replacement, idx);
		    return true;
		} else {
		    return false;
		}
	    }
	    return false;
	}
	if (this.hasher.areEqual(original, replacement)) {
	    return false;
	}
	K curr;
	final K[] key = this.key;
	int pos;
	// The starting point.
	if ((curr = key[pos = HashCommon.mix(this.hasher.hash(original)) & this.mask]) == null) {
	    return false;
	}
	if (this.hasher.areEqual(original, curr)) {
	    idx = this.alterEntry(pos);
	    this.addAt(replacement, idx);
	    return true;
	}
	while (true) {
	    if ((curr = key[pos = pos + 1 & this.mask]) == null) {
		return false;
	    }
	    if (this.hasher.areEqual(original, curr)) {
		idx = this.alterEntry(pos);
		this.addAt(replacement, idx);
		return true;
	    }
	}
    }

    /**
     * Changes the K at the given index to replacement while keeping replacement at
     * the same point in the ordering.
     *
     * @param index       an index to replace the K item at
     * @param replacement another K value that will replace the original at the
     *                    remembered index
     * @return true if the Set changed, or false if it didn't (such as if the
     *         replacement was already present at the given index)
     */
    public boolean alterAt(final int index, final K replacement) {
	return this.alter(this.getAt(index), replacement);
    }
}
