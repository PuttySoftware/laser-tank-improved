/*
 * Copyright (C) 2002-2015 Sebastiano Vigna
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package squidpony.squidmath;

import java.io.Serializable;
import java.util.AbstractCollection;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.ListIterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;

import squidpony.ArrayTools;
import squidpony.annotation.Beta;
import squidpony.annotation.GwtIncompatible;

/**
 * A bi-directional mapping of objects to positions in an ordering (which this
 * generates), and vice versa. Useful for various indirection techniques where
 * you want to be able to retrieve a value in several ways, such as with
 * multiple Arrangements all sharing the same ordering but with different types
 * for keys. <br>
 * Originally, this started as a generic linked hash map with with a fast
 * implementation, originally from fastutil as Object2IntLinkedOpenHashMap but
 * modified to support indexed access. The code is extremely close to
 * {@link OrderedMap}, and like OrderedMap you can look up keys by index, but
 * this is specialized to int values which it can automatically assign. <br>
 * <p>
 * Instances of this class use a hash table to represent a map. The table is
 * filled up to a specified <em>load factor</em>, and then doubled in size to
 * accommodate new entries. If the table is emptied below <em>one fourth</em> of
 * the load factor, it is halved in size. However, halving is not performed when
 * deleting entries from an iterator, as it would interfere with the iteration
 * process.
 * </p>
 * <p>
 * Note that {@link #clear()} does not modify the hash table size. Rather, a
 * family of {@linkplain #trim() trimming methods} lets you control the size of
 * the table; this is particularly useful if you reuse instances of this class.
 * </p>
 * <p>
 * Iterators generated by this map will enumerate pairs in the same order in
 * which they have been added to the map (addition of pairs whose key is already
 * present in the set does not change the iteration order). Note that this order
 * has nothing in common with the natural order of the keys. The order is kept
 * by means of a int-specialized list, {@link IntVLA}, and is modifiable with
 * this class' {@link #reorder(int...)} and {@link #shuffle(RNG)} methods, among
 * other tools.
 * </p>
 * <p>
 * This class implements the interface of a sorted map, so to allow easy access
 * of the iteration order: for instance, you can get the first key in iteration
 * order with {@code firstKey()} without having to create an iterator; however,
 * this class partially violates the {@link SortedMap} contract because all
 * submap methods throw an exception and {@link #comparator()} returns always
 * <code>null</code>.
 * </p>
 * <p>
 * Additional methods, such as <code>getAndMoveToFirst()</code>, make it easy to
 * use instances of this class as a cache (e.g., with LRU policy).
 * </p>
 * <br>
 * Thank you, Sebastiano Vigna, for making FastUtil available to the public with
 * such high quality. <br>
 * See https://github.com/vigna/fastutil for the original library.
 *
 * @author Sebastiano Vigna (responsible for all the hard parts)
 * @author Tommy Ettinger (mostly responsible for squashing several layers of
 *         parent classes into one monster class)
 */
@Beta
public class Arrangement<K> implements SortedMap<K, Integer>, Iterable<K>, Serializable, Cloneable {
    private static final long serialVersionUID = 0L;
    /**
     * The array of keys.
     */
    protected K[] key;
    /**
     * The array of values.
     */
    protected int[] value;
    /**
     * The mask for wrapping a position counter.
     */
    protected int mask;
    /**
     * Whether this set contains the key zero.
     */
    protected boolean containsNullKey;
    /**
     * The index of the first entry in iteration order. It is valid iff
     * {@link #size} is nonzero; otherwise, it contains -1.
     */
    protected int first = -1;
    /**
     * The index of the last entry in iteration order. It is valid iff {@link #size}
     * is nonzero; otherwise, it contains -1.
     */
    protected int last = -1;
    /*
     * For each entry, the next and the previous entry in iteration order, stored as
     * <code>((prev & 0xFFFFFFFFL) << 32) | (next & 0xFFFFFFFFL)</code>. The first
     * entry contains predecessor -1, and the last entry contains successor -1.
     */
    // protected long[] link;
    protected IntVLA order;
    /**
     * The current table size.
     */
    protected int n;
    /**
     * Threshold after which we rehash. It must be the table size times {@link #f}.
     */
    protected int maxFill;
    /**
     * Number of entries in the set (including the key zero, if present).
     */
    protected int size;
    /**
     * The acceptable load factor.
     */
    public final float f;
    /**
     * Cached set of entries.
     */
    protected volatile MapEntrySet entries;
    /**
     * Cached set of keys.
     */
    protected volatile KeySet keys;
    /**
     * Cached collection of values.
     */
    protected volatile Collection<Integer> values;
    /**
     * Default return value.
     */
    protected final int defRetValue = -1;
    /**
     * The initial default size of a hash table.
     */
    public static final int DEFAULT_INITIAL_SIZE = 16;
    /**
     * The default load factor of a hash table.
     */
    public static final float DEFAULT_LOAD_FACTOR = .5f; // .375f // .1875f; // .75f;
    /**
     * The load factor for a (usually small) table that is meant to be particularly
     * fast.
     */
    public static final float FAST_LOAD_FACTOR = .5f;
    /**
     * The load factor for a (usually very small) table that is meant to be
     * extremely fast.
     */
    public static final float VERY_FAST_LOAD_FACTOR = .25f;
    protected CrossHash.IHasher hasher = null;

    /**
     * Creates a new Arrangement.
     * <p>
     * <p>
     * The actual table size will be the least power of two greater than
     * <code>expected</code>/<code>f</code>.
     *
     * @param expected the expected number of elements in the hash set.
     * @param f        the load factor.
     */
    @SuppressWarnings("unchecked")
    public Arrangement(final int expected, final float f) {
	if (f <= 0 || f > 1) {
	    throw new IllegalArgumentException("Load factor must be greater than 0 and smaller than or equal to 1");
	}
	if (expected < 0) {
	    throw new IllegalArgumentException("The expected number of elements must be nonnegative");
	}
	this.f = f;
	this.n = Arrangement.arraySize(expected, f);
	this.mask = this.n - 1;
	this.maxFill = Arrangement.maxFill(this.n, f);
	this.key = (K[]) new Object[this.n + 1];
	this.value = new int[this.n + 1];
	// link = new long[n + 1];
	this.order = new IntVLA(expected);
	this.hasher = CrossHash.defaultHasher;
    }

    /**
     * Creates a new Arrangement with 0.5f as load factor.
     *
     * @param expected the expected number of elements in the Arrangement.
     */
    public Arrangement(final int expected) {
	this(expected, Arrangement.DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new Arrangement with initial expected 16 entries and 0.5f as load
     * factor.
     */
    public Arrangement() {
	this(Arrangement.DEFAULT_INITIAL_SIZE, Arrangement.DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new Arrangement copying a given one.
     *
     * @param m a {@link Map} to be copied into the new Arrangement.
     * @param f the load factor.
     */
    public Arrangement(final Map<? extends K, ? extends Integer> m, final float f) {
	this(m.size(), f, m instanceof Arrangement ? ((Arrangement) m).hasher : CrossHash.defaultHasher);
	this.putAll(m);
    }

    /**
     * Creates a new Arrangement with 0.5f as load factor copying a given one.
     *
     * @param m a {@link Map} to be copied into the new Arrangement.
     */
    public Arrangement(final Map<? extends K, ? extends Integer> m) {
	this(m, m instanceof Arrangement ? ((Arrangement) m).f : Arrangement.DEFAULT_LOAD_FACTOR,
		m instanceof Arrangement ? ((Arrangement) m).hasher : CrossHash.defaultHasher);
    }

    public Arrangement(final Arrangement<? extends K> a) {
	this(a.size(), a.f, a.hasher);
	this.ensureCapacity(a.size()); // The resulting map will be sized for
	System.arraycopy(a.key, 0, this.key, 0, a.key.length);
	System.arraycopy(a.value, 0, this.value, 0, a.value.length);
	this.order.addAll(a.order);
	this.containsNullKey = a.containsNullKey;
    }

    /**
     * Creates a new Arrangement using the elements of an array.
     *
     * @param keyArray the array of keys of the new Arrangement.
     * @param f        the load factor.
     * @throws IllegalArgumentException if <code>k</code> and <code>v</code> have
     *                                  different lengths.
     */
    public Arrangement(final K[] keyArray, final float f) {
	this(keyArray.length, f);
	for (int i = 0; i < keyArray.length; i++) {
	    this.put(keyArray[i], i);
	}
    }

    /**
     * Creates a new Arrangement using the elements of an array.
     *
     * @param keyColl the collection of keys of the new Arrangement.
     * @throws IllegalArgumentException if <code>k</code> and <code>v</code> have
     *                                  different lengths.
     */
    public Arrangement(final Collection<K> keyColl) {
	this(keyColl, Arrangement.DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new Arrangement using the given collection of keys.
     *
     * @param keyColl the collection of keys of the new Arrangement.
     * @param f       the load factor.
     * @throws IllegalArgumentException if <code>k</code> and <code>v</code> have
     *                                  different lengths.
     */
    public Arrangement(final Collection<K> keyColl, final float f) {
	this(keyColl.size(), f);
	final Iterator<K> ki = keyColl.iterator();
	int idx = 0;
	while (ki.hasNext()) {
	    this.put(ki.next(), idx++);
	}
    }

    /**
     * Creates a new Arrangement with 0.5f as load factor using the elements of an
     * array.
     *
     * @param keyArray the array of keys of the new Arrangement.
     * @throws IllegalArgumentException if <code>k</code> and <code>v</code> have
     *                                  different lengths.
     */
    public Arrangement(final K[] keyArray) {
	this(keyArray, Arrangement.DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new Arrangement.
     * <p>
     * <p>
     * The actual table size will be the least power of two greater than
     * <code>expected</code>/<code>f</code>.
     *
     * @param expected the expected number of elements in the hash set.
     * @param f        the load factor.
     * @param hasher   used to hash items; typically only needed when K is an array,
     *                 where CrossHash has implementations
     */
    @SuppressWarnings("unchecked")
    public Arrangement(final int expected, final float f, final CrossHash.IHasher hasher) {
	if (f <= 0 || f > 1) {
	    throw new IllegalArgumentException("Load factor must be greater than 0 and smaller than or equal to 1");
	}
	if (expected < 0) {
	    throw new IllegalArgumentException("The expected number of elements must be nonnegative");
	}
	this.f = f;
	this.n = Arrangement.arraySize(expected, f);
	this.mask = this.n - 1;
	this.maxFill = Arrangement.maxFill(this.n, f);
	this.key = (K[]) new Object[this.n + 1];
	this.value = new int[this.n + 1];
	// link = new long[n + 1];
	this.order = new IntVLA(expected);
	this.hasher = hasher == null ? CrossHash.defaultHasher : hasher;
    }

    /**
     * Creates a new Arrangement with 0.5f as load factor.
     *
     * @param expected the expected number of elements in the Arrangement.
     * @param hasher   used to hash items; typically only needed when K is an array,
     *                 where CrossHash has implementations
     */
    public Arrangement(final int expected, final CrossHash.IHasher hasher) {
	this(expected, Arrangement.DEFAULT_LOAD_FACTOR, hasher);
    }

    /**
     * Creates a new Arrangement with initial expected 16 entries and 0.5f as load
     * factor.
     */
    public Arrangement(final CrossHash.IHasher hasher) {
	this(Arrangement.DEFAULT_INITIAL_SIZE, Arrangement.DEFAULT_LOAD_FACTOR, hasher);
    }

    /**
     * Creates a new Arrangement copying a given one.
     *
     * @param m      a {@link Map} to be copied into the new Arrangement.
     * @param f      the load factor.
     * @param hasher used to hash items; typically only needed when K is an array,
     *               where CrossHash has implementations
     */
    public Arrangement(final Map<? extends K, ? extends Integer> m, final float f, final CrossHash.IHasher hasher) {
	this(m.size(), f, hasher);
	this.putAll(m);
    }

    /**
     * Creates a new Arrangement with 0.5f as load factor copying a given one.
     *
     * @param m      a {@link Map} to be copied into the new Arrangement.
     * @param hasher used to hash items; typically only needed when K is an array,
     *               where CrossHash has implementations
     */
    public Arrangement(final Map<? extends K, ? extends Integer> m, final CrossHash.IHasher hasher) {
	this(m, Arrangement.DEFAULT_LOAD_FACTOR, hasher);
    }

    /**
     * Creates a new Arrangement using the elements of two parallel arrays.
     *
     * @param keyArray the array of keys of the new Arrangement.
     * @param f        the load factor.
     * @param hasher   used to hash items; typically only needed when K is an array,
     *                 where CrossHash has implementations
     * @throws IllegalArgumentException if <code>k</code> and <code>v</code> have
     *                                  different lengths.
     */
    public Arrangement(final K[] keyArray, final float f, final CrossHash.IHasher hasher) {
	this(keyArray.length, f, hasher);
	for (int i = 0; i < keyArray.length; i++) {
	    this.put(keyArray[i], i);
	}
    }

    /**
     * Creates a new Arrangement with 0.5f as load factor using the elements of two
     * parallel arrays.
     *
     * @param keyArray the array of keys of the new Arrangement.
     * @param hasher   used to hash items; typically only needed when K is an array,
     *                 where CrossHash has implementations
     * @throws IllegalArgumentException if <code>k</code> and <code>v</code> have
     *                                  different lengths.
     */
    public Arrangement(final K[] keyArray, final CrossHash.IHasher hasher) {
	this(keyArray, Arrangement.DEFAULT_LOAD_FACTOR, hasher);
    }

    private int realSize() {
	return this.containsNullKey ? this.size - 1 : this.size;
    }

    private void ensureCapacity(final int capacity) {
	final int needed = Arrangement.arraySize(capacity, this.f);
	if (needed > this.n) {
	    this.rehash(needed);
	}
    }

    private void tryCapacity(final long capacity) {
	final int needed = (int) Math.min(1 << 30,
		Math.max(2, HashCommon.nextPowerOfTwo((long) Math.ceil(capacity / this.f))));
	if (needed > this.n) {
	    this.rehash(needed);
	}
    }

    private int removeEntry(final int pos) {
	this.size--;
	this.fixOrder(pos);
	this.shiftKeys(pos);
	final int oldValue = this.value[pos];
	this.fixValues(oldValue);
	if (this.size < this.maxFill >>> 2 && this.n > Arrangement.DEFAULT_INITIAL_SIZE) {
	    this.rehash(this.n / 2);
	}
	return oldValue;
    }

    private int removeNullEntry() {
	this.containsNullKey = false;
	this.key[this.n] = null;
	final int oldValue = this.value[this.n];
	this.size--;
	this.fixOrder(this.n);
	this.fixValues(oldValue);
	if (this.size < this.maxFill >>> 2 && this.n > Arrangement.DEFAULT_INITIAL_SIZE) {
	    this.rehash(this.n / 2);
	}
	return oldValue;
    }

    @Override
    public void putAll(final Map<? extends K, ? extends Integer> m) {
	if (this.f <= .5) {
	    this.ensureCapacity(m.size()); // The resulting map will be sized for
	    // m.size() elements
	} else {
	    this.tryCapacity(this.size() + m.size()); // The resulting map will be
	}
	int n = m.size();
	final Iterator<? extends K> i = m.keySet().iterator();
	while (n-- != 0) {
	    this.add(i.next());
	}
    }

    public void putAll(final K[] keyArray) {
	final int n = keyArray.length;
	if (this.f <= .5) {
	    this.ensureCapacity(n); // The resulting map will be sized for
	    // m.size() elements
	} else {
	    this.tryCapacity(this.size() + n); // The resulting map will be
	}
	// tentatively sized for size() + keyArray.length elements
	for (int i = 0; i < n; i++) {
	    this.add(keyArray[i]);
	}
    }

    public void putAll(final Collection<? extends K> keyColl) {
	if (this.f <= .5) {
	    this.ensureCapacity(keyColl.size()); // The resulting map will be sized for
	    // keyColl.size() elements
	} else {
	    this.tryCapacity(this.size() + keyColl.size()); // The resulting map will be
	}
	// tentatively sized for size() + keyColl.size() elements
	final Iterator<? extends K> it = keyColl.iterator();
	while (it.hasNext()) {
	    this.add(it.next());
	}
    }

    private int insert(final K k, final int v) {
	int pos;
	if (k == null) {
	    if (this.containsNullKey) {
		return this.n;
	    }
	    this.containsNullKey = true;
	    pos = this.n;
	} else {
	    K curr;
	    final K[] key = this.key;
	    // The starting point.
	    if ((curr = key[pos = HashCommon.mix(this.hasher.hash(k)) & this.mask]) != null) {
		if (this.hasher.areEqual(curr, k)) {
		    return pos;
		}
		while ((curr = key[pos = pos + 1 & this.mask]) != null) {
		    if (this.hasher.areEqual(curr, k)) {
			return pos;
		    }
		}
	    }
	}
	this.key[pos] = k;
	if (this.size == 0) {
	    this.first = this.last = pos;
	} else {
	    this.last = pos;
	}
	this.order.add(pos);
	this.value[pos] = this.size;
	if (this.size++ >= this.maxFill) {
	    this.rehash(Arrangement.arraySize(this.size + 1, this.f));
	}
	return -1;
    }

    private int insertAt(final K k, final int at) {
	int pos;
	if (k == null) {
	    if (this.containsNullKey) {
		return this.n;
	    }
	    this.containsNullKey = true;
	    pos = this.n;
	} else {
	    K curr;
	    final K[] key = this.key;
	    // The starting point.
	    if ((curr = key[pos = HashCommon.mix(this.hasher.hash(k)) & this.mask]) != null) {
		if (this.hasher.areEqual(curr, k)) {
		    this.order.removeIndex(this.value[pos]);
		    this.order.insert(at, pos);
		    return pos;
		}
		while ((curr = key[pos = pos + 1 & this.mask]) != null) {
		    if (this.hasher.areEqual(curr, k)) {
			this.order.removeIndex(this.value[pos]);
			this.order.insert(at, pos);
			return pos;
		    }
		}
	    }
	}
	this.key[pos] = k;
	if (this.size == 0) {
	    this.first = this.last = pos;
	} else if (at == 0) {
	    this.first = pos;
	} else if (at == this.size) {
	    this.last = pos;
	}
	this.order.insert(at, pos);
	this.value[pos] = at;
	if (this.size++ >= this.maxFill) {
	    this.rehash(Arrangement.arraySize(this.size + 1, this.f));
	}
	return pos;
    }

    /**
     * Puts the key k into this Arrangement with a value equal to the current number
     * of keys; v is disregarded.
     *
     * @param k any K type, including null
     * @param v any Integer, doesn't matter what it is and will be disregarded. Only
     *          here for compatibility
     * @return the Integer that was previously associated with k, or -1 if there was
     *         none
     */
    @Override
    @Deprecated
    public Integer put(final K k, final Integer v) {
	final int pos = this.insert(k, v);
	if (pos < 0) {
	    return this.defRetValue;
	}
	final Integer oldValue = this.value[pos];
	this.value[pos] = this.size - 1;
	return oldValue;
    }

    public int put(final K k, final int v) {
	final int pos = this.insert(k, v);
	if (pos < 0) {
	    return this.defRetValue;
	}
	final int oldValue = this.value[pos];
	this.value[pos] = this.size - 1;
	return oldValue;
    }

    public int add(final K k) {
	final int pos = this.insert(k, this.size);
	if (pos < 0) {
	    return this.defRetValue;
	}
	final int oldValue = this.value[pos];
	this.value[pos] = this.size - 1;
	return oldValue;
    }

    public int addIfAbsent(final K k) {
	int kPos;
	if ((kPos = this.getInt(k)) < 0) {
	    return this.add(k);
	}
	return kPos;
    }

    protected void fixValues(final int start) {
	for (int i = start; i < this.size; i++) {
	    this.value[this.order.items[i]] = i;
	}
    }

    /**
     * Shifts left entries with the specified hash code, starting at the specified
     * position, and empties the resulting free entry.
     *
     * @param pos a starting position.
     */
    protected final void shiftKeys(int pos) {
	// Shift entries with the same hash.
	int last, slot;
	K curr;
	final K[] key = this.key;
	for (;;) {
	    pos = (last = pos) + 1 & this.mask;
	    for (;;) {
		if ((curr = key[pos]) == null) {
		    key[last] = null;
		    return;
		}
		slot = HashCommon.mix(this.hasher.hash(curr)) & this.mask;
		if (last <= pos ? last >= slot || slot > pos : last >= slot && slot > pos) {
		    break;
		}
		pos = pos + 1 & this.mask;
	    }
	    key[last] = curr;
	    this.fixOrder(pos, last);
	}
    }

    /**
     * Shifts left entries with the specified hash code, starting at the specified
     * position, and empties the resulting free entry.
     *
     * @param pos a starting position.
     */
    protected final void shiftKeysValues(int pos) {
	// Shift entries with the same hash.
	int last, slot;
	K curr;
	int v;
	final K[] key = this.key;
	final int[] val = this.value;
	for (;;) {
	    pos = (last = pos) + 1 & this.mask;
	    for (;;) {
		if ((curr = key[pos]) == null) {
		    key[last] = null;
		    val[last] = -1;
		    return;
		}
		v = val[pos];
		slot = HashCommon.mix(this.hasher.hash(curr)) & this.mask;
		if (last <= pos ? last >= slot || slot > pos : last >= slot && slot > pos) {
		    break;
		}
		pos = pos + 1 & this.mask;
	    }
	    key[last] = curr;
	    val[last] = v;
	    this.fixOrder(pos, last);
	}
    }

    @SuppressWarnings("unchecked")
    protected Integer rem(final Object k) {
	if ((K) k == null) {
	    if (this.containsNullKey) {
		return this.removeNullEntry();
	    }
	    return null;
	}
	K curr;
	final K[] key = this.key;
	int pos;
	// The starting point.
	if ((curr = key[pos = HashCommon.mix(this.hasher.hash(k)) & this.mask]) == null) {
	    return null;
	}
	if (this.hasher.areEqual(k, curr)) {
	    return this.removeEntry(pos);
	}
	while (true) {
	    if ((curr = key[pos = pos + 1 & this.mask]) == null) {
		return null;
	    }
	    if (this.hasher.areEqual(k, curr)) {
		return this.removeEntry(pos);
	    }
	}
    }

    @Override
    public Integer remove(final Object o) {
	return this.rem(o);
    }

    @SuppressWarnings("unchecked")
    public int removeInt(final Object k) {
	if ((K) k == null) {
	    if (this.containsNullKey) {
		return this.removeNullEntry();
	    }
	    return this.defRetValue;
	}
	K curr;
	final K[] key = this.key;
	int pos;
	// The starting point.
	if ((curr = key[pos = HashCommon.mix(this.hasher.hash(k)) & this.mask]) == null) {
	    return this.defRetValue;
	}
	if (this.hasher.areEqual(k, curr)) {
	    return this.removeEntry(pos);
	}
	while (true) {
	    if ((curr = key[pos = pos + 1 & this.mask]) == null) {
		return this.defRetValue;
	    }
	    if (this.hasher.areEqual(k, curr)) {
		return this.removeEntry(pos);
	    }
	}
    }

    private int setValue(final int pos, final int v) {
	final int oldValue = this.value[pos];
	this.value[pos] = v;
	return oldValue;
    }

    /**
     * Removes the mapping associated with the first key in iteration order.
     *
     * @return the value previously associated with the first key in iteration
     *         order.
     * @throws NoSuchElementException is this map is empty.
     */
    public K removeFirst() {
	if (this.size == 0) {
	    throw new NoSuchElementException();
	}
	final int pos = this.first;
	final K fst = this.key[pos];
	this.order.removeIndex(0);
	if (this.order.size > 0) {
	    this.first = this.order.get(0);
	} else {
	    this.first = -1;
	}
	// Abbreviated version of fixOrder(pos)
	/*
	 * first = (int) link[pos]; if (0 <= first) { // Special case of SET_PREV( link[
	 * first ], -1 ) link[first] |= (-1 & 0xFFFFFFFFL) << 32; }
	 */
	this.size--;
	final int v = this.value[pos];
	if (pos == this.n) {
	    this.containsNullKey = false;
	    this.key[this.n] = null;
	} else {
	    this.shiftKeys(pos);
	}
	this.fixValues(v);
	if (this.size < this.maxFill / 4 && this.n > Arrangement.DEFAULT_INITIAL_SIZE) {
	    this.rehash(this.n / 2);
	}
	return fst;
    }

    /**
     * Removes the mapping associated with the last key in iteration order.
     *
     * @return the value previously associated with the last key in iteration order.
     * @throws NoSuchElementException is this map is empty.
     */
    public K removeLast() {
	if (this.size == 0) {
	    throw new NoSuchElementException();
	}
	final int pos = this.last;
	final K lst = this.key[pos];
	this.order.pop();
	if (this.order.size > 0) {
	    this.last = this.order.get(this.order.size - 1);
	} else {
	    this.last = -1;
	}
	// Abbreviated version of fixOrder(pos)
	/*
	 * last = (int) (link[pos] >>> 32); if (0 <= last) { // Special case of
	 * SET_NEXT( link[ last ], -1 ) link[last] |= -1 & 0xFFFFFFFFL; }
	 */
	this.size--;
	if (pos == this.n) {
	    this.containsNullKey = false;
	    this.key[this.n] = null;
	} else {
	    this.shiftKeys(pos);
	}
	// fixValues(v); // one case where we don't need to do this; the last item is
	// just given -1
	this.value[pos] = -1;
	if (this.size < this.maxFill / 4 && this.n > Arrangement.DEFAULT_INITIAL_SIZE) {
	    this.rehash(this.n / 2);
	}
	return lst;
    }

    private void moveIndexToFirst(final int i) {
	if (this.size <= 1 || this.first == i) {
	    return;
	}
	this.order.moveToFirst(i);
	if (this.last == i) {
	    this.last = this.order.peek();
	    // last = (int) (link[i] >>> 32);
	    // Special case of SET_NEXT( link[ last ], -1 );
	    // link[last] |= -1 & 0xFFFFFFFFL;
	} /*
	   * else { final long linki = link[i]; final int prev = (int) (linki >>> 32);
	   * final int next = (int) linki; link[prev] ^= ((link[prev] ^ (linki &
	   * 0xFFFFFFFFL)) & 0xFFFFFFFFL); link[next] ^= ((link[next] ^ (linki &
	   * 0xFFFFFFFF00000000L)) & 0xFFFFFFFF00000000L); } link[first] ^= ((link[first]
	   * ^ ((i & 0xFFFFFFFFL) << 32)) & 0xFFFFFFFF00000000L); link[i] = ((-1 &
	   * 0xFFFFFFFFL) << 32) | (first & 0xFFFFFFFFL);
	   */
	this.first = i;
	this.fixValues(0);
    }

    private void moveIndexToLast(final int i) {
	if (this.size <= 1 || this.last == i) {
	    return;
	}
	this.order.moveToLast(i);
	if (this.first == i) {
	    this.first = this.order.get(0);
	    // first = (int) link[i];
	    // Special case of SET_PREV( link[ first ], -1 );
	    // link[first] |= (-1 & 0xFFFFFFFFL) << 32;
	} /*
	   * else { final long linki = link[i]; final int prev = (int) (linki >>> 32);
	   * final int next = (int) linki; link[prev] ^= ((link[prev] ^ (linki &
	   * 0xFFFFFFFFL)) & 0xFFFFFFFFL); link[next] ^= ((link[next] ^ (linki &
	   * 0xFFFFFFFF00000000L)) & 0xFFFFFFFF00000000L); } link[last] ^= ((link[last] ^
	   * (i & 0xFFFFFFFFL)) & 0xFFFFFFFFL); link[i] = ((last & 0xFFFFFFFFL) << 32) |
	   * (-1 & 0xFFFFFFFFL);
	   */
	this.last = i;
	this.fixValues(i);
    }

    /**
     * Returns the value to which the given key is mapped; if the key is present, it
     * is moved to the first position of the iteration order.
     *
     * @param k the key.
     * @return the corresponding value, or -1 if no value was present for the given
     *         key.
     */
    public int getAndMoveToFirst(final K k) {
	if (k == null) {
	    if (this.containsNullKey) {
		this.moveIndexToFirst(this.n);
		return this.value[this.n];
	    }
	    return this.defRetValue;
	}
	K curr;
	final K[] key = this.key;
	int pos;
	// The starting point.
	if ((curr = key[pos = HashCommon.mix(this.hasher.hash(k)) & this.mask]) == null) {
	    return this.defRetValue;
	}
	if (this.hasher.areEqual(k, curr)) {
	    this.moveIndexToFirst(pos);
	    return this.value[pos];
	}
	// There's always an unused entry.
	while (true) {
	    if ((curr = key[pos = pos + 1 & this.mask]) == null) {
		return this.defRetValue;
	    }
	    if (this.hasher.areEqual(k, curr)) {
		this.moveIndexToFirst(pos);
		return this.value[pos];
	    }
	}
    }

    /**
     * Returns the value to which the given key is mapped; if the key is present, it
     * is moved to the last position of the iteration order.
     *
     * @param k the key.
     * @return the corresponding value, or -1 if no value was present for the given
     *         key.
     */
    public int getAndMoveToLast(final K k) {
	if (k == null) {
	    if (this.containsNullKey) {
		this.moveIndexToLast(this.n);
		return this.value[this.n];
	    }
	    return this.defRetValue;
	}
	K curr;
	final K[] key = this.key;
	int pos;
	// The starting point.
	if ((curr = key[pos = HashCommon.mix(this.hasher.hash(k)) & this.mask]) == null) {
	    return this.defRetValue;
	}
	if (this.hasher.areEqual(k, curr)) {
	    this.moveIndexToLast(pos);
	    return this.value[pos];
	}
	// There's always an unused entry.
	while (true) {
	    if ((curr = key[pos = pos + 1 & this.mask]) == null) {
		return this.defRetValue;
	    }
	    if (this.hasher.areEqual(k, curr)) {
		this.moveIndexToLast(pos);
		return this.value[pos];
	    }
	}
    }

    /**
     * Adds a pair to the map; if the key is already present, it is moved to the
     * first position of the iteration order.
     *
     * @param k the key.
     * @param v the value.
     * @return the old value, or -1 if no value was present for the given key.
     */
    public int putAndMoveToFirst(final K k, final int v) {
	int pos;
	if (k == null) {
	    if (this.containsNullKey) {
		this.moveIndexToFirst(this.n);
		return this.setValue(this.n, 0);
	    }
	    this.containsNullKey = true;
	    pos = this.n;
	} else {
	    K curr;
	    final K[] key = this.key;
	    // The starting point.
	    if (!((curr = key[pos = HashCommon.mix(this.hasher.hash(k)) & this.mask]) == null)) {
		if (this.hasher.areEqual(curr, k)) {
		    this.moveIndexToFirst(pos);
		    return this.setValue(pos, 0);
		}
		while (!((curr = key[pos = pos + 1 & this.mask]) == null)) {
		    if (this.hasher.areEqual(curr, k)) {
			this.moveIndexToFirst(pos);
			return this.setValue(pos, 0);
		    }
		}
	    }
	}
	this.key[pos] = k;
	if (this.size == 0) {
	    this.first = this.last = pos;
	    // Special case of SET_UPPER_LOWER( link[ pos ], -1, -1 );
	    // link[pos] = -1L;
	} else {
	    // link[first] ^= ((link[first] ^ ((pos & 0xFFFFFFFFL) << 32)) &
	    // 0xFFFFFFFF00000000L);
	    // link[pos] = ((-1 & 0xFFFFFFFFL) << 32) | (first & 0xFFFFFFFFL);
	    this.first = pos;
	}
	this.order.insert(0, pos);
	this.fixValues(0);
	if (this.size++ >= this.maxFill) {
	    this.rehash(Arrangement.arraySize(this.size, this.f));
	}
	return this.defRetValue;
    }

    /**
     * Adds a pair to the map; if the key is already present, it is moved to the
     * last position of the iteration order.
     *
     * @param k the key.
     * @param v the value.
     * @return the old value, or -1 if no value was present for the given key.
     */
    public int putAndMoveToLast(final K k, final int v) {
	int pos;
	if (k == null) {
	    if (this.containsNullKey) {
		this.moveIndexToLast(this.n);
		return this.setValue(this.n, this.size - 1);
	    }
	    this.containsNullKey = true;
	    pos = this.n;
	} else {
	    K curr;
	    final K[] key = this.key;
	    // The starting point.
	    if (!((curr = key[pos = HashCommon.mix(this.hasher.hash(k)) & this.mask]) == null)) {
		if (this.hasher.areEqual(curr, k)) {
		    this.moveIndexToLast(pos);
		    return this.setValue(pos, this.size - 1);
		}
		while (!((curr = key[pos = pos + 1 & this.mask]) == null)) {
		    if (this.hasher.areEqual(curr, k)) {
			this.moveIndexToLast(pos);
			return this.setValue(pos, this.size - 1);
		    }
		}
	    }
	}
	this.key[pos] = k;
	this.value[pos] = this.size;
	if (this.size == 0) {
	    this.first = this.last = pos;
	    // Special case of SET_UPPER_LOWER( link[ pos ], -1, -1 );
	    // link[pos] = -1L;
	} else {
	    // link[last] ^= ((link[last] ^ (pos & 0xFFFFFFFFL)) & 0xFFFFFFFFL);
	    // link[pos] = ((last & 0xFFFFFFFFL) << 32) | (-1 & 0xFFFFFFFFL);
	    this.last = pos;
	}
	this.order.add(pos);
	if (this.size++ >= this.maxFill) {
	    this.rehash(Arrangement.arraySize(this.size, this.f));
	}
	return this.defRetValue;
    }

    @Override
    public Integer get(final Object k) {
	if (k == null) {
	    return this.containsNullKey ? this.value[this.n] : this.defRetValue;
	}
	K curr;
	final K[] key = this.key;
	int pos;
	// The starting point.
	if ((curr = key[pos = HashCommon.mix(this.hasher.hash(k)) & this.mask]) == null) {
	    return this.defRetValue;
	}
	if (this.hasher.areEqual(k, curr)) {
	    return this.value[pos];
	}
	// There's always an unused entry.
	while (true) {
	    if ((curr = key[pos = pos + 1 & this.mask]) == null) {
		return this.defRetValue;
	    }
	    if (this.hasher.areEqual(k, curr)) {
		return this.value[pos];
	    }
	}
    }

    public int getInt(final Object k) {
	if (k == null) {
	    return this.containsNullKey ? this.value[this.n] : this.defRetValue;
	}
	K curr;
	final K[] key = this.key;
	int pos;
	// The starting point.
	if ((curr = key[pos = HashCommon.mix(this.hasher.hash(k)) & this.mask]) == null) {
	    return this.defRetValue;
	}
	if (this.hasher.areEqual(k, curr)) {
	    return this.value[pos];
	}
	// There's always an unused entry.
	while (true) {
	    if ((curr = key[pos = pos + 1 & this.mask]) == null) {
		return this.defRetValue;
	    }
	    if (this.hasher.areEqual(k, curr)) {
		return this.value[pos];
	    }
	}
    }

    @Override
    public boolean containsKey(final Object k) {
	if (k == null) {
	    return this.containsNullKey;
	}
	K curr;
	final K[] key = this.key;
	int pos;
	// The starting point.
	if ((curr = key[pos = HashCommon.mix(this.hasher.hash(k)) & this.mask]) == null) {
	    return false;
	}
	if (this.hasher.areEqual(k, curr)) {
	    return true;
	}
	// There's always an unused entry.
	while (true) {
	    if ((curr = key[pos = pos + 1 & this.mask]) == null) {
		return false;
	    }
	    if (this.hasher.areEqual(k, curr)) {
		return true;
	    }
	}
    }

    public boolean containsValue(final int v) {
	return v >= 0 && v < this.size;
    }

    @Override
    public boolean containsValue(final Object ov) {
	return ov != null && this.containsValue(((Integer) ov).intValue());
    }

    /*
     * Removes all elements from this map.
     *
     * <P>To increase object reuse, this method does not change the table size. If
     * you want to reduce the table size, you must use {@link #trim()}.
     */
    @Override
    public void clear() {
	if (this.size == 0) {
	    return;
	}
	this.size = 0;
	this.containsNullKey = false;
	Arrays.fill(this.key, null);
	Arrays.fill(this.value, -1);
	this.first = this.last = -1;
	this.order.clear();
    }

    @Override
    public int size() {
	return this.size;
    }

    @Override
    public boolean isEmpty() {
	return this.size == 0;
    }

    /**
     * Returns an iterator over elements of type {@code T}.
     *
     * @return an Iterator.
     */
    @Override
    public Iterator<K> iterator() {
	return new KeyIterator();
    }

    /**
     * The entry class for a hash map does not record key and value, but rather the
     * position in the hash table of the corresponding entry. This is necessary so
     * that calls to {@link java.util.Map.Entry#setValue(Object)} are reflected in
     * the map
     */
    final class MapEntry implements Map.Entry<K, Integer> {
	// The table index this entry refers to, or -1 if this entry has been
	// deleted.
	int index;

	MapEntry(final int index) {
	    this.index = index;
	}

	MapEntry() {
	}

	@Override
	public K getKey() {
	    return Arrangement.this.key[this.index];
	}

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated Please use the corresponding type-specific method instead.
	 */
	@Override
	@Deprecated
	public Integer getValue() {
	    return Arrangement.this.value[this.index];
	}

	public int getIntValue() {
	    return Arrangement.this.value[this.index];
	}

	public int setValue(final int v) {
	    final int oldValue = Arrangement.this.value[this.index];
	    Arrangement.this.value[this.index] = v;
	    return oldValue;
	}

	@Override
	public Integer setValue(final Integer v) {
	    return this.setValue(v.intValue());
	}

	@Override
	@SuppressWarnings("unchecked")
	public boolean equals(final Object o) {
	    if (!(o instanceof Map.Entry)) {
		return false;
	    }
	    final Map.Entry<K, Integer> e = (Map.Entry<K, Integer>) o;
	    return (Arrangement.this.key[this.index] == null ? e.getKey() == null
		    : Arrangement.this.key[this.index].equals(e.getKey()))
		    && Arrangement.this.value[this.index] == e.getValue();
	}

	@Override
	public int hashCode() {
	    return (Arrangement.this.key[this.index] == null ? 0
		    : Arrangement.this.hasher.hash(Arrangement.this.key[this.index]))
		    ^ Arrangement.this.value[this.index];
	}

	@Override
	public String toString() {
	    return Arrangement.this.key[this.index] + "=>" + Arrangement.this.value[this.index];
	}
    }

    /**
     * Modifies the link vector so that the given entry is removed. This method will
     * complete in logarithmic time.
     *
     * @param i the index of an entry.
     */
    protected void fixOrder(final int i) {
	if (this.size == 0) {
	    this.order.clear();
	    this.first = this.last = -1;
	    return;
	}
	this.order.removeValue(i);
	if (this.first == i) {
	    this.first = this.order.get(0);
	    // first = (int) link[i];
	    /*
	     * if (0 <= first) { // Special case of SET_PREV( link[ first ], -1 )
	     * link[first] |= (-1 & 0xFFFFFFFFL) << 32; } return;
	     */
	}
	if (this.last == i) {
	    this.last = this.order.peek();
	    // last = (int) (link[i] >>> 32);
	    /*
	     * if (0 <= last) { // Special case of SET_NEXT( link[ last ], -1 ) link[last]
	     * |= -1 & 0xFFFFFFFFL; } return;
	     */
	}
	/*
	 * final long linki = link[i]; final int prev = (int) (linki >>> 32); final int
	 * next = (int) linki; link[prev] ^= ((link[prev] ^ (linki & 0xFFFFFFFFL)) &
	 * 0xFFFFFFFFL); link[next] ^= ((link[next] ^ (linki & 0xFFFFFFFF00000000L)) &
	 * 0xFFFFFFFF00000000L);
	 */
    }

    /**
     * Modifies the link vector for a shift from s to d. <br>
     * This method will complete in logarithmic time or better.
     *
     * @param s the source position.
     * @param d the destination position.
     */
    protected void fixOrder(final int s, final int d) {
	if (this.size == 1) {
	    this.first = this.last = d;
	    // Special case of SET_UPPER_LOWER( link[ d ], -1, -1 )
	    // link[d] = -1L;
	    this.order.set(0, d);
	} else if (this.first == s) {
	    this.first = d;
	    this.order.set(0, d);
	    // link[(int) link[s]] ^= ((link[(int) link[s]] ^ ((d & 0xFFFFFFFFL) << 32)) &
	    // 0xFFFFFFFF00000000L);
	    // link[d] = link[s];
	} else if (this.last == s) {
	    this.last = d;
	    this.order.set(this.order.size - 1, d);
	    // link[(int) (link[s] >>> 32)] ^= ((link[(int) (link[s] >>> 32)] ^ (d &
	    // 0xFFFFFFFFL)) & 0xFFFFFFFFL);
	    // link[d] = link[s];
	} else {
	    final int idx = this.order.indexOf(s);
	    this.order.set(idx, d);
	    // value[s] = idx;
	}
	/*
	 * final long links = link[s]; final int prev = (int) (links >>> 32); final int
	 * next = (int) links; link[prev] ^= ((link[prev] ^ (d & 0xFFFFFFFFL)) &
	 * 0xFFFFFFFFL); link[next] ^= ((link[next] ^ ((d & 0xFFFFFFFFL) << 32)) &
	 * 0xFFFFFFFF00000000L); link[d] = links;
	 */
    }

    /**
     * Returns the first key of this map in iteration order.
     *
     * @return the first key in iteration order.
     */
    @Override
    public K firstKey() {
	if (this.size == 0) {
	    throw new NoSuchElementException();
	}
	return this.key[this.first];
    }

    /**
     * Returns the last key of this map in iteration order.
     *
     * @return the last key in iteration order.
     */
    @Override
    public K lastKey() {
	if (this.size == 0) {
	    throw new NoSuchElementException();
	}
	return this.key[this.last];
    }

    /**
     * Retains in this collection only elements from the given collection.
     *
     * @param c a collection.
     * @return <code>true</code> if this collection changed as a result of the call.
     */
    public boolean retainAll(final Collection<?> c) {
	boolean retVal = false;
	int n = this.size;
	while (n-- != 0) {
	    if (!c.contains(this.key[this.order.get(n)])) {
		this.removeAt(n);
		retVal = true;
	    }
	}
	return retVal;
    }

    @Override
    public Comparator<? super K> comparator() {
	return null;
    }

    @Override
    public SortedMap<K, Integer> tailMap(final K from) {
	throw new UnsupportedOperationException();
    }

    @Override
    public SortedMap<K, Integer> headMap(final K to) {
	throw new UnsupportedOperationException();
    }

    @Override
    public SortedMap<K, Integer> subMap(final K from, final K to) {
	throw new UnsupportedOperationException();
    }

    /**
     * A list iterator over a Arrangement.
     *
     * <P>
     * This class provides a list iterator over a Arrangement. The constructor runs
     * in constant time.
     */
    private class MapIterator {
	/**
	 * The entry that will be returned by the next call to
	 * {@link ListIterator#previous()} (or <code>null</code> if no previous entry
	 * exists).
	 */
	int prev = -1;
	/**
	 * The entry that will be returned by the next call to
	 * {@link ListIterator#next()} (or <code>null</code> if no next entry exists).
	 */
	int next = -1;
	/**
	 * The last entry that was returned (or -1 if we did not iterate or used
	 * {@link Iterator#remove()}).
	 */
	int curr = -1;
	/**
	 * The current index (in the sense of a {@link ListIterator}). Note that this
	 * value is not meaningful when this iterator has been created using the
	 * nonempty constructor.
	 */
	int index = 0;

	private MapIterator() {
	    this.next = Arrangement.this.first;
	    this.index = 0;
	}

	/*
	 * private MapIterator(final K from) { if (((from) == null)) { if
	 * (containsNullKey) { next = (int) link[n]; prev = n; return; } else throw new
	 * NoSuchElementException("The key null" + " does not belong to this map."); }
	 * if (((key[last]) != null && (key[last]).equals(from))) { prev = last; index =
	 * size; return; } // The starting point. int pos =
	 * (HashCommon.mix((from).hashCode())) & mask; // There's always an unused
	 * entry. while (!((key[pos]) == null)) { if (((key[pos]).equals(from))) { //
	 * Note: no valid index known. next = (int) link[pos]; prev = pos; return; } pos
	 * = (pos + 1) & mask; } throw new NoSuchElementException("The key " + from +
	 * " does not belong to this map."); }
	 */
	public boolean hasNext() {
	    return this.next != -1;
	}

	public boolean hasPrevious() {
	    return this.prev != -1;
	}

	private void ensureIndexKnown() {
	    if (this.index >= 0) {
		return;
	    }
	    if (this.prev == -1) {
		this.index = 0;
		return;
	    }
	    if (this.next == -1) {
		this.index = Arrangement.this.size;
		return;
	    }
	    this.index = 0;
	    /*
	     * while (pos != prev) { pos = (int) link[pos]; index++; }
	     */
	}

	public int nextIndex() {
	    this.ensureIndexKnown();
	    return this.index + 1;
	}

	public int previousIndex() {
	    this.ensureIndexKnown();
	    return this.index - 1;
	}

	public int nextEntry() {
	    if (!this.hasNext()) {
		throw new NoSuchElementException();
	    }
	    this.curr = this.next;
	    if (++this.index >= Arrangement.this.order.size) {
		this.next = -1;
	    } else {
		this.next = Arrangement.this.order.get(this.index);// (int) link[curr];
	    }
	    this.prev = this.curr;
	    return this.curr;
	}

	public int previousEntry() {
	    if (!this.hasPrevious()) {
		throw new NoSuchElementException();
	    }
	    this.curr = this.prev;
	    if (--this.index < 1) {
		this.prev = -1;
	    } else {
		this.prev = Arrangement.this.order.get(this.index - 1);
	    }
	    // prev = (int) (link[curr] >>> 32);
	    this.next = this.curr;
	    return this.curr;
	}

	public void remove() {
	    this.ensureIndexKnown();
	    if (this.curr == -1) {
		throw new IllegalStateException();
	    }
	    if (this.curr == this.prev) {
		/*
		 * If the last operation was a next(), we are removing an entry that precedes
		 * the current index, and thus we must decrement it.
		 */
		if (--this.index >= 1) {
		    this.prev = Arrangement.this.order.get(this.index - 1); // (int) (link[curr] >>> 32);
		} else {
		    this.prev = -1;
		}
	    } else {
		if (this.index < Arrangement.this.order.size - 1) {
		    this.next = Arrangement.this.order.get(this.index + 1);
		} else {
		    this.next = -1;
		}
	    }
	    /*
	     * Now we manually fix the pointers. Because of our knowledge of next and prev,
	     * this is going to be faster than calling fixOrder().
	     */
	    if (this.prev == -1) {
		Arrangement.this.first = this.next;
	    }
	    if (this.next == -1) {
		Arrangement.this.last = this.prev;
	    }
	    Arrangement.this.order.removeIndex(this.index);
	    Arrangement.this.size--;
	    int last, slot, pos = this.curr;
	    this.curr = -1;
	    if (pos == Arrangement.this.n) {
		Arrangement.this.containsNullKey = false;
		Arrangement.this.key[Arrangement.this.n] = null;
	    } else {
		K curr;
		final K[] key = Arrangement.this.key;
		// We have to horribly duplicate the shiftKeys() code because we
		// need to update next/prev.
		for (;;) {
		    pos = (last = pos) + 1 & Arrangement.this.mask;
		    for (;;) {
			if ((curr = key[pos]) == null) {
			    key[last] = null;
			    Arrangement.this.fixValues(this.index);
			    return;
			}
			slot = HashCommon.mix(Arrangement.this.hasher.hash(curr)) & Arrangement.this.mask;
			if (last <= pos ? last >= slot || slot > pos : last >= slot && slot > pos) {
			    break;
			}
			pos = pos + 1 & Arrangement.this.mask;
		    }
		    key[last] = curr;
		    if (this.next == pos) {
			this.next = last;
		    }
		    if (this.prev == pos) {
			this.prev = last;
		    }
		    Arrangement.this.fixOrder(pos, last);
		}
	    }
	}

	public int skip(final int n) {
	    int i = n;
	    while (i-- != 0 && this.hasNext()) {
		this.nextEntry();
	    }
	    return n - i - 1;
	}

	public int back(final int n) {
	    int i = n;
	    while (i-- != 0 && this.hasPrevious()) {
		this.previousEntry();
	    }
	    return n - i - 1;
	}
    }

    private class EntryIterator extends MapIterator implements Iterator<Entry<K, Integer>>, Serializable {
	private static final long serialVersionUID = 0L;
	private MapEntry entry;

	public EntryIterator() {
	}

	@Override
	public MapEntry next() {
	    return this.entry = new MapEntry(this.nextEntry());
	}

	@Override
	public void remove() {
	    super.remove();
	    this.entry.index = -1; // You cannot use a deleted entry.
	}
    }

    public class FastEntryIterator extends MapIterator implements ListIterator<MapEntry>, Serializable {
	private static final long serialVersionUID = 0L;
	final MapEntry entry = new MapEntry();

	public FastEntryIterator() {
	}

	@Override
	public MapEntry next() {
	    this.entry.index = this.nextEntry();
	    return this.entry;
	}

	@Override
	public MapEntry previous() {
	    this.entry.index = this.previousEntry();
	    return this.entry;
	}

	@Override
	public void set(final MapEntry ok) {
	    throw new UnsupportedOperationException();
	}

	@Override
	public void add(final MapEntry ok) {
	    throw new UnsupportedOperationException();
	}
    }

    private final class MapEntrySet implements Cloneable, SortedSet<Entry<K, Integer>>, Set<Entry<K, Integer>>,
	    Collection<Entry<K, Integer>>, Serializable {
	private static final long serialVersionUID = 0L;

	@Override
	public EntryIterator iterator() {
	    return new EntryIterator();
	}

	@Override
	public Comparator<? super Entry<K, Integer>> comparator() {
	    return null;
	}

	@Override
	public SortedSet<Entry<K, Integer>> subSet(final Entry<K, Integer> fromElement,
		final Entry<K, Integer> toElement) {
	    throw new UnsupportedOperationException();
	}

	@Override
	public SortedSet<Entry<K, Integer>> headSet(final Entry<K, Integer> toElement) {
	    throw new UnsupportedOperationException();
	}

	@Override
	public SortedSet<Entry<K, Integer>> tailSet(final Entry<K, Integer> fromElement) {
	    throw new UnsupportedOperationException();
	}

	@Override
	public Entry<K, Integer> first() {
	    if (Arrangement.this.size == 0) {
		throw new NoSuchElementException();
	    }
	    return new MapEntry(Arrangement.this.first);
	}

	@Override
	public Entry<K, Integer> last() {
	    if (Arrangement.this.size == 0) {
		throw new NoSuchElementException();
	    }
	    return new MapEntry(Arrangement.this.last);
	}

	@Override
	@SuppressWarnings("unchecked")
	public boolean contains(final Object o) {
	    if (!(o instanceof Map.Entry)) {
		return false;
	    }
	    final Entry<?, ?> e = (Entry<?, ?>) o;
	    final K k = (K) e.getKey();
	    final int v = (Integer) e.getValue();
	    if (k == null) {
		return Arrangement.this.containsNullKey && Arrangement.this.value[Arrangement.this.n] == v;
	    }
	    K curr;
	    final K[] key = Arrangement.this.key;
	    int pos;
	    // The starting point.
	    if ((curr = key[pos = HashCommon.mix(Arrangement.this.hasher.hash(k)) & Arrangement.this.mask]) == null) {
		return false;
	    }
	    if (Arrangement.this.hasher.areEqual(k, curr)) {
		return Arrangement.this.value[pos] == v;
	    }
	    // There's always an unused entry.
	    while (true) {
		if ((curr = key[pos = pos + 1 & Arrangement.this.mask]) == null) {
		    return false;
		}
		if (Arrangement.this.hasher.areEqual(k, curr)) {
		    return Arrangement.this.value[pos] == v;
		}
	    }
	}

	@SuppressWarnings("unchecked")
	protected boolean rem(final Object o) {
	    if (!(o instanceof Map.Entry)) {
		return false;
	    }
	    final Entry<?, ?> e = (Entry<?, ?>) o;
	    final K k = (K) e.getKey();
	    final int v = (Integer) e.getValue();
	    if (k == null) {
		if (Arrangement.this.containsNullKey && Arrangement.this.value[Arrangement.this.n] == v) {
		    Arrangement.this.removeNullEntry();
		    return true;
		}
		return false;
	    }
	    K curr;
	    final K[] key = Arrangement.this.key;
	    int pos;
	    // The starting point.
	    if ((curr = key[pos = HashCommon.mix(Arrangement.this.hasher.hash(k)) & Arrangement.this.mask]) == null) {
		return false;
	    }
	    if (Arrangement.this.hasher.areEqual(curr, k)) {
		if (Arrangement.this.value[pos] == v) {
		    Arrangement.this.removeEntry(pos);
		    return true;
		}
		return false;
	    }
	    while (true) {
		if ((curr = key[pos = pos + 1 & Arrangement.this.mask]) == null) {
		    return false;
		}
		if (Arrangement.this.hasher.areEqual(curr, k)) {
		    if (Arrangement.this.value[pos] == v) {
			Arrangement.this.removeEntry(pos);
			return true;
		    }
		}
	    }
	}

	@Override
	public boolean remove(final Object o) {
	    return this.rem(o);
	}

	@Override
	public int size() {
	    return Arrangement.this.size;
	}

	@Override
	public void clear() {
	    Arrangement.this.clear();
	}

	@Override
	public boolean equals(final Object o) {
	    if (o == this) {
		return true;
	    }
	    if (!(o instanceof Set)) {
		return false;
	    }
	    final Set<?> s = (Set<?>) o;
	    return s.size() == this.size() && this.containsAll(s);
	}

	@Override
	public Object[] toArray() {
	    final Object[] a = new Object[this.size()];
	    Arrangement.objectUnwrap(this.iterator(), a);
	    return a;
	}

	@Override
	@SuppressWarnings("unchecked")
	public <T> T[] toArray(T[] a) {
	    if (a == null || a.length < this.size()) {
		a = (T[]) new Object[this.size()];
	    }
	    Arrangement.objectUnwrap(this.iterator(), a);
	    return a;
	}

	/**
	 * Unsupported.
	 *
	 * @param c ignored
	 * @return nothing, throws UnsupportedOperationException
	 * @throws UnsupportedOperationException always
	 */
	@Override
	public boolean addAll(final Collection<? extends Entry<K, Integer>> c) {
	    throw new UnsupportedOperationException("addAll not supported");
	}

	/**
	 * Unsupported.
	 *
	 * @param k ignored
	 * @return nothing, throws UnsupportedOperationException
	 * @throws UnsupportedOperationException always
	 */
	@Override
	public boolean add(final Entry<K, Integer> k) {
	    throw new UnsupportedOperationException("add not supported");
	}

	/**
	 * Checks whether this collection contains all elements from the given
	 * collection.
	 *
	 * @param c a collection.
	 * @return <code>true</code> if this collection contains all elements of the
	 *         argument.
	 */
	@Override
	public boolean containsAll(final Collection<?> c) {
	    int n = c.size();
	    final Iterator<?> i = c.iterator();
	    while (n-- != 0) {
		if (!this.contains(i.next())) {
		    return false;
		}
	    }
	    return true;
	}

	/**
	 * Retains in this collection only elements from the given collection.
	 *
	 * @param c a collection.
	 * @return <code>true</code> if this collection changed as a result of the call.
	 */
	@Override
	public boolean retainAll(final Collection<?> c) {
	    boolean retVal = false;
	    int n = this.size();
	    final Iterator<?> i = this.iterator();
	    while (n-- != 0) {
		if (!c.contains(i.next())) {
		    i.remove();
		    retVal = true;
		}
	    }
	    return retVal;
	}

	/**
	 * Remove from this collection all elements in the given collection. If the
	 * collection is an instance of this class, it uses faster iterators.
	 *
	 * @param c a collection.
	 * @return <code>true</code> if this collection changed as a result of the call.
	 */
	@Override
	public boolean removeAll(final Collection<?> c) {
	    boolean retVal = false;
	    int n = c.size();
	    final Iterator<?> i = c.iterator();
	    while (n-- != 0) {
		if (this.remove(i.next())) {
		    retVal = true;
		}
	    }
	    return retVal;
	}

	@Override
	public boolean isEmpty() {
	    return this.size() == 0;
	}

	@Override
	public String toString() {
	    final StringBuilder s = new StringBuilder();
	    final EntryIterator i = this.iterator();
	    int n = this.size();
	    Object k;
	    boolean first = true;
	    s.append("{");
	    while (n-- != 0) {
		if (first) {
		    first = false;
		} else {
		    s.append(", ");
		}
		k = i.next();
		if (this == k) {
		    s.append("(this collection)");
		} else {
		    s.append(String.valueOf(k));
		}
	    }
	    s.append("}");
	    return s.toString();
	}
    }

    @Override
    public SortedSet<Entry<K, Integer>> entrySet() {
	if (this.entries == null) {
	    this.entries = new MapEntrySet();
	}
	return this.entries;
    }

    public MapEntrySet mapEntrySet() {
	if (this.entries == null) {
	    this.entries = new MapEntrySet();
	}
	return this.entries;
    }

    /**
     * An iterator on keys.
     * <p>
     * <P>
     * We simply override the
     * {@link ListIterator#next()}/{@link ListIterator#previous()} methods (and
     * possibly their type-specific counterparts) so that they return keys instead
     * of entries.
     */
    public final class KeyIterator extends MapIterator implements Iterator<K>, Serializable {
	private static final long serialVersionUID = 0L;

	public K previous() {
	    return Arrangement.this.key[this.previousEntry()];
	}

	public void set(final K k) {
	    throw new UnsupportedOperationException();
	}

	public void add(final K k) {
	    throw new UnsupportedOperationException();
	}

	public KeyIterator() {
	}

	@Override
	public K next() {
	    return Arrangement.this.key[this.nextEntry()];
	}

	@Override
	public void remove() {
	    super.remove();
	}
    }

    public final class KeySet implements SortedSet<K>, Serializable {
	private static final long serialVersionUID = 0L;

	@Override
	public KeyIterator iterator() {
	    return new KeyIterator();
	}

	@Override
	public int size() {
	    return Arrangement.this.size;
	}

	@Override
	public void clear() {
	    Arrangement.this.clear();
	}

	@Override
	public K first() {
	    if (Arrangement.this.size == 0) {
		throw new NoSuchElementException();
	    }
	    return Arrangement.this.key[Arrangement.this.first];
	}

	@Override
	public K last() {
	    if (Arrangement.this.size == 0) {
		throw new NoSuchElementException();
	    }
	    return Arrangement.this.key[Arrangement.this.last];
	}

	@Override
	public Comparator<K> comparator() {
	    return null;
	}

	@Override
	public SortedSet<K> tailSet(final K from) {
	    throw new UnsupportedOperationException();
	}

	@Override
	public SortedSet<K> headSet(final K to) {
	    throw new UnsupportedOperationException();
	}

	@Override
	public SortedSet<K> subSet(final K from, final K to) {
	    throw new UnsupportedOperationException();
	}

	@SuppressWarnings("unchecked")
	@Override
	public <T> T[] toArray(T[] a) {
	    if (a == null || a.length < this.size()) {
		a = (T[]) new Object[this.size()];
	    }
	    this.unwrap(this.iterator(), a);
	    return a;
	}

	/**
	 * Always throws an UnsupportedOperationException
	 */
	@Override
	public boolean remove(final Object ok) {
	    throw new UnsupportedOperationException("Cannot remove from the key set directly");
	}

	/**
	 * Always throws an UnsupportedOperationException
	 */
	@Override
	public boolean add(final K o) {
	    throw new UnsupportedOperationException("Cannot add to the key set directly");
	}

	/**
	 * Delegates to the corresponding type-specific method.
	 */
	@Override
	public boolean contains(final Object o) {
	    return Arrangement.this.containsKey(o);
	}

	/**
	 * Checks whether this collection contains all elements from the given
	 * type-specific collection.
	 *
	 * @param c a type-specific collection.
	 * @return <code>true</code> if this collection contains all elements of the
	 *         argument.
	 */
	@Override
	public boolean containsAll(final Collection<?> c) {
	    final Iterator<?> i = c.iterator();
	    int n = c.size();
	    while (n-- != 0) {
		if (!this.contains(i.next())) {
		    return false;
		}
	    }
	    return true;
	}

	/**
	 * Retains in this collection only elements from the given type-specific
	 * collection.
	 *
	 * @param c a type-specific collection.
	 * @return <code>true</code> if this collection changed as a result of the call.
	 */
	@Override
	public boolean retainAll(final Collection<?> c) {
	    throw new UnsupportedOperationException("Cannot remove from the key set directly");
	}

	/**
	 * Remove from this collection all elements in the given type-specific
	 * collection.
	 *
	 * @param c a type-specific collection.
	 * @return <code>true</code> if this collection changed as a result of the call.
	 */
	@Override
	public boolean removeAll(final Collection<?> c) {
	    throw new UnsupportedOperationException("Cannot remove from the key set directly");
	}

	@Override
	public Object[] toArray() {
	    final Object[] a = new Object[this.size()];
	    Arrangement.objectUnwrap(this.iterator(), a);
	    return a;
	}

	/**
	 * Always throws an UnsupportedOperationException.
	 *
	 * @param c disregarded; always throws Exception
	 * @return nothing; always throws Exception
	 */
	@Override
	public boolean addAll(final Collection<? extends K> c) {
	    throw new UnsupportedOperationException("Cannot add to the key set directly");
	}

	@Override
	public boolean equals(final Object o) {
	    if (o == this) {
		return true;
	    }
	    if (!(o instanceof Set)) {
		return false;
	    }
	    final Set<?> s = (Set<?>) o;
	    if (s.size() != this.size()) {
		return false;
	    }
	    return this.containsAll(s);
	}

	/**
	 * Unwraps an iterator into an array starting at a given offset for a given
	 * number of elements.
	 * <p>
	 * <P>
	 * This method iterates over the given type-specific iterator and stores the
	 * elements returned, up to a maximum of <code>length</code>, in the given array
	 * starting at <code>offset</code>. The number of actually unwrapped elements is
	 * returned (it may be less than <code>max</code> if the iterator emits less
	 * than <code>max</code> elements).
	 *
	 * @param i      a type-specific iterator.
	 * @param array  an array to contain the output of the iterator.
	 * @param offset the first element of the array to be returned.
	 * @param max    the maximum number of elements to unwrap.
	 * @return the number of elements unwrapped.
	 */
	public int unwrap(final KeyIterator i, final Object[] array, int offset, final int max) {
	    if (max < 0) {
		throw new IllegalArgumentException("The maximum number of elements (" + max + ") is negative");
	    }
	    if (offset < 0 || offset + max > array.length) {
		throw new IllegalArgumentException();
	    }
	    int j = max;
	    while (j-- != 0 && i.hasNext()) {
		array[offset++] = i.next();
	    }
	    return max - j - 1;
	}

	/**
	 * Unwraps an iterator into an array.
	 * <p>
	 * <P>
	 * This method iterates over the given type-specific iterator and stores the
	 * elements returned in the given array. The iteration will stop when the
	 * iterator has no more elements or when the end of the array has been reached.
	 *
	 * @param i     a type-specific iterator.
	 * @param array an array to contain the output of the iterator.
	 * @return the number of elements unwrapped.
	 */
	public int unwrap(final KeyIterator i, final Object[] array) {
	    return this.unwrap(i, array, 0, array.length);
	}

	@Override
	public boolean isEmpty() {
	    return this.size() == 0;
	}

	@Override
	public String toString() {
	    final StringBuilder s = new StringBuilder();
	    final KeyIterator i = this.iterator();
	    int n = this.size();
	    boolean first = true;
	    s.append("{");
	    while (n-- != 0) {
		if (first) {
		    first = false;
		} else {
		    s.append(", ");
		}
		s.append(i.next());
	    }
	    s.append("}");
	    return s.toString();
	}
    }

    @Override
    public KeySet keySet() {
	if (this.keys == null) {
	    this.keys = new KeySet();
	}
	return this.keys;
    }

    public OrderedSet<K> keysAsOrderedSet() {
	final OrderedSet<K> os = new OrderedSet<>(this.size, this.f, this.hasher);
	for (int i = 0; i < this.size; i++) {
	    os.add(this.keyAt(i));
	}
	return os;
    }

    /**
     * An iterator on values.
     * <p>
     * <P>
     * We simply override the
     * {@link ListIterator#next()}/{@link ListIterator#previous()} methods (and
     * possibly their type-specific counterparts) so that they return values instead
     * of entries.
     */
    public final class ValueIterator extends MapIterator implements ListIterator<Integer>, Serializable {
	private static final long serialVersionUID = 0L;

	@Override
	public Integer previous() {
	    return this.index < 0 ? -1 : --this.index;
	}

	public int previousInt() {
	    return this.index < 0 ? -1 : --this.index;
	}

	@Override
	public void set(final Integer v) {
	    throw new UnsupportedOperationException();
	}

	@Override
	public void add(final Integer v) {
	    throw new UnsupportedOperationException();
	}

	public ValueIterator() {
	}

	@Override
	public Integer next() {
	    return this.index >= Arrangement.this.size - 1 ? -1 : ++this.index;
	}

	public int nextInt() {
	    return this.index >= Arrangement.this.size - 1 ? -1 : ++this.index;
	}

	@Override
	public void remove() {
	    super.remove();
	}
    }

    public final class ValueCollection extends AbstractCollection<Integer> implements Serializable {
	private static final long serialVersionUID = 0L;

	@Override
	public ValueIterator iterator() {
	    return new ValueIterator();
	}

	@Override
	public int size() {
	    return Arrangement.this.size;
	}

	@Override
	public boolean contains(final Object v) {
	    return Arrangement.this.containsValue(v);
	}

	@Override
	public void clear() {
	    Arrangement.this.clear();
	}
    }

    @Override
    public Collection<Integer> values() {
	if (this.values == null) {
	    this.values = new ValueCollection();
	}
	return this.values;
    }

    public ArrayList<Integer> valuesAsList() {
	final ArrayList<Integer> ls = new ArrayList<>(this.size);
	for (int i = 0; i < this.size; i++) {
	    ls.add(i);
	}
	return ls;
    }

    public IntVLA valuesAsIntVLA() {
	return new IntVLA(ArrayTools.range(this.size));
    }

    public int[] valuesAsArray() {
	return ArrayTools.range(this.size);
    }

    /**
     * Rehashes the map, making the table as small as possible.
     * <p>
     * <P>
     * This method rehashes the table to the smallest size satisfying the load
     * factor. It can be used when the set will not be changed anymore, so to
     * optimize access speed and size.
     * <p>
     * <P>
     * If the table size is already the minimum possible, this method does nothing.
     *
     * @return true if there was enough memory to trim the map.
     * @see #trim(int)
     */
    public boolean trim() {
	final int l = Arrangement.arraySize(this.size, this.f);
	if (l >= this.n || this.size > Arrangement.maxFill(l, this.f)) {
	    return true;
	}
	try {
	    this.rehash(l);
	} catch (final Exception cantDoIt) {
	    return false;
	}
	return true;
    }

    /**
     * Rehashes this map if the table is too large.
     * <p>
     * <P>
     * Let <var>N</var> be the smallest table size that can hold
     * <code>max(n,{@link #size()})</code> entries, still satisfying the load
     * factor. If the current table size is smaller than or equal to <var>N</var>,
     * this method does nothing. Otherwise, it rehashes this map in a table of size
     * <var>N</var>.
     * <p>
     * <P>
     * This method is useful when reusing maps. {@linkplain #clear() Clearing a map}
     * leaves the table size untouched. If you are reusing a map many times, you can
     * call this method with a typical size to avoid keeping around a very large
     * table just because of a few large transient maps.
     *
     * @param n the threshold for the trimming.
     * @return true if there was enough memory to trim the map.
     * @see #trim()
     */
    public boolean trim(final int n) {
	final int l = HashCommon.nextPowerOfTwo((int) Math.ceil(n / this.f));
	if (l >= n || this.size > Arrangement.maxFill(l, this.f)) {
	    return true;
	}
	try {
	    this.rehash(l);
	} catch (final Exception cantDoIt) {
	    return false;
	}
	return true;
    }

    /**
     * Rehashes the map.
     *
     * <P>
     * This method implements the basic rehashing strategy, and may be overriden by
     * subclasses implementing different rehashing strategies (e.g., disk-based
     * rehashing). However, you should not override this method unless you
     * understand the internal workings of this class.
     *
     * @param newN the new size
     */
    @SuppressWarnings("unchecked")
    protected void rehash(final int newN) {
	final K key[] = this.key;
	final int[] value = this.value;
	final int mask = newN - 1; // Note that this is used by the hashing macro
	final K newKey[] = (K[]) new Object[newN + 1];
	final int[] newValue = new int[newN + 1];
	int i, pos;
	final int sz = this.order.size, originalFirst = this.first, originalLast = this.last;
	for (int q = 0; q < sz; q++) {
	    i = this.order.get(q);
	    if (key[i] == null) {
		pos = newN;
	    } else {
		pos = HashCommon.mix(this.hasher.hash(key[i])) & mask;
		while (!(newKey[pos] == null)) {
		    pos = pos + 1 & mask;
		}
	    }
	    newKey[pos] = key[i];
	    newValue[pos] = value[i];
	    this.order.set(q, pos);
	    if (i == originalFirst) {
		this.first = pos;
	    }
	    if (i == originalLast) {
		this.last = pos;
	    }
	}
	this.n = newN;
	this.mask = mask;
	this.maxFill = Arrangement.maxFill(this.n, this.f);
	this.key = newKey;
	this.value = newValue;
    }

    /**
     * Returns a deep copy of this map.
     *
     * <P>
     * This method performs a deep copy of this Arrangement; the data stored in the
     * map, however, is not cloned. Note that this makes a difference only for
     * object keys.
     *
     * @return a deep copy of this map.
     */
    @Override
    @SuppressWarnings("unchecked")
    @GwtIncompatible
    public Arrangement<K> clone() {
	Arrangement<K> c;
	try {
	    c = (Arrangement<K>) super.clone();
	    c.key = (K[]) new Object[this.n + 1];
	    System.arraycopy(this.key, 0, c.key, 0, this.n + 1);
	    c.value = new int[this.n + 1];
	    System.arraycopy(this.value, 0, c.value, 0, this.n + 1);
	    c.order = (IntVLA) this.order.clone();
	    c.hasher = this.hasher;
	    return c;
	} catch (final Exception cantHappen) {
	    throw new UnsupportedOperationException(
		    cantHappen + (cantHappen.getMessage() != null ? "; " + cantHappen.getMessage() : ""));
	}
    }

    /**
     * Returns a hash code for this map.
     *
     * This method overrides the generic method provided by the superclass. Since
     * <code>equals()</code> is not overriden, it is important that the value
     * returned by this method is the same value as the one returned by the
     * overriden method.
     *
     * @return a hash code for this map.
     */
    @Override
    public int hashCode() {
	int h = 0;
	for (int j = this.realSize(), i = 0, t = 0; j-- != 0;) {
	    while (this.key[i] == null) {
		i++;
	    }
	    if (this != this.key[i]) {
		t = this.hasher.hash(this.key[i]);
	    }
	    t ^= this.value[i];
	    h += t;
	    i++;
	}
	// Zero / null keys have hash zero.
	if (this.containsNullKey) {
	    h += this.value[this.n];
	}
	return h;
    }

    /**
     * Returns the maximum number of entries that can be filled before rehashing.
     *
     * @param n the size of the backing array.
     * @param f the load factor.
     * @return the maximum number of entries before rehashing.
     */
    public static int maxFill(final int n, final float f) {
	/*
	 * We must guarantee that there is always at least one free entry (even with
	 * pathological load factors).
	 */
	return Math.min((int) Math.ceil(n * f), n - 1);
    }

    /**
     * Returns the maximum number of entries that can be filled before rehashing.
     *
     * @param n the size of the backing array.
     * @param f the load factor.
     * @return the maximum number of entries before rehashing.
     */
    public static long maxFill(final long n, final float f) {
	/*
	 * We must guarantee that there is always at least one free entry (even with
	 * pathological load factors).
	 */
	return Math.min((long) Math.ceil(n * f), n - 1);
    }

    /**
     * Returns the least power of two smaller than or equal to 2<sup>30</sup> and
     * larger than or equal to <code>Math.ceil( expected / f )</code>.
     *
     * @param expected the expected number of elements in a hash table.
     * @param f        the load factor.
     * @return the minimum possible size for a backing array.
     * @throws IllegalArgumentException if the necessary size is larger than
     *                                  2<sup>30</sup>.
     */
    public static int arraySize(final int expected, final float f) {
	final long s = Math.max(2, HashCommon.nextPowerOfTwo((long) Math.ceil(expected / f)));
	if (s > 1 << 30) {
	    throw new IllegalArgumentException(
		    "Too large (" + expected + " expected elements with load factor " + f + ")");
	}
	return (int) s;
    }

    /**
     * Unwraps an iterator into an array starting at a given offset for a given
     * number of elements.
     *
     * <P>
     * This method iterates over the given type-specific iterator and stores the
     * elements returned, up to a maximum of <code>length</code>, in the given array
     * starting at <code>offset</code>. The number of actually unwrapped elements is
     * returned (it may be less than <code>max</code> if the iterator emits less
     * than <code>max</code> elements).
     *
     * @param i      a type-specific iterator.
     * @param array  an array to contain the output of the iterator.
     * @param offset the first element of the array to be returned.
     * @param max    the maximum number of elements to unwrap.
     * @return the number of elements unwrapped.
     */
    private static <K> int objectUnwrap(final Iterator<? extends K> i, final K array[], int offset, final int max) {
	if (max < 0) {
	    throw new IllegalArgumentException("The maximum number of elements (" + max + ") is negative");
	}
	if (offset < 0 || offset + max > array.length) {
	    throw new IllegalArgumentException();
	}
	int j = max;
	while (j-- != 0 && i.hasNext()) {
	    array[offset++] = i.next();
	}
	return max - j - 1;
    }

    /**
     * Unwraps an iterator into an array.
     *
     * <P>
     * This method iterates over the given type-specific iterator and stores the
     * elements returned in the given array. The iteration will stop when the
     * iterator has no more elements or when the end of the array has been reached.
     *
     * @param i     a type-specific iterator.
     * @param array an array to contain the output of the iterator.
     * @return the number of elements unwrapped.
     */
    private static <K> int objectUnwrap(final Iterator<? extends K> i, final K array[]) {
	return Arrangement.objectUnwrap(i, array, 0, array.length);
    }

    @Override
    public String toString() {
	final StringBuilder s = new StringBuilder();
	final int n = this.size();
	int i = 0;
	boolean first = true;
	s.append("Arrangement{");
	while (i < n) {
	    if (first) {
		first = false;
	    } else {
		s.append(", ");
	    }
	    s.append(this.entryAt(i++));
	}
	s.append("}");
	return s.toString();
    }

    @Override
    public boolean equals(final Object o) {
	if (o == this) {
	    return true;
	}
	if (!(o instanceof Map)) {
	    return false;
	}
	final Map<?, ?> m = (Map<?, ?>) o;
	if (m.size() != this.size()) {
	    return false;
	}
	return this.entrySet().containsAll(m.entrySet());
    }

    @GwtIncompatible
    private void writeObject(final java.io.ObjectOutputStream s) throws java.io.IOException {
	final K key[] = this.key;
	final int[] value = this.value;
	final MapIterator i = new MapIterator();
	s.defaultWriteObject();
	s.writeObject(this.hasher);
	for (int j = this.size, e; j-- != 0;) {
	    e = i.nextEntry();
	    s.writeObject(key[e]);
	    s.writeInt(value[e]);
	}
    }

    @GwtIncompatible
    @SuppressWarnings("unchecked")
    private void readObject(final java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException {
	s.defaultReadObject();
	this.hasher = (CrossHash.IHasher) s.readObject();
	this.n = Arrangement.arraySize(this.size, this.f);
	this.maxFill = Arrangement.maxFill(this.n, this.f);
	this.mask = this.n - 1;
	final K key[] = this.key = (K[]) new Object[this.n + 1];
	final int[] value = this.value = new int[this.n + 1];
	final IntVLA order = this.order = new IntVLA(this.n + 1);
	int prev = -1;
	this.first = this.last = -1;
	K k;
	int v;
	for (int i = this.size, pos; i-- != 0;) {
	    k = (K) s.readObject();
	    v = s.readInt();
	    if (k == null) {
		pos = this.n;
		this.containsNullKey = true;
	    } else {
		pos = HashCommon.mix(this.hasher.hash(k)) & this.mask;
		while (!(key[pos] == null)) {
		    pos = pos + 1 & this.mask;
		}
	    }
	    key[pos] = k;
	    value[pos] = v;
	    if (this.first != -1) {
		prev = pos;
	    } else {
		prev = this.first = pos;
	    }
	    order.add(pos);
	}
	this.last = prev;
    }

    /**
     * Gets the value at the given index in the iteration order in constant time
     * (random-access).
     *
     * @param idx the index in the iteration order of the value to fetch
     * @return the value at the index, if the index is valid, otherwise the default
     *         return value
     */
    public int getAt(final int idx) {
	int pos;
	if (idx < 0 || idx >= this.order.size) {
	    return this.defRetValue;
	}
	// The starting point.
	if (this.key[pos = this.order.get(idx)] == null) {
	    return this.containsNullKey ? this.value[this.n] : this.defRetValue;
	}
	return this.value[pos];
    }

    /**
     * Gets the key at the given index in the iteration order in constant time
     * (random-access).
     *
     * @param idx the index in the iteration order of the key to fetch
     * @return the key at the index, if the index is valid, otherwise null
     */
    public K keyAt(final int idx) {
	if (idx < 0 || idx >= this.order.size) {
	    return null;
	}
	// The starting point.
	return this.key[this.order.get(idx)];
    }

    /**
     * Gets the key-value Map.Entry at the given index in the iteration order in
     * constant time (random-access).
     *
     * @param idx the index in the iteration order of the entry to fetch
     * @return the key-value entry at the index, if the index is valid, otherwise
     *         null
     */
    public Entry<K, Integer> entryAt(final int idx) {
	if (idx < 0 || idx >= this.order.size) {
	    return null;
	}
	return new MapEntry(this.order.get(idx));
    }

    /**
     * Removes the key and value at the given index in the iteration order in
     * not-exactly constant time (though it still should be efficient).
     *
     * @param idx the index in the iteration order of the key and value to remove
     * @return the key removed, if there was anything removed, or null otherwise
     */
    public K removeAt(final int idx) {
	if (idx < 0 || idx >= this.order.size) {
	    return null;
	}
	final int pos = this.order.get(idx);
	K k;
	if ((k = this.key[pos]) == null) {
	    if (this.containsNullKey) {
		this.removeNullEntry();
	    }
	    return null;
	}
	this.removeEntry(pos);
	return k;
    }

    /**
     * Equivalent to {@link #add(Object)}, except that it can place k at any point
     * in the ordering (shifting up later entries and changing their values to match
     * their new positions in the ordering).
     *
     * @param idx the position in the ordering to place k at; will not be used if
     *            negative or greater than the current size (it can be equal to the
     *            current size)
     * @param k   the key to add into this Arrangement; its value will be idx
     * @return the previous position in the ordering that k had if already present,
     *         the previous size of the Arrangement if k was just added now, or -1
     *         if idx is invalid
     */
    public int addAt(final int idx, final K k) {
	if (idx < 0 || idx > this.size) {
	    return -1;
	}
	final int pos = this.insertAt(k, idx), oldValue = this.value[pos];
	this.fixValues(idx);
	if (pos < 0) {
	    return this.size - 1;
	}
	return oldValue;
    }

    /**
     * Gets a random value from this Arrangement in constant time, using the given
     * RNG to generate a random number.
     *
     * @param rng used to generate a random index for a value
     * @return a random value from this Arrangement, or -1 if this is empty
     */
    public int randomValue(final RNG rng) {
	if (rng == null) {
	    return this.defRetValue;
	}
	return this.getAt(rng.nextInt(this.order.size));
    }

    /**
     * Gets a random key from this Arrangement in constant time, using the given RNG
     * to generate a random number.
     *
     * @param rng used to generate a random index for a key
     * @return a random key from this Arrangement, or null if this is empty
     */
    public K randomKey(final RNG rng) {
	if (rng == null) {
	    return null;
	}
	return this.keyAt(rng.nextInt(this.order.size));
    }

    /**
     * Gets a random entry from this Arrangement in constant time, using the given
     * RNG to generate a random number.
     *
     * @param rng used to generate a random index for a entry
     * @return a random key-value entry from this Arrangement
     */
    public Entry<K, Integer> randomEntry(final RNG rng) {
	return new MapEntry(this.order.getRandomElement(rng));
    }

    /**
     * Randomly alters the iteration order for this Arrangement using the given RNG
     * to shuffle.
     *
     * @param rng used to generate a random ordering
     * @return this for chaining
     */
    public Arrangement<K> shuffle(final RNG rng) {
	if (this.size < 2) {
	    return this;
	}
	this.order.shuffle(rng);
	this.first = this.order.get(0);
	this.last = this.order.peek();
	this.fixValues(0);
	return this;
    }

    /**
     * Given an array or varargs of replacement indices for this Arrangement's
     * iteration order, reorders this so the first item in the returned version is
     * the same as {@code getAt(ordering[0])} (with some care taken for negative or
     * too-large indices), the second item in the returned version is the same as
     * {@code getAt(ordering[1])}, etc. <br>
     * Negative indices are considered reversed distances from the end of ordering,
     * so -1 refers to the same index as {@code ordering[ordering.length - 1]}. If
     * ordering is smaller than {@code size()}, only the indices up to the length of
     * ordering will be modified. If ordering is larger than {@code size()}, only as
     * many indices will be affected as {@code size()}, and reversed distances are
     * measured from the end of this Map's entries instead of the end of ordering.
     * Duplicate values in ordering will produce duplicate values in the returned
     * Map. <br>
     * This method modifies this Arrangement in-place and also returns it for
     * chaining.
     *
     * @param ordering an array or varargs of int indices, where the nth item in
     *                 ordering changes the nth item in this Map to have the value
     *                 currently in this Map at the index specified by the value in
     *                 ordering
     * @return this for chaining, after modifying it in-place
     */
    public Arrangement<K> reorder(final int... ordering) {
	if (ordering == null || ordering.length <= 0) {
	    return this;
	}
	this.order.reorder(ordering);
	this.first = this.order.get(0);
	this.last = this.order.peek();
	this.fixValues(0);
	return this;
    }

    private int alterEntry(final int pos, final K replacement) {
	final int[] value = this.value;
	final int v = value[pos], op = this.order.indexOf(pos);
	final boolean isFirst = op == 0, isLast = op == this.order.size - 1;
	this.shiftKeysValues(pos);
	int rep;
	if (replacement == null) {
	    if (this.containsNullKey) {
		return v;
	    }
	    rep = this.n;
	    this.containsNullKey = true;
	} else {
	    K curr;
	    final K[] key = this.key;
	    // The starting point.
	    if (!((curr = key[rep = HashCommon.mix(this.hasher.hash(replacement)) & this.mask]) == null)) {
		if (this.hasher.areEqual(curr, replacement)) {
		    return v;
		}
		while (!((curr = key[rep = rep + 1 & this.mask]) == null)) {
		    if (this.hasher.areEqual(curr, replacement)) {
			return v;
		    }
		}
	    }
	    key[rep] = replacement;
	    value[rep] = v;
	}
	this.order.set(op, rep);
	if (isFirst) {
	    this.first = rep;
	}
	if (isLast) {
	    this.last = rep;
	}
	return v;
    }

    private int alterNullEntry(final K replacement) {
	this.containsNullKey = false;
	this.key[this.n] = null;
	final int[] value = this.value;
	final int v = value[this.n];
	value[this.n] = -1;
	int rep;
	if (replacement == null) {
	    rep = this.n;
	    this.containsNullKey = true;
	} else {
	    K curr;
	    final K[] key = this.key;
	    // The starting point.
	    if ((curr = key[rep = HashCommon.mix(this.hasher.hash(replacement)) & this.mask]) != null) {
		if (this.hasher.areEqual(curr, replacement)) {
		    return v;
		}
		while ((curr = key[rep = rep + 1 & this.mask]) != null) {
		    if (this.hasher.areEqual(curr, replacement)) {
			return v;
		    }
		}
	    }
	    key[rep] = replacement;
	    value[rep] = v;
	}
	this.fixOrder(this.n, rep);
	return v;
    }

    /**
     * Swaps a key, original, for another key, replacement, while keeping
     * replacement at the same point in the iteration order as original and keeping
     * it associated with the same value (which also keeps its iteration index).
     *
     * @param original    the key to find and swap out
     * @param replacement the key to replace original with
     * @return the value associated with original before, and replacement now
     */
    public int alter(final K original, final K replacement) {
	if (original == null) {
	    if (this.containsNullKey) {
		return this.alterNullEntry(replacement);
	    } else {
		return this.add(replacement);
	    }
	} else if (this.hasher.areEqual(original, replacement)) {
	    return this.getInt(original);
	}
	K curr;
	final K[] key = this.key;
	int pos;
	// The starting point.
	if ((curr = key[pos = HashCommon.mix(this.hasher.hash(original)) & this.mask]) == null) {
	    return this.add(replacement);
	}
	if (this.hasher.areEqual(original, curr)) {
	    return this.alterEntry(pos, replacement);
	}
	while (true) {
	    if ((curr = key[pos = pos + 1 & this.mask]) == null) {
		return this.add(replacement);
	    }
	    if (this.hasher.areEqual(original, curr)) {
		return this.alterEntry(pos, replacement);
	    }
	}
    }

    public int[] getArray(final K[] keys) {
	if (keys == null) {
	    return new int[0];
	}
	final int len = keys.length;
	final int[] vals = new int[len];
	for (int i = 0; i < len; i++) {
	    vals[i] = this.getInt(keys[i]);
	}
	return vals;
    }

    public int[] getArray(final Collection<? extends K> keys) {
	if (keys == null) {
	    return new int[0];
	}
	final int len = keys.size();
	int i = 0;
	final int[] vals = new int[len];
	for (final K k : keys) {
	    vals[i++] = this.getInt(k);
	}
	return vals;
    }

    public IntVLA getMany(final Iterable<? extends K> keys) {
	if (keys == null) {
	    return new IntVLA();
	}
	final IntVLA vals = new IntVLA();
	for (final K k : keys) {
	    vals.add(this.getInt(k));
	}
	return vals;
    }

    public OrderedSet<K> keysAt(final int... positions) {
	if (this.keys == null || positions == null || positions.length <= 0) {
	    return new OrderedSet<>();
	}
	final OrderedSet<K> ks = new OrderedSet<>(positions.length);
	for (final int position : positions) {
	    ks.add(this.keyAt(position));
	}
	return ks;
    }

    public OrderedSet<K> keysAt(final IntVLA positions) {
	if (this.keys == null || positions == null || positions.size <= 0) {
	    return new OrderedSet<>();
	}
	final OrderedSet<K> ks = new OrderedSet<>(positions.size);
	for (int i = 0; i < positions.size; i++) {
	    ks.add(this.keyAt(positions.get(i)));
	}
	return ks;
    }

    /**
     * Produces a copy of this Arrangement, but only using up to the given amount of
     * items to take. Does a shallow copy of individual keys, so the references will
     * be shared.
     *
     * @param amount the number of items to copy from this Arrangement; will copy
     *               all items if greater than size
     * @return a new Arrangement with up to amount items copied from this into it.
     */
    public Arrangement<K> take(int amount) {
	amount = Math.min(this.size, Math.max(0, amount));
	final Arrangement<K> nx = new Arrangement<>(amount, this.f);
	for (int i = 0; i < amount; i++) {
	    nx.add(this.keyAt(i));
	}
	return nx;
    }

    protected int positionOf(final Object k) {
	if (k == null) {
	    return this.containsNullKey ? this.n : -1;
	}
	K curr;
	final K[] key = this.key;
	int pos;
	// The starting point.
	if ((curr = key[pos = HashCommon.mix(this.hasher.hash(k)) & this.mask]) == null) {
	    return -1;
	}
	if (this.hasher.areEqual(k, curr)) {
	    return pos;
	}
	// There's always an unused entry.
	while (true) {
	    if ((curr = key[pos = pos + 1 & this.mask]) == null) {
		return -1;
	    }
	    if (this.hasher.areEqual(k, curr)) {
		return pos;
	    }
	}
    }

    /**
     * Swaps the positions in the ordering for the given items, if they are both
     * present. Returns true if the ordering changed as a result of this call, or
     * false if it stayed the same (which can be because left or right was not
     * present, or because left and right are the same reference (so swapping would
     * do nothing)).
     *
     * @param left  an item that should be present in this OrderedSet
     * @param right an item that should be present in this OrderedSet
     * @return true if this OrderedSet changed in ordering as a result of this call,
     *         or false otherwise
     */
    public boolean swap(final K left, final K right) {
	if (left == right) {
	    return false;
	}
	final int l = this.getInt(left);
	if (l < 0) {
	    return false;
	}
	final int r = this.getInt(right);
	if (r < 0) {
	    return false;
	}
	final int posL = this.order.get(l), posR = this.order.get(r);
	this.value[posL] = r;
	this.value[posR] = l;
	this.order.swap(l, r);
	return true;
    }

    /**
     * Swaps the given indices in the ordering, if they are both ints between 0 and
     * size. Returns true if the ordering changed as a result of this call, or false
     * if it stayed the same (which can be because left or right referred to an
     * out-of-bounds index, or because left and right are equal (so swapping would
     * do nothing)).
     *
     * @param left  an index of an item in this OrderedSet, at least 0 and less than
     *              {@link #size()}
     * @param right an index of an item in this OrderedSet, at least 0 and less than
     *              {@link #size()}
     * @return true if this OrderedSet changed in ordering as a result of this call,
     *         or false otherwise
     */
    public boolean swapIndices(final int left, final int right) {
	if (left < 0 || right < 0 || left >= this.order.size || right >= this.order.size || left == right) {
	    return false;
	}
	final int posL = this.order.get(left), posR = this.order.get(right);
	this.value[posL] = right;
	this.value[posR] = left;
	this.order.swap(left, right);
	return true;
    }

    /**
     * Changes the K at the given index to replacement while keeping replacement at
     * the same point in the ordering.
     *
     * @param index       an index to replace the K key at
     * @param replacement another K key that will replace the original at the
     *                    remembered index
     * @return the int associated with the possibly-altered key; should be equal to
     *         index
     */
    public int alterAt(final int index, final K replacement) {
	return this.alter(this.keyAt(index), replacement);
    }
}
