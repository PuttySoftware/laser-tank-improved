/*
 * Copyright (C) 2002-2015 Sebastiano Vigna
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package squidpony.squidmath;

import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.ListIterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;

/**
 * A type-specific linked hash map with with a fast, primitive-based
 * implementation, originally from fastutil as Int2DoubleLinkedOpenHashMap.
 * <p>
 * <P>
 * Instances of this class use a hash table to represent a map. The table is
 * filled up to a specified <em>load factor</em>, and then doubled in size to
 * accommodate new entries. If the table is emptied below <em>one fourth</em> of
 * the load factor, it is halved in size. However, halving is not performed when
 * deleting entries from an iterator, as it would interfere with the iteration
 * process.
 * <p>
 * <p>
 * Note that {@link #clear()} does not modify the hash table size. Rather, a
 * family of {@linkplain #trim() trimming methods} lets you control the size of
 * the table; this is particularly useful if you reuse instances of this class.
 * <p>
 * <P>
 * Iterators generated by this map will enumerate pairs in the same order in
 * which they have been added to the map (addition of pairs whose key is already
 * present in the set does not change the iteration order). Note that this order
 * has nothing in common with the natural order of the keys. The order is kept
 * by means of a doubly linked list, represented <i>via</i> an array of longs
 * parallel to the table.
 * <p>
 * <P>
 * This class implements the interface of a sorted map, so to allow easy access
 * of the iteration order: for instance, you can get the first key in iteration
 * order with {@code firstKey()} without having to create an iterator; however,
 * this class partially violates the {@link java.util.SortedMap} contract
 * because all submap methods throw an exception and {@link #comparator()}
 * returns always <code>null</code>.
 * <p>
 * <p>
 * Additional methods, such as <code>getAndMoveToFirst()</code>, make it easy to
 * use instances of this class as a cache (e.g., with LRU policy).
 * <p>
 * <P>
 * The iterators provided by the views of this class using are type-specific
 * {@linkplain java.util.ListIterator list iterators}, and can be started at any
 * element <em>which is a key of the map</em>, or a
 * {@link NoSuchElementException} exception will be thrown. If, however, the
 * provided element is not the first or last key in the set, the first access to
 * the list index will require linear time, as in the worst case the entire key
 * set must be scanned in iteration order to retrieve the positional index of
 * the starting key. <br>
 * Thank you, Sebastiano Vigna, for making FastUtil available to the public with
 * such high quality. <br>
 * See https://github.com/vigna/fastutil for the original library.
 *
 * @author Sebastiano Vigna (responsible for all the hard parts)
 * @author Tommy Ettinger (just responsible for squashing several layers of
 *         parent classes into one monster class)
 */
public class IntDoubleOrderedMap implements SortedMap<Integer, Double>, java.io.Serializable, Cloneable {
    private static final long serialVersionUID = 0L;
    /**
     * The array of keys.
     */
    protected int[] key;
    /**
     * The array of values.
     */
    protected double[] value;
    /**
     * The mask for wrapping a position counter.
     */
    protected int mask;
    /**
     * Whether this set contains the key zero.
     */
    protected boolean containsNullKey;
    /**
     * The index of the first entry in iteration order. It is valid iff
     * {@link #size} is nonzero; otherwise, it contains -1.
     */
    protected int first = -1;
    /**
     * The index of the last entry in iteration order. It is valid iff {@link #size}
     * is nonzero; otherwise, it contains -1.
     */
    protected int last = -1;
    /**
     * For each entry, the next and the previous entry in iteration order, stored as
     * <code>((prev & 0xFFFFFFFFL) << 32) | (next & 0xFFFFFFFFL)</code>. The first
     * entry contains predecessor -1, and the last entry contains successor -1.
     */
    protected long[] link;
    /**
     * The current table size.
     */
    protected int n;
    /**
     * Threshold after which we rehash. It must be the table size times {@link #f}.
     */
    protected int maxFill;
    /**
     * Number of entries in the set (including the key zero, if present).
     */
    protected int size;
    /**
     * The acceptable load factor.
     */
    public final float f;
    /**
     * Cached set of entries.
     */
    protected volatile MapEntrySet entries;
    /**
     * Cached set of keys.
     */
    protected volatile KeySet keys;
    /**
     * Cached collection of values.
     */
    protected volatile DoubleCollection values;
    /**
     * Default return value.
     */
    protected double defRetValue;
    /**
     * The initial default size of a hash table.
     */
    public static final int DEFAULT_INITIAL_SIZE = 16;
    /**
     * The default load factor of a hash table.
     */
    public static final float DEFAULT_LOAD_FACTOR = .1875f; // .75f;
    /**
     * The load factor for a (usually small) table that is meant to be particularly
     * fast.
     */
    public static final float FAST_LOAD_FACTOR = .5f;
    /**
     * The load factor for a (usually very small) table that is meant to be
     * extremely fast.
     */
    public static final float VERY_FAST_LOAD_FACTOR = .25f;

    public void defaultReturnValue(final double rv) {
	this.defRetValue = rv;
    }

    public double defaultReturnValue() {
	return this.defRetValue;
    }

    /**
     * Creates a new hash map.
     * <p>
     * <p>
     * The actual table size will be the least power of two greater than
     * <code>expected</code>/<code>f</code>.
     *
     * @param expected the expected number of elements in the hash set.
     * @param f        the load factor.
     */
    public IntDoubleOrderedMap(final int expected, final float f) {
	if (f <= 0 || f > 1) {
	    throw new IllegalArgumentException("Load factor must be greater than 0 and smaller than or equal to 1");
	}
	if (expected < 0) {
	    throw new IllegalArgumentException("The expected number of elements must be nonnegative");
	}
	this.f = f;
	this.n = IntDoubleOrderedMap.arraySize(expected, f);
	this.mask = this.n - 1;
	this.maxFill = IntDoubleOrderedMap.maxFill(this.n, f);
	this.key = new int[this.n + 1];
	this.value = new double[this.n + 1];
	this.link = new long[this.n + 1];
    }

    /**
     * Creates a new hash map with 0.75f as load factor.
     *
     * @param expected the expected number of elements in the hash map.
     */
    public IntDoubleOrderedMap(final int expected) {
	this(expected, IntDoubleOrderedMap.DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new hash map with initial expected 16 entries and 0.75f as load
     * factor.
     */
    public IntDoubleOrderedMap() {
	this(IntDoubleOrderedMap.DEFAULT_INITIAL_SIZE, IntDoubleOrderedMap.DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new hash map copying a given one.
     *
     * @param m a {@link Map} to be copied into the new hash map.
     * @param f the load factor.
     */
    public IntDoubleOrderedMap(final Map<? extends Integer, ? extends Double> m, final float f) {
	this(m.size(), f);
	this.putAll(m);
    }

    /**
     * Creates a new hash map with 0.75f as load factor copying a given one.
     *
     * @param m a {@link Map} to be copied into the new hash map.
     */
    public IntDoubleOrderedMap(final Map<? extends Integer, ? extends Double> m) {
	this(m, IntDoubleOrderedMap.DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new hash map copying a given type-specific one.
     *
     * @param m a type-specific map to be copied into the new hash map.
     * @param f the load factor.
     */
    public IntDoubleOrderedMap(final IntDoubleOrderedMap m, final float f) {
	this(m.size(), f);
	this.putAll(m);
    }

    /**
     * Creates a new hash map with 0.75f as load factor copying a given
     * type-specific one.
     *
     * @param m a type-specific map to be copied into the new hash map.
     */
    public IntDoubleOrderedMap(final IntDoubleOrderedMap m) {
	this(m, IntDoubleOrderedMap.DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new hash map using the elements of two parallel arrays.
     *
     * @param k the array of keys of the new hash map.
     * @param v the array of corresponding values in the new hash map.
     * @param f the load factor.
     * @throws IllegalArgumentException if <code>k</code> and <code>v</code> have
     *                                  different lengths.
     */
    public IntDoubleOrderedMap(final int[] k, final double[] v, final float f) {
	this(k.length, f);
	if (k.length != v.length) {
	    throw new IllegalArgumentException(
		    "The key array and the value array have different lengths (" + k.length + " and " + v.length + ")");
	}
	for (int i = 0; i < k.length; i++) {
	    this.put(k[i], v[i]);
	}
    }

    /**
     * Creates a new hash map with 0.75f as load factor using the elements of two
     * parallel arrays.
     *
     * @param k the array of keys of the new hash map.
     * @param v the array of corresponding values in the new hash map.
     * @throws IllegalArgumentException if <code>k</code> and <code>v</code> have
     *                                  different lengths.
     */
    public IntDoubleOrderedMap(final int[] k, final double[] v) {
	this(k, v, IntDoubleOrderedMap.DEFAULT_LOAD_FACTOR);
    }

    @Override
    public boolean containsKey(final Object ok) {
	return this.containsKey(((Integer) ok).intValue());
    }

    /**
     * Delegates to the corresponding type-specific method, taking care of returning
     * <code>null</code> on a missing key.
     * <p>
     * <P>
     * This method must check whether the provided key is in the map using
     * <code>containsKey()</code>. Thus, it probes the map <em>twice</em>.
     * Implementors of subclasses should override it with a more efficient method.
     *
     * @deprecated Please use the corresponding type-specific method instead.
     */
    @Override
    @Deprecated
    public Double get(final Object ok) {
	final int k = (Integer) ok;
	return this.containsKey(k) ? this.get(k) : null;
    }

    private int realSize() {
	return this.containsNullKey ? this.size - 1 : this.size;
    }

    private void ensureCapacity(final int capacity) {
	final int needed = IntDoubleOrderedMap.arraySize(capacity, this.f);
	if (needed > this.n) {
	    this.rehash(needed);
	}
    }

    private void tryCapacity(final long capacity) {
	final int needed = (int) Math.min(1 << 30,
		Math.max(2, HashCommon.nextPowerOfTwo((long) Math.ceil(capacity / this.f))));
	if (needed > this.n) {
	    this.rehash(needed);
	}
    }

    private double removeEntry(final int pos) {
	final double oldValue = this.value[pos];
	this.size--;
	this.fixPointers(pos);
	this.shiftKeys(pos);
	if (this.size < this.maxFill / 4 && this.n > IntDoubleOrderedMap.DEFAULT_INITIAL_SIZE) {
	    this.rehash(this.n / 2);
	}
	return oldValue;
    }

    private double removeNullEntry() {
	this.containsNullKey = false;
	final double oldValue = this.value[this.n];
	this.size--;
	this.fixPointers(this.n);
	if (this.size < this.maxFill / 4 && this.n > IntDoubleOrderedMap.DEFAULT_INITIAL_SIZE) {
	    this.rehash(this.n / 2);
	}
	return oldValue;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void putAll(final Map<? extends Integer, ? extends Double> m) {
	if (this.f <= .5) {
	    this.ensureCapacity(m.size()); // The resulting map will be sized for m.size() elements
	} else {
	    this.tryCapacity(this.size() + m.size()); // The resulting map will be tentatively sized for size() +
						      // m.size()
	}
	// elements
	int n = m.size();
	final Iterator<? extends Entry<? extends Integer, ? extends Double>> i = m.entrySet().iterator();
	if (m instanceof IntDoubleOrderedMap) {
	    MapEntry e;
	    while (n-- != 0) {
		e = (MapEntry) i.next();
		this.put(e.getIntKey(), e.getDoubleValue());
	    }
	} else {
	    Entry<? extends Integer, ? extends Double> e;
	    while (n-- != 0) {
		e = i.next();
		this.put(e.getKey(), e.getValue());
	    }
	}
    }

    public void putAll(final IntDoubleOrderedMap m) {
	if (this.f <= .5) {
	    this.ensureCapacity(m.size()); // The resulting map will be sized for m.size() elements
	} else {
	    this.tryCapacity(this.size() + m.size()); // The resulting map will be tentatively sized for size() +
						      // m.size()
	}
	// elements
	int n = m.size();
	final EntryIterator i = m.mapEntrySet().iterator();
	MapEntry e;
	while (n-- != 0) {
	    e = i.next();
	    this.put(e.getIntKey(), e.getDoubleValue());
	}
    }

    public void putAll(final int[] k, final double[] v) {
	for (int i = 0, length = Math.min(k.length, v.length); i < length; i++) {
	    this.put(k[i], v[i]);
	}
    }

    private int insert(final int k, final double v) {
	int pos;
	if (k == 0) {
	    if (this.containsNullKey) {
		return this.n;
	    }
	    this.containsNullKey = true;
	    pos = this.n;
	} else {
	    int curr;
	    final int[] key = this.key;
	    // The starting point.
	    if (!((curr = key[pos = HashCommon.mix(k) & this.mask]) == 0)) {
		if (curr == k) {
		    return pos;
		}
		while (!((curr = key[pos = pos + 1 & this.mask]) == 0)) {
		    if (curr == k) {
			return pos;
		    }
		}
	    }
	}
	this.key[pos] = k;
	this.value[pos] = v;
	if (this.size == 0) {
	    this.first = this.last = pos;
	    // Special case of SET_UPPER_LOWER( link[ pos ], -1, -1 );
	    this.link[pos] = -1L;
	} else {
	    this.link[this.last] ^= (this.link[this.last] ^ pos & 0xFFFFFFFFL) & 0xFFFFFFFFL;
	    this.link[pos] = (this.last & 0xFFFFFFFFL) << 32 | 0xFFFFFFFFL;
	    this.last = pos;
	}
	if (this.size++ >= this.maxFill) {
	    this.rehash(IntDoubleOrderedMap.arraySize(this.size + 1, this.f));
	}
	return -1;
    }

    public double put(final int k, final double v) {
	final int pos = this.insert(k, v);
	if (pos < 0) {
	    return this.defRetValue;
	}
	final double oldValue = this.value[pos];
	this.value[pos] = v;
	return oldValue;
    }

    /**
     * {@inheritDoc}
     *
     * @deprecated Please use the corresponding type-specific method instead.
     */
    @Deprecated
    @Override
    public Double put(final Integer ok, final Double ov) {
	final double v = ov;
	final int pos = this.insert(ok, v);
	if (pos < 0) {
	    return null;
	}
	final double oldValue = this.value[pos];
	this.value[pos] = v;
	return oldValue;
    }

    private double addToValue(final int pos, final double incr) {
	final double oldValue = this.value[pos];
	this.value[pos] = oldValue + incr;
	return oldValue;
    }

    /**
     * Adds an increment to value currently associated with a key.
     * <p>
     * <P>
     * Note that this method respects the {@linkplain #defaultReturnValue() default
     * return value} semantics: when called with a key that does not currently
     * appears in the map, the key will be associated with the default return value
     * plus the given increment.
     *
     * @param k    the key.
     * @param incr the increment.
     * @return the old value, or the {@linkplain #defaultReturnValue() default
     *         return value} if no value was present for the given key.
     */
    public double addTo(final int k, final double incr) {
	int pos;
	if (k == 0) {
	    if (this.containsNullKey) {
		return this.addToValue(this.n, incr);
	    }
	    pos = this.n;
	    this.containsNullKey = true;
	} else {
	    int curr;
	    final int[] key = this.key;
	    // The starting point.
	    if (!((curr = key[pos = HashCommon.mix(k) & this.mask]) == 0)) {
		if (curr == k) {
		    return this.addToValue(pos, incr);
		}
		while (!((curr = key[pos = pos + 1 & this.mask]) == 0)) {
		    if (curr == k) {
			return this.addToValue(pos, incr);
		    }
		}
	    }
	}
	this.key[pos] = k;
	this.value[pos] = this.defRetValue + incr;
	if (this.size == 0) {
	    this.first = this.last = pos;
	    // Special case of SET_UPPER_LOWER( link[ pos ], -1, -1 );
	    this.link[pos] = -1L;
	} else {
	    this.link[this.last] ^= (this.link[this.last] ^ pos & 0xFFFFFFFFL) & 0xFFFFFFFFL;
	    this.link[pos] = (this.last & 0xFFFFFFFFL) << 32 | 0xFFFFFFFFL;
	    this.last = pos;
	}
	if (this.size++ >= this.maxFill) {
	    this.rehash(IntDoubleOrderedMap.arraySize(this.size + 1, this.f));
	}
	return this.defRetValue;
    }

    /**
     * Shifts left entries with the specified hash code, starting at the specified
     * position, and empties the resulting free entry.
     *
     * @param pos a starting position.
     */
    protected final void shiftKeys(int pos) {
	// Shift entries with the same hash.
	int last, slot;
	int curr;
	final int[] key = this.key;
	for (;;) {
	    pos = (last = pos) + 1 & this.mask;
	    for (;;) {
		if ((curr = key[pos]) == 0) {
		    key[last] = 0;
		    return;
		}
		slot = HashCommon.mix(curr) & this.mask;
		if (last <= pos ? last >= slot || slot > pos : last >= slot && slot > pos) {
		    break;
		}
		pos = pos + 1 & this.mask;
	    }
	    key[last] = curr;
	    this.value[last] = this.value[pos];
	    this.fixPointers(pos, last);
	}
    }

    public double remove(final int k) {
	if (k == 0) {
	    if (this.containsNullKey) {
		return this.removeNullEntry();
	    }
	    return this.defRetValue;
	}
	int curr;
	final int[] key = this.key;
	int pos;
	// The starting point.
	if ((curr = key[pos = HashCommon.mix(k) & this.mask]) == 0) {
	    return this.defRetValue;
	}
	if (k == curr) {
	    return this.removeEntry(pos);
	}
	while (true) {
	    if ((curr = key[pos = pos + 1 & this.mask]) == 0) {
		return this.defRetValue;
	    }
	    if (k == curr) {
		return this.removeEntry(pos);
	    }
	}
    }

    /**
     * {@inheritDoc}
     *
     * @deprecated Please use the corresponding type-specific method instead.
     */
    @Deprecated
    @Override
    public Double remove(final Object ok) {
	final int k = (Integer) ok;
	if (k == 0) {
	    if (this.containsNullKey) {
		return this.removeNullEntry();
	    }
	    return null;
	}
	int curr;
	final int[] key = this.key;
	int pos;
	// The starting point.
	if ((curr = key[pos = HashCommon.mix(k) & this.mask]) == 0) {
	    return null;
	}
	if (curr == k) {
	    return this.removeEntry(pos);
	}
	while (true) {
	    if ((curr = key[pos = pos + 1 & this.mask]) == 0) {
		return null;
	    }
	    if (curr == k) {
		return this.removeEntry(pos);
	    }
	}
    }

    private double setValue(final int pos, final double v) {
	final double oldValue = this.value[pos];
	this.value[pos] = v;
	return oldValue;
    }

    /**
     * Removes the mapping associated with the first key in iteration order.
     *
     * @return the value previously associated with the first key in iteration
     *         order.
     * @throws NoSuchElementException is this map is empty.
     */
    public double removeFirstDouble() {
	if (this.size == 0) {
	    throw new NoSuchElementException();
	}
	final int pos = this.first;
	// Abbreviated version of fixPointers(pos)
	this.first = (int) this.link[pos];
	if (0 <= this.first) {
	    // Special case of SET_PREV( link[ first ], -1 )
	    this.link[this.first] |= 0xFFFFFFFFL << 32;
	}
	this.size--;
	final double v = this.value[pos];
	if (pos == this.n) {
	    this.containsNullKey = false;
	} else {
	    this.shiftKeys(pos);
	}
	if (this.size < this.maxFill / 4 && this.n > IntDoubleOrderedMap.DEFAULT_INITIAL_SIZE) {
	    this.rehash(this.n / 2);
	}
	return v;
    }

    /**
     * Removes the mapping associated with the last key in iteration order.
     *
     * @return the value previously associated with the last key in iteration order.
     * @throws NoSuchElementException is this map is empty.
     */
    public double removeLastDouble() {
	if (this.size == 0) {
	    throw new NoSuchElementException();
	}
	final int pos = this.last;
	// Abbreviated version of fixPointers(pos)
	this.last = (int) (this.link[pos] >>> 32);
	if (0 <= this.last) {
	    // Special case of SET_NEXT( link[ last ], -1 )
	    this.link[this.last] |= 0xFFFFFFFFL;
	}
	this.size--;
	final double v = this.value[pos];
	if (pos == this.n) {
	    this.containsNullKey = false;
	} else {
	    this.shiftKeys(pos);
	}
	if (this.size < this.maxFill / 4 && this.n > IntDoubleOrderedMap.DEFAULT_INITIAL_SIZE) {
	    this.rehash(this.n / 2);
	}
	return v;
    }

    private void moveIndexToFirst(final int i) {
	if (this.size == 1 || this.first == i) {
	    return;
	}
	if (this.last == i) {
	    this.last = (int) (this.link[i] >>> 32);
	    // Special case of SET_NEXT( link[ last ], -1 );
	    this.link[this.last] |= 0xFFFFFFFFL;
	} else {
	    final long linki = this.link[i];
	    final int prev = (int) (linki >>> 32);
	    final int next = (int) linki;
	    this.link[prev] ^= (this.link[prev] ^ linki & 0xFFFFFFFFL) & 0xFFFFFFFFL;
	    this.link[next] ^= (this.link[next] ^ linki & 0xFFFFFFFF00000000L) & 0xFFFFFFFF00000000L;
	}
	this.link[this.first] ^= (this.link[this.first] ^ (i & 0xFFFFFFFFL) << 32) & 0xFFFFFFFF00000000L;
	this.link[i] = 0xFFFFFFFFL << 32 | this.first & 0xFFFFFFFFL;
	this.first = i;
    }

    private void moveIndexToLast(final int i) {
	if (this.size == 1 || this.last == i) {
	    return;
	}
	if (this.first == i) {
	    this.first = (int) this.link[i];
	    // Special case of SET_PREV( link[ first ], -1 );
	    this.link[this.first] |= 0xFFFFFFFFL << 32;
	} else {
	    final long linki = this.link[i];
	    final int prev = (int) (linki >>> 32);
	    final int next = (int) linki;
	    this.link[prev] ^= (this.link[prev] ^ linki & 0xFFFFFFFFL) & 0xFFFFFFFFL;
	    this.link[next] ^= (this.link[next] ^ linki & 0xFFFFFFFF00000000L) & 0xFFFFFFFF00000000L;
	}
	this.link[this.last] ^= (this.link[this.last] ^ i & 0xFFFFFFFFL) & 0xFFFFFFFFL;
	this.link[i] = (this.last & 0xFFFFFFFFL) << 32 | 0xFFFFFFFFL;
	this.last = i;
    }

    /**
     * Returns the value to which the given key is mapped; if the key is present, it
     * is moved to the first position of the iteration order.
     *
     * @param k the key.
     * @return the corresponding value, or the {@linkplain #defaultReturnValue()
     *         default return value} if no value was present for the given key.
     */
    public double getAndMoveToFirst(final int k) {
	if (k == 0) {
	    if (this.containsNullKey) {
		this.moveIndexToFirst(this.n);
		return this.value[this.n];
	    }
	    return this.defRetValue;
	}
	int curr;
	final int[] key = this.key;
	int pos;
	// The starting point.
	if ((curr = key[pos = HashCommon.mix(k) & this.mask]) == 0) {
	    return this.defRetValue;
	}
	if (k == curr) {
	    this.moveIndexToFirst(pos);
	    return this.value[pos];
	}
	// There's always an unused entry.
	while (true) {
	    if ((curr = key[pos = pos + 1 & this.mask]) == 0) {
		return this.defRetValue;
	    }
	    if (k == curr) {
		this.moveIndexToFirst(pos);
		return this.value[pos];
	    }
	}
    }

    /**
     * Returns the value to which the given key is mapped; if the key is present, it
     * is moved to the last position of the iteration order.
     *
     * @param k the key.
     * @return the corresponding value, or the {@linkplain #defaultReturnValue()
     *         default return value} if no value was present for the given key.
     */
    public double getAndMoveToLast(final int k) {
	if (k == 0) {
	    if (this.containsNullKey) {
		this.moveIndexToLast(this.n);
		return this.value[this.n];
	    }
	    return this.defRetValue;
	}
	int curr;
	final int[] key = this.key;
	int pos;
	// The starting point.
	if ((curr = key[pos = HashCommon.mix(k) & this.mask]) == 0) {
	    return this.defRetValue;
	}
	if (k == curr) {
	    this.moveIndexToLast(pos);
	    return this.value[pos];
	}
	// There's always an unused entry.
	while (true) {
	    if ((curr = key[pos = pos + 1 & this.mask]) == 0) {
		return this.defRetValue;
	    }
	    if (k == curr) {
		this.moveIndexToLast(pos);
		return this.value[pos];
	    }
	}
    }

    /**
     * Adds a pair to the map; if the key is already present, it is moved to the
     * first position of the iteration order.
     *
     * @param k the key.
     * @param v the value.
     * @return the old value, or the {@linkplain #defaultReturnValue() default
     *         return value} if no value was present for the given key.
     */
    public double putAndMoveToFirst(final int k, final double v) {
	int pos;
	if (k == 0) {
	    if (this.containsNullKey) {
		this.moveIndexToFirst(this.n);
		return this.setValue(this.n, v);
	    }
	    this.containsNullKey = true;
	    pos = this.n;
	} else {
	    int curr;
	    final int[] key = this.key;
	    // The starting point.
	    if (!((curr = key[pos = HashCommon.mix(k) & this.mask]) == 0)) {
		if (curr == k) {
		    this.moveIndexToFirst(pos);
		    return this.setValue(pos, v);
		}
		while (!((curr = key[pos = pos + 1 & this.mask]) == 0)) {
		    if (curr == k) {
			this.moveIndexToFirst(pos);
			return this.setValue(pos, v);
		    }
		}
	    }
	}
	this.key[pos] = k;
	this.value[pos] = v;
	if (this.size == 0) {
	    this.first = this.last = pos;
	    // Special case of SET_UPPER_LOWER( link[ pos ], -1, -1 );
	    this.link[pos] = -1L;
	} else {
	    this.link[this.first] ^= (this.link[this.first] ^ (pos & 0xFFFFFFFFL) << 32) & 0xFFFFFFFF00000000L;
	    this.link[pos] = 0xFFFFFFFFL << 32 | this.first & 0xFFFFFFFFL;
	    this.first = pos;
	}
	if (this.size++ >= this.maxFill) {
	    this.rehash(IntDoubleOrderedMap.arraySize(this.size, this.f));
	}
	return this.defRetValue;
    }

    /**
     * Adds a pair to the map; if the key is already present, it is moved to the
     * last position of the iteration order.
     *
     * @param k the key.
     * @param v the value.
     * @return the old value, or the {@linkplain #defaultReturnValue() default
     *         return value} if no value was present for the given key.
     */
    public double putAndMoveToLast(final int k, final double v) {
	int pos;
	if (k == 0) {
	    if (this.containsNullKey) {
		this.moveIndexToLast(this.n);
		return this.setValue(this.n, v);
	    }
	    this.containsNullKey = true;
	    pos = this.n;
	} else {
	    int curr;
	    final int[] key = this.key;
	    // The starting point.
	    if (!((curr = key[pos = HashCommon.mix(k) & this.mask]) == 0)) {
		if (curr == k) {
		    this.moveIndexToLast(pos);
		    return this.setValue(pos, v);
		}
		while (!((curr = key[pos = pos + 1 & this.mask]) == 0)) {
		    if (curr == k) {
			this.moveIndexToLast(pos);
			return this.setValue(pos, v);
		    }
		}
	    }
	}
	this.key[pos] = k;
	this.value[pos] = v;
	if (this.size == 0) {
	    this.first = this.last = pos;
	    // Special case of SET_UPPER_LOWER( link[ pos ], -1, -1 );
	    this.link[pos] = -1L;
	} else {
	    this.link[this.last] ^= (this.link[this.last] ^ pos & 0xFFFFFFFFL) & 0xFFFFFFFFL;
	    this.link[pos] = (this.last & 0xFFFFFFFFL) << 32 | 0xFFFFFFFFL;
	    this.last = pos;
	}
	if (this.size++ >= this.maxFill) {
	    this.rehash(IntDoubleOrderedMap.arraySize(this.size, this.f));
	}
	return this.defRetValue;
    }

    public Double get(final Integer ok) {
	final int k = ok;
	if (k == 0) {
	    return this.containsNullKey ? this.value[this.n] : null;
	}
	int curr;
	final int[] key = this.key;
	int pos;
	// The starting point.
	if ((curr = key[pos = HashCommon.mix(k) & this.mask]) == 0) {
	    return null;
	}
	if (k == curr) {
	    return this.value[pos];
	}
	// There's always an unused entry.
	while (true) {
	    if ((curr = key[pos = pos + 1 & this.mask]) == 0) {
		return null;
	    }
	    if (k == curr) {
		return this.value[pos];
	    }
	}
    }

    public double get(final int k) {
	if (k == 0) {
	    return this.containsNullKey ? this.value[this.n] : this.defRetValue;
	}
	int curr;
	final int[] key = this.key;
	int pos;
	// The starting point.
	if ((curr = key[pos = HashCommon.mix(k) & this.mask]) == 0) {
	    return this.defRetValue;
	}
	if (k == curr) {
	    return this.value[pos];
	}
	// There's always an unused entry.
	while (true) {
	    if ((curr = key[pos = pos + 1 & this.mask]) == 0) {
		return this.defRetValue;
	    }
	    if (k == curr) {
		return this.value[pos];
	    }
	}
    }

    public boolean containsKey(final int k) {
	if (k == 0) {
	    return this.containsNullKey;
	}
	int curr;
	final int[] key = this.key;
	int pos;
	// The starting point.
	if ((curr = key[pos = HashCommon.mix(k) & this.mask]) == 0) {
	    return false;
	}
	if (k == curr) {
	    return true;
	}
	// There's always an unused entry.
	while (true) {
	    if ((curr = key[pos = pos + 1 & this.mask]) == 0) {
		return false;
	    }
	    if (k == curr) {
		return true;
	    }
	}
    }

    public boolean containsValue(final double v) {
	final double value[] = this.value;
	final int key[] = this.key;
	if (this.containsNullKey && value[this.n] == v) {
	    return true;
	}
	for (int i = this.n; i-- != 0;) {
	    if (!(key[i] == 0) && value[i] == v) {
		return true;
	    }
	}
	return false;
    }

    /*
     * Removes all elements from this map.
     *
     * <P>To increase object reuse, this method does not change the table size. If
     * you want to reduce the table size, you must use {@link #trim()}.
     */
    @Override
    public void clear() {
	if (this.size == 0) {
	    return;
	}
	this.size = 0;
	this.containsNullKey = false;
	Arrays.fill(this.key, 0);
	this.first = this.last = -1;
    }

    @Override
    public int size() {
	return this.size;
    }

    @Override
    public boolean isEmpty() {
	return this.size == 0;
    }

    /**
     * A no-op for backward compatibility.
     *
     * @param growthFactor unused.
     * @deprecated Since <code>fastutil</code> 6.1.0, hash tables are doubled when
     *             they are too full.
     */
    @Deprecated
    public void growthFactor(final int growthFactor) {
    }

    /**
     * Gets the growth factor (2).
     *
     * @return the growth factor of this set, which is fixed (2).
     * @see #growthFactor(int)
     * @deprecated Since <code>fastutil</code> 6.1.0, hash tables are doubled when
     *             they are too full.
     */
    @Deprecated
    public int growthFactor() {
	return 16;
    }

    /**
     * The entry class for a hash map does not record key and value, but rather the
     * position in the hash table of the corresponding entry. This is necessary so
     * that calls to {@link java.util.Map.Entry#setValue(Object)} are reflected in
     * the map
     */
    public final class MapEntry implements Entry<Integer, Double> {
	// The table index this entry refers to, or -1 if this entry has been deleted.
	int index;

	MapEntry(final int index) {
	    this.index = index;
	}

	MapEntry() {
	}

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated Please use the corresponding type-specific method instead.
	 */
	@Override
	@Deprecated
	public Integer getKey() {
	    return IntDoubleOrderedMap.this.key[this.index];
	}

	public int getIntKey() {
	    return IntDoubleOrderedMap.this.key[this.index];
	}

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated Please use the corresponding type-specific method instead.
	 */
	@Override
	@Deprecated
	public Double getValue() {
	    return IntDoubleOrderedMap.this.value[this.index];
	}

	public double getDoubleValue() {
	    return IntDoubleOrderedMap.this.value[this.index];
	}

	public double setValue(final double v) {
	    final double oldValue = IntDoubleOrderedMap.this.value[this.index];
	    IntDoubleOrderedMap.this.value[this.index] = v;
	    return oldValue;
	}

	@Override
	public Double setValue(final Double v) {
	    return this.setValue(v.doubleValue());
	}

	@Override
	@SuppressWarnings("unchecked")
	public boolean equals(final Object o) {
	    if (!(o instanceof Entry)) {
		return false;
	    }
	    final Entry<Integer, Double> e = (Entry<Integer, Double>) o;
	    return IntDoubleOrderedMap.this.key[this.index] == e.getKey()
		    && IntDoubleOrderedMap.this.value[this.index] == e.getValue();
	}

	@Override
	public int hashCode() {
	    return IntDoubleOrderedMap.this.key[this.index]
		    ^ NumberTools.doubleToMixedIntBits(IntDoubleOrderedMap.this.value[this.index]);
	}

	@Override
	public String toString() {
	    return IntDoubleOrderedMap.this.key[this.index] + "=>" + IntDoubleOrderedMap.this.value[this.index];
	}
    }

    /**
     * Modifies the {@link #link} vector so that the given entry is removed. This
     * method will complete in constant time.
     *
     * @param i the index of an entry.
     */
    protected void fixPointers(final int i) {
	if (this.size == 0) {
	    this.first = this.last = -1;
	    return;
	}
	if (this.first == i) {
	    this.first = (int) this.link[i];
	    if (0 <= this.first) {
		// Special case of SET_PREV( link[ first ], -1 )
		this.link[this.first] |= 0xFFFFFFFFL << 32;
	    }
	    return;
	}
	if (this.last == i) {
	    this.last = (int) (this.link[i] >>> 32);
	    if (0 <= this.last) {
		// Special case of SET_NEXT( link[ last ], -1 )
		this.link[this.last] |= 0xFFFFFFFFL;
	    }
	    return;
	}
	final long linki = this.link[i];
	final int prev = (int) (linki >>> 32);
	final int next = (int) linki;
	this.link[prev] ^= (this.link[prev] ^ linki & 0xFFFFFFFFL) & 0xFFFFFFFFL;
	this.link[next] ^= (this.link[next] ^ linki & 0xFFFFFFFF00000000L) & 0xFFFFFFFF00000000L;
    }

    /**
     * Modifies the {@link #link} vector for a shift from s to d.
     * <P>
     * This method will complete in constant time.
     *
     * @param s the source position.
     * @param d the destination position.
     */
    protected void fixPointers(final int s, final int d) {
	if (this.size == 1) {
	    this.first = this.last = d;
	    // Special case of SET_UPPER_LOWER( link[ d ], -1, -1 )
	    this.link[d] = -1L;
	    return;
	}
	if (this.first == s) {
	    this.first = d;
	    this.link[(int) this.link[s]] ^= (this.link[(int) this.link[s]] ^ (d & 0xFFFFFFFFL) << 32)
		    & 0xFFFFFFFF00000000L;
	    this.link[d] = this.link[s];
	    return;
	}
	if (this.last == s) {
	    this.last = d;
	    this.link[(int) (this.link[s] >>> 32)] ^= (this.link[(int) (this.link[s] >>> 32)] ^ d & 0xFFFFFFFFL)
		    & 0xFFFFFFFFL;
	    this.link[d] = this.link[s];
	    return;
	}
	final long links = this.link[s];
	final int prev = (int) (links >>> 32);
	final int next = (int) links;
	this.link[prev] ^= (this.link[prev] ^ d & 0xFFFFFFFFL) & 0xFFFFFFFFL;
	this.link[next] ^= (this.link[next] ^ (d & 0xFFFFFFFFL) << 32) & 0xFFFFFFFF00000000L;
	this.link[d] = links;
    }

    /**
     * Returns the first key of this map in iteration order.
     *
     * @return the first key in iteration order.
     */
    public int firstIntKey() {
	if (this.size == 0) {
	    throw new NoSuchElementException();
	}
	return this.key[this.first];
    }

    /**
     * Returns the last key of this map in iteration order.
     *
     * @return the last key in iteration order.
     */
    public int lastIntKey() {
	if (this.size == 0) {
	    throw new NoSuchElementException();
	}
	return this.key[this.last];
    }

    @Override
    public Comparator<Integer> comparator() {
	return null;
    }

    public IntDoubleOrderedMap tailMap(final int from) {
	throw new UnsupportedOperationException();
    }

    public IntDoubleOrderedMap headMap(final int to) {
	throw new UnsupportedOperationException();
    }

    public IntDoubleOrderedMap subMap(final int from, final int to) {
	throw new UnsupportedOperationException();
    }

    @Override
    public IntDoubleOrderedMap tailMap(final Integer from) {
	throw new UnsupportedOperationException();
    }

    @Override
    public IntDoubleOrderedMap headMap(final Integer to) {
	throw new UnsupportedOperationException();
    }

    @Override
    public IntDoubleOrderedMap subMap(final Integer from, final Integer to) {
	throw new UnsupportedOperationException();
    }

    /**
     * A list iterator over a linked map.
     * <p>
     * <P>
     * This class provides a list iterator over a linked hash map. The constructor
     * runs in constant time.
     */
    private class MapIterator {
	/**
	 * The entry that will be returned by the next call to
	 * {@link java.util.ListIterator#previous()} (or <code>null</code> if no
	 * previous entry exists).
	 */
	int prev = -1;
	/**
	 * The entry that will be returned by the next call to
	 * {@link java.util.ListIterator#next()} (or <code>null</code> if no next entry
	 * exists).
	 */
	int next = -1;
	/**
	 * The last entry that was returned (or -1 if we did not iterate or used
	 * {@link java.util.Iterator#remove()}).
	 */
	int curr = -1;
	/**
	 * The current index (in the sense of a {@link java.util.ListIterator}). Note
	 * that this value is not meaningful when this iterator has been created using
	 * the nonempty constructor.
	 */
	int index = -1;

	private MapIterator() {
	    this.next = IntDoubleOrderedMap.this.first;
	    this.index = 0;
	}

	private MapIterator(final int from) {
	    if (from == 0) {
		if (IntDoubleOrderedMap.this.containsNullKey) {
		    this.next = (int) IntDoubleOrderedMap.this.link[IntDoubleOrderedMap.this.n];
		    this.prev = IntDoubleOrderedMap.this.n;
		    return;
		} else {
		    throw new NoSuchElementException("The key " + from + " does not belong to this map.");
		}
	    }
	    if (IntDoubleOrderedMap.this.key[IntDoubleOrderedMap.this.last] == from) {
		this.prev = IntDoubleOrderedMap.this.last;
		this.index = IntDoubleOrderedMap.this.size;
		return;
	    }
	    // The starting point.
	    int pos = HashCommon.mix(from) & IntDoubleOrderedMap.this.mask;
	    // There's always an unused entry.
	    while (!(IntDoubleOrderedMap.this.key[pos] == 0)) {
		if (IntDoubleOrderedMap.this.key[pos] == from) {
		    // Note: no valid index known.
		    this.next = (int) IntDoubleOrderedMap.this.link[pos];
		    this.prev = pos;
		    return;
		}
		pos = pos + 1 & IntDoubleOrderedMap.this.mask;
	    }
	    throw new NoSuchElementException("The key " + from + " does not belong to this map.");
	}

	public boolean hasNext() {
	    return this.next != -1;
	}

	public boolean hasPrevious() {
	    return this.prev != -1;
	}

	private final void ensureIndexKnown() {
	    if (this.index >= 0) {
		return;
	    }
	    if (this.prev == -1) {
		this.index = 0;
		return;
	    }
	    if (this.next == -1) {
		this.index = IntDoubleOrderedMap.this.size;
		return;
	    }
	    int pos = IntDoubleOrderedMap.this.first;
	    this.index = 1;
	    while (pos != this.prev) {
		pos = (int) IntDoubleOrderedMap.this.link[pos];
		this.index++;
	    }
	}

	public int nextIndex() {
	    this.ensureIndexKnown();
	    return this.index;
	}

	public int previousIndex() {
	    this.ensureIndexKnown();
	    return this.index - 1;
	}

	public int nextEntry() {
	    if (!this.hasNext()) {
		throw new NoSuchElementException();
	    }
	    this.curr = this.next;
	    this.next = (int) IntDoubleOrderedMap.this.link[this.curr];
	    this.prev = this.curr;
	    if (this.index >= 0) {
		this.index++;
	    }
	    return this.curr;
	}

	public int previousEntry() {
	    if (!this.hasPrevious()) {
		throw new NoSuchElementException();
	    }
	    this.curr = this.prev;
	    this.prev = (int) (IntDoubleOrderedMap.this.link[this.curr] >>> 32);
	    this.next = this.curr;
	    if (this.index >= 0) {
		this.index--;
	    }
	    return this.curr;
	}

	public void remove() {
	    this.ensureIndexKnown();
	    if (this.curr == -1) {
		throw new IllegalStateException();
	    }
	    if (this.curr == this.prev) {
		/*
		 * If the last operation was a next(), we are removing an entry that preceeds
		 * the current index, and thus we must decrement it.
		 */
		this.index--;
		this.prev = (int) (IntDoubleOrderedMap.this.link[this.curr] >>> 32);
	    } else {
		this.next = (int) IntDoubleOrderedMap.this.link[this.curr];
	    }
	    IntDoubleOrderedMap.this.size--;
	    /*
	     * Now we manually fix the pointers. Because of our knowledge of next and prev,
	     * this is going to be faster than calling fixPointers().
	     */
	    if (this.prev == -1) {
		IntDoubleOrderedMap.this.first = this.next;
	    } else {
		IntDoubleOrderedMap.this.link[this.prev] ^= (IntDoubleOrderedMap.this.link[this.prev]
			^ this.next & 0xFFFFFFFFL) & 0xFFFFFFFFL;
	    }
	    if (this.next == -1) {
		IntDoubleOrderedMap.this.last = this.prev;
	    } else {
		IntDoubleOrderedMap.this.link[this.next] ^= (IntDoubleOrderedMap.this.link[this.next]
			^ (this.prev & 0xFFFFFFFFL) << 32) & 0xFFFFFFFF00000000L;
	    }
	    int last, slot, pos = this.curr;
	    this.curr = -1;
	    if (pos == IntDoubleOrderedMap.this.n) {
		IntDoubleOrderedMap.this.containsNullKey = false;
	    } else {
		int curr;
		final int[] key = IntDoubleOrderedMap.this.key;
		// We have to horribly duplicate the shiftKeys() code because we need to update
		// next/prev.
		for (;;) {
		    pos = (last = pos) + 1 & IntDoubleOrderedMap.this.mask;
		    for (;;) {
			if ((curr = key[pos]) == 0) {
			    key[last] = 0;
			    return;
			}
			slot = HashCommon.mix(curr) & IntDoubleOrderedMap.this.mask;
			if (last <= pos ? last >= slot || slot > pos : last >= slot && slot > pos) {
			    break;
			}
			pos = pos + 1 & IntDoubleOrderedMap.this.mask;
		    }
		    key[last] = curr;
		    IntDoubleOrderedMap.this.value[last] = IntDoubleOrderedMap.this.value[pos];
		    if (this.next == pos) {
			this.next = last;
		    }
		    if (this.prev == pos) {
			this.prev = last;
		    }
		    IntDoubleOrderedMap.this.fixPointers(pos, last);
		}
	    }
	}

	public int skip(final int n) {
	    int i = n;
	    while (i-- != 0 && this.hasNext()) {
		this.nextEntry();
	    }
	    return n - i - 1;
	}

	public int back(final int n) {
	    int i = n;
	    while (i-- != 0 && this.hasPrevious()) {
		this.previousEntry();
	    }
	    return n - i - 1;
	}
    }

    public class EntryIterator extends MapIterator implements Iterator<MapEntry> {
	private MapEntry entry;

	public EntryIterator() {
	}

	public EntryIterator(final int from) {
	    super(from);
	}

	@Override
	public MapEntry next() {
	    return this.entry = new MapEntry(this.nextEntry());
	}

	public MapEntry previous() {
	    return this.entry = new MapEntry(this.previousEntry());
	}

	@Override
	public void remove() {
	    super.remove();
	    this.entry.index = -1; // You cannot use a deleted entry.
	}

	public void set(final MapEntry ok) {
	    throw new UnsupportedOperationException();
	}

	public void add(final MapEntry ok) {
	    throw new UnsupportedOperationException();
	}
    }

    public class FastEntryIterator extends MapIterator implements ListIterator<MapEntry> {
	final MapEntry entry = new MapEntry();

	public FastEntryIterator() {
	}

	public FastEntryIterator(final int from) {
	    super(from);
	}

	@Override
	public MapEntry next() {
	    this.entry.index = this.nextEntry();
	    return this.entry;
	}

	@Override
	public MapEntry previous() {
	    this.entry.index = this.previousEntry();
	    return this.entry;
	}

	@Override
	public void set(final MapEntry ok) {
	    throw new UnsupportedOperationException();
	}

	@Override
	public void add(final MapEntry ok) {
	    throw new UnsupportedOperationException();
	}
    }

    public final class MapEntrySet implements Cloneable, SortedSet<MapEntry>, Set<MapEntry>, Collection<MapEntry> {
	@Override
	public EntryIterator iterator() {
	    return new EntryIterator();
	}

	@Override
	public Comparator<? super MapEntry> comparator() {
	    return null;
	}

	@Override
	public MapEntrySet subSet(final MapEntry fromElement, final MapEntry toElement) {
	    throw new UnsupportedOperationException();
	}

	@Override
	public MapEntrySet headSet(final MapEntry toElement) {
	    throw new UnsupportedOperationException();
	}

	@Override
	public MapEntrySet tailSet(final MapEntry fromElement) {
	    throw new UnsupportedOperationException();
	}

	@Override
	public MapEntry first() {
	    if (IntDoubleOrderedMap.this.size == 0) {
		throw new NoSuchElementException();
	    }
	    return new MapEntry(IntDoubleOrderedMap.this.first);
	}

	@Override
	public MapEntry last() {
	    if (IntDoubleOrderedMap.this.size == 0) {
		throw new NoSuchElementException();
	    }
	    return new MapEntry(IntDoubleOrderedMap.this.last);
	}

	@Override
	@SuppressWarnings("unchecked")
	public boolean contains(final Object o) {
	    if (!(o instanceof Entry)) {
		return false;
	    }
	    final Entry<Integer, Double> e = (Entry<Integer, Double>) o;
	    final int k = e.getKey();
	    if (k == 0) {
		return IntDoubleOrderedMap.this.containsNullKey
			&& IntDoubleOrderedMap.this.value[IntDoubleOrderedMap.this.n] == e.getValue();
	    }
	    int curr;
	    final int[] key = IntDoubleOrderedMap.this.key;
	    int pos;
	    // The starting point.
	    if ((curr = key[pos = HashCommon.mix(k) & IntDoubleOrderedMap.this.mask]) == 0) {
		return false;
	    }
	    if (k == curr) {
		return IntDoubleOrderedMap.this.value[pos] == e.getValue();
	    }
	    // There's always an unused entry.
	    while (true) {
		if ((curr = key[pos = pos + 1 & IntDoubleOrderedMap.this.mask]) == 0) {
		    return false;
		}
		if (k == curr) {
		    return IntDoubleOrderedMap.this.value[pos] == e.getValue();
		}
	    }
	}

	@Override
	@SuppressWarnings("unchecked")
	public boolean remove(final Object o) {
	    if (!(o instanceof Entry)) {
		return false;
	    }
	    final Entry<Integer, Double> e = (Entry<Integer, Double>) o;
	    final int k = e.getKey();
	    final double v = e.getValue();
	    if (k == 0) {
		if (IntDoubleOrderedMap.this.containsNullKey
			&& IntDoubleOrderedMap.this.value[IntDoubleOrderedMap.this.n] == v) {
		    IntDoubleOrderedMap.this.removeNullEntry();
		    return true;
		}
		return false;
	    }
	    int curr;
	    final int[] key = IntDoubleOrderedMap.this.key;
	    int pos;
	    // The starting point.
	    if ((curr = key[pos = HashCommon.mix(k) & IntDoubleOrderedMap.this.mask]) == 0) {
		return false;
	    }
	    if (curr == k) {
		if (IntDoubleOrderedMap.this.value[pos] == v) {
		    IntDoubleOrderedMap.this.removeEntry(pos);
		    return true;
		}
		return false;
	    }
	    while (true) {
		if ((curr = key[pos = pos + 1 & IntDoubleOrderedMap.this.mask]) == 0) {
		    return false;
		}
		if (curr == k) {
		    if (IntDoubleOrderedMap.this.value[pos] == v) {
			IntDoubleOrderedMap.this.removeEntry(pos);
			return true;
		    }
		}
	    }
	}

	@Override
	public int size() {
	    return IntDoubleOrderedMap.this.size;
	}

	@Override
	public void clear() {
	    IntDoubleOrderedMap.this.clear();
	}

	public EntryIterator iterator(final MapEntry from) {
	    return new EntryIterator(from.getIntKey());
	}

	@Override
	public boolean equals(final Object o) {
	    if (o == this) {
		return true;
	    }
	    if (!(o instanceof Set)) {
		return false;
	    }
	    final Set<?> s = (Set<?>) o;
	    if (s.size() != this.size()) {
		return false;
	    }
	    return this.containsAll(s);
	}

	/**
	 * Returns a hash code for this set.
	 * <p>
	 * The hash code of a set is computed by summing the hash codes of its elements.
	 *
	 * @return a hash code for this set.
	 */
	@Override
	public int hashCode() {
	    int h = 0, n = this.size();
	    final EntryIterator i = this.iterator();
	    MapEntry k;
	    while (n-- != 0) {
		k = i.next(); // We need k because KEY2JAVAHASH() is a macro with repeated evaluation.
		h += k == null ? 0 : k.hashCode();
	    }
	    return h;
	}

	public EntryIterator fastIterator() {
	    return new EntryIterator();
	}

	public EntryIterator fastIterator(final MapEntry from) {
	    return new EntryIterator(from.getIntKey());
	}

	@Override
	public Object[] toArray() {
	    final Object[] a = new Object[this.size()];
	    IntDoubleOrderedMap.objectUnwrap(this.iterator(), a);
	    return a;
	}

	@Override
	@SuppressWarnings("unchecked")
	public <T> T[] toArray(T[] a) {
	    final int size = this.size();
	    if (a.length < size) {
		a = (T[]) new MapEntry[size];
	    }
	    IntDoubleOrderedMap.objectUnwrap(this.iterator(), a);
	    if (size < a.length) {
		a[size] = null;
	    }
	    return a;
	}

	/**
	 * Unsupported.
	 *
	 * @param c ignored
	 * @return nothing, throws UnsupportedOperationException
	 * @throws UnsupportedOperationException always
	 */
	@Override
	public boolean addAll(final Collection<? extends MapEntry> c) {
	    throw new UnsupportedOperationException("addAll not supported");
	}

	/**
	 * Unsupported.
	 *
	 * @param k ignored
	 * @return nothing, throws UnsupportedOperationException
	 * @throws UnsupportedOperationException always
	 */
	@Override
	public boolean add(final MapEntry k) {
	    throw new UnsupportedOperationException("add not supported");
	}

	/**
	 * Checks whether this collection contains all elements from the given
	 * collection.
	 *
	 * @param c a collection.
	 * @return <code>true</code> if this collection contains all elements of the
	 *         argument.
	 */
	@Override
	public boolean containsAll(final Collection<?> c) {
	    int n = c.size();
	    final Iterator<?> i = c.iterator();
	    while (n-- != 0) {
		if (!this.contains(i.next())) {
		    return false;
		}
	    }
	    return true;
	}

	/**
	 * Retains in this collection only elements from the given collection.
	 *
	 * @param c a collection.
	 * @return <code>true</code> if this collection changed as a result of the call.
	 */
	@Override
	public boolean retainAll(final Collection<?> c) {
	    boolean retVal = false;
	    int n = this.size();
	    final Iterator<?> i = this.iterator();
	    while (n-- != 0) {
		if (!c.contains(i.next())) {
		    i.remove();
		    retVal = true;
		}
	    }
	    return retVal;
	}

	/**
	 * Remove from this collection all elements in the given collection. If the
	 * collection is an instance of this class, it uses faster iterators.
	 *
	 * @param c a collection.
	 * @return <code>true</code> if this collection changed as a result of the call.
	 */
	@Override
	public boolean removeAll(final Collection<?> c) {
	    boolean retVal = false;
	    int n = c.size();
	    final Iterator<?> i = c.iterator();
	    while (n-- != 0) {
		if (this.remove(i.next())) {
		    retVal = true;
		}
	    }
	    return retVal;
	}

	@Override
	public boolean isEmpty() {
	    return this.size() == 0;
	}

	@Override
	public String toString() {
	    final StringBuilder s = new StringBuilder();
	    final EntryIterator i = this.iterator();
	    int n = this.size();
	    Object k;
	    boolean first = true;
	    s.append("{");
	    while (n-- != 0) {
		if (first) {
		    first = false;
		} else {
		    s.append(", ");
		}
		k = i.next();
		if (this == k) {
		    s.append("(this collection)");
		} else {
		    s.append(String.valueOf(k));
		}
	    }
	    s.append("}");
	    return s.toString();
	}

	public Set<Entry<Integer, Double>> toBoxed() {
	    return new OrderedSet<>(this);
	}
    }

    /**
     * THIS ONE IS BAD; it copies the entry set to allow it to be considered a Set
     * of Map.Entry with the right (boxed) key and value types. Prefer
     * {@code mapEntrySet()}!!!
     *
     * @return a Set of Map.Entry with Integer keys and Double values
     * @see IntDoubleOrderedMap#mapEntrySet strongly preferred variant that allows
     *      primitive access
     * @deprecated prefer {@link IntDoubleOrderedMap#mapEntrySet}
     */
    @Override
    public Set<Entry<Integer, Double>> entrySet() {
	if (this.entries == null) {
	    this.entries = new MapEntrySet();
	}
	return this.entries.toBoxed();
    }

    public MapEntrySet mapEntrySet() {
	if (this.entries == null) {
	    this.entries = new MapEntrySet();
	}
	return this.entries;
    }

    /**
     * An iterator on keys.
     * <p>
     * <P>
     * We simply override the
     * {@link java.util.ListIterator#next()}/{@link java.util.ListIterator#previous()}
     * methods (and possibly their type-specific counterparts) so that they return
     * keys instead of entries.
     */
    public final class KeyIterator extends MapIterator implements Iterator<Integer> {
	public KeyIterator(final int k) {
	    super(k);
	}

	public int previousInt() {
	    return IntDoubleOrderedMap.this.key[this.previousEntry()];
	}

	public void set(final int k) {
	    throw new UnsupportedOperationException();
	}

	public void add(final int k) {
	    throw new UnsupportedOperationException();
	}

	public Integer previous() {
	    return IntDoubleOrderedMap.this.key[this.previousEntry()];
	}

	public void set(final Integer ok) {
	    throw new UnsupportedOperationException();
	}

	public void add(final Integer ok) {
	    throw new UnsupportedOperationException();
	}

	public KeyIterator() {
	    super();
	}

	public int nextInt() {
	    return IntDoubleOrderedMap.this.key[this.nextEntry()];
	}

	@Override
	public Integer next() {
	    return IntDoubleOrderedMap.this.key[this.nextEntry()];
	}
    }

    public final class KeySet implements SortedSet<Integer> {
	public KeyIterator iterator(final int from) {
	    return new KeyIterator(from);
	}

	@Override
	public KeyIterator iterator() {
	    return new KeyIterator();
	}

	@Override
	public int size() {
	    return IntDoubleOrderedMap.this.size;
	}

	public boolean contains(final int k) {
	    return IntDoubleOrderedMap.this.containsKey(k);
	}

	public boolean remove(final int k) {
	    final int oldSize = IntDoubleOrderedMap.this.size;
	    IntDoubleOrderedMap.this.remove(k);
	    return IntDoubleOrderedMap.this.size != oldSize;
	}

	public boolean remove(final Integer k) {
	    final int oldSize = IntDoubleOrderedMap.this.size;
	    IntDoubleOrderedMap.this.remove(k);
	    return IntDoubleOrderedMap.this.size != oldSize;
	}

	@Override
	public void clear() {
	    IntDoubleOrderedMap.this.clear();
	}

	public int firstInt() {
	    if (IntDoubleOrderedMap.this.size == 0) {
		throw new NoSuchElementException();
	    }
	    return IntDoubleOrderedMap.this.key[IntDoubleOrderedMap.this.first];
	}

	public int lastInt() {
	    if (IntDoubleOrderedMap.this.size == 0) {
		throw new NoSuchElementException();
	    }
	    return IntDoubleOrderedMap.this.key[IntDoubleOrderedMap.this.last];
	}

	@Override
	public Comparator<Integer> comparator() {
	    return null;
	}

	@Override
	public SortedSet<Integer> tailSet(final Integer from) {
	    throw new UnsupportedOperationException();
	}

	@Override
	public SortedSet<Integer> headSet(final Integer to) {
	    throw new UnsupportedOperationException();
	}

	@Override
	public SortedSet<Integer> subSet(final Integer from, final Integer to) {
	    throw new UnsupportedOperationException();
	}

	/**
	 * Delegates to the corresponding type-specific method.
	 *
	 * @deprecated Please use the corresponding type-specific method instead.
	 */
	@Override
	@Deprecated
	public Integer first() {
	    return this.firstInt();
	}

	/**
	 * Delegates to the corresponding type-specific method.
	 *
	 * @deprecated Please use the corresponding type-specific method instead.
	 */
	@Override
	@Deprecated
	public Integer last() {
	    return this.lastInt();
	}

	public int[] toArray(final int a[]) {
	    return this.toIntArray(a);
	}

	public int[] toIntArray() {
	    return this.toIntArray(null);
	}

	public int[] toIntArray(int a[]) {
	    if (a == null || a.length < this.size()) {
		a = new int[this.size()];
	    }
	    this.unwrap(this.iterator(), a);
	    return a;
	}

	/**
	 * Delegates to the type-specific <code>rem()</code> method.
	 */
	@Override
	public boolean remove(final Object ok) {
	    return this.rem(ok);
	}

	/**
	 * Delegates to the corresponding type-specific method.
	 */
	@Override
	public boolean add(final Integer o) {
	    return this.add(o.intValue());
	}

	/**
	 * Delegates to the corresponding type-specific method.
	 */
	public boolean rem(final Object o) {
	    return this.rem(o);
	}

	/**
	 * Delegates to the corresponding type-specific method.
	 */
	@Override
	public boolean contains(final Object o) {
	    return this.contains(((Integer) o).intValue());
	}

	/**
	 * Checks whether this collection contains all elements from the given
	 * type-specific collection.
	 *
	 * @param c a type-specific collection.
	 * @return <code>true</code> if this collection contains all elements of the
	 *         argument.
	 */
	@Override
	public boolean containsAll(final Collection<?> c) {
	    final Iterator<?> i = c.iterator();
	    int n = c.size();
	    while (n-- != 0) {
		if (!this.contains(i.next())) {
		    return false;
		}
	    }
	    return true;
	}

	/**
	 * Retains in this collection only elements from the given type-specific
	 * collection.
	 *
	 * @param c a type-specific collection.
	 * @return <code>true</code> if this collection changed as a result of the call.
	 */
	@Override
	public boolean retainAll(final Collection<?> c) {
	    boolean retVal = false;
	    int n = this.size();
	    final Iterator<?> i = this.iterator();
	    while (n-- != 0) {
		if (!c.contains(i.next())) {
		    i.remove();
		    retVal = true;
		}
	    }
	    return retVal;
	}

	/**
	 * Remove from this collection all elements in the given type-specific
	 * collection.
	 *
	 * @param c a type-specific collection.
	 * @return <code>true</code> if this collection changed as a result of the call.
	 */
	@Override
	public boolean removeAll(final Collection<?> c) {
	    boolean retVal = false;
	    int n = c.size();
	    final Iterator<?> i = c.iterator();
	    while (n-- != 0) {
		if (this.remove(i.next())) {
		    retVal = true;
		}
	    }
	    return retVal;
	}

	@Override
	public Object[] toArray() {
	    final Object[] a = new Object[this.size()];
	    IntDoubleOrderedMap.objectUnwrap(this.iterator(), a);
	    return a;
	}

	@Override
	@SuppressWarnings("unchecked")
	public <T> T[] toArray(final T[] a) {
	    IntDoubleOrderedMap.objectUnwrap(this.iterator(), a);
	    return a;
	}

	/**
	 * Adds all elements of the given collection to this collection.
	 *
	 * @param c a collection.
	 * @return <code>true</code> if this collection changed as a result of the call.
	 */
	@Override
	public boolean addAll(final Collection<? extends Integer> c) {
	    boolean retVal = false;
	    final Iterator<? extends Integer> i = c.iterator();
	    int n = c.size();
	    while (n-- != 0) {
		if (this.add(i.next())) {
		    retVal = true;
		}
	    }
	    return retVal;
	}

	public boolean add(final int k) {
	    throw new UnsupportedOperationException();
	}

	/**
	 * Unwraps an iterator into an array starting at a given offset for a given
	 * number of elements.
	 * <p>
	 * <P>
	 * This method iterates over the given type-specific iterator and stores the
	 * elements returned, up to a maximum of <code>length</code>, in the given array
	 * starting at <code>offset</code>. The number of actually unwrapped elements is
	 * returned (it may be less than <code>max</code> if the iterator emits less
	 * than <code>max</code> elements).
	 *
	 * @param i      a type-specific iterator.
	 * @param array  an array to contain the output of the iterator.
	 * @param offset the first element of the array to be returned.
	 * @param max    the maximum number of elements to unwrap.
	 * @return the number of elements unwrapped.
	 */
	public int unwrap(final KeyIterator i, final int array[], int offset, final int max) {
	    if (max < 0) {
		throw new IllegalArgumentException("The maximum number of elements (" + max + ") is negative");
	    }
	    if (offset < 0 || offset + max > array.length) {
		throw new IllegalArgumentException();
	    }
	    int j = max;
	    while (j-- != 0 && i.hasNext()) {
		array[offset++] = i.nextInt();
	    }
	    return max - j - 1;
	}

	/**
	 * Unwraps an iterator into an array.
	 * <p>
	 * <P>
	 * This method iterates over the given type-specific iterator and stores the
	 * elements returned in the given array. The iteration will stop when the
	 * iterator has no more elements or when the end of the array has been reached.
	 *
	 * @param i     a type-specific iterator.
	 * @param array an array to contain the output of the iterator.
	 * @return the number of elements unwrapped.
	 */
	public int unwrap(final KeyIterator i, final int array[]) {
	    return this.unwrap(i, array, 0, array.length);
	}

	@Override
	public boolean isEmpty() {
	    return this.size() == 0;
	}

	@Override
	public String toString() {
	    final StringBuilder s = new StringBuilder();
	    final KeyIterator i = this.iterator();
	    int n = this.size();
	    int k;
	    boolean first = true;
	    s.append("{");
	    while (n-- != 0) {
		if (first) {
		    first = false;
		} else {
		    s.append(", ");
		}
		k = i.nextInt();
		s.append(String.valueOf(k));
	    }
	    s.append("}");
	    return s.toString();
	}
    }

    @Override
    public KeySet keySet() {
	if (this.keys == null) {
	    this.keys = new KeySet();
	}
	return this.keys;
    }

    /**
     * An iterator on values.
     * <p>
     * <P>
     * We simply override the
     * {@link java.util.ListIterator#next()}/{@link java.util.ListIterator#previous()}
     * methods (and possibly their type-specific counterparts) so that they return
     * values instead of entries.
     */
    public final class DoubleIterator extends MapIterator implements ListIterator<Double> {
	public double previousDouble() {
	    return IntDoubleOrderedMap.this.value[this.previousEntry()];
	}

	@Override
	public Double previous() {
	    return IntDoubleOrderedMap.this.value[this.previousEntry()];
	}

	@Override
	public void set(final Double ok) {
	    throw new UnsupportedOperationException();
	}

	@Override
	public void add(final Double ok) {
	    throw new UnsupportedOperationException();
	}

	public void set(final double v) {
	    throw new UnsupportedOperationException();
	}

	public void add(final double v) {
	    throw new UnsupportedOperationException();
	}

	public DoubleIterator() {
	    super();
	}

	public double nextDouble() {
	    return IntDoubleOrderedMap.this.value[this.nextEntry()];
	}

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated Please use the corresponding type-specific method instead.
	 */
	@Override
	@Deprecated
	public Double next() {
	    return IntDoubleOrderedMap.this.value[this.nextEntry()];
	}
    }

    @Override
    public DoubleCollection values() {
	if (this.values == null) {
	    this.values = new DoubleCollection();
	}
	return this.values;
    }

    /**
     * A no-op for backward compatibility. The kind of tables implemented by this
     * class never need rehashing.
     * <p>
     * <P>
     * If you need to reduce the table size to fit exactly this set, use
     * {@link #trim()}.
     *
     * @return true.
     * @see #trim()
     * @deprecated A no-op.
     */
    @Deprecated
    public boolean rehash() {
	return true;
    }

    /**
     * Rehashes the map, making the table as small as possible.
     * <p>
     * <P>
     * This method rehashes the table to the smallest size satisfying the load
     * factor. It can be used when the set will not be changed anymore, so to
     * optimize access speed and size.
     * <p>
     * <P>
     * If the table size is already the minimum possible, this method does nothing.
     *
     * @return true if there was enough memory to trim the map.
     * @see #trim(int)
     */
    public boolean trim() {
	final int l = IntDoubleOrderedMap.arraySize(this.size, this.f);
	if (l >= this.n || this.size > IntDoubleOrderedMap.maxFill(l, this.f)) {
	    return true;
	}
	try {
	    this.rehash(l);
	} catch (final Exception cantDoIt) {
	    return false;
	}
	return true;
    }

    /**
     * Rehashes this map if the table is too large.
     * <p>
     * <P>
     * Let <var>N</var> be the smallest table size that can hold
     * <code>max(n,{@link #size()})</code> entries, still satisfying the load
     * factor. If the current table size is smaller than or equal to <var>N</var>,
     * this method does nothing. Otherwise, it rehashes this map in a table of size
     * <var>N</var>.
     * <p>
     * <P>
     * This method is useful when reusing maps. {@linkplain #clear() Clearing a map}
     * leaves the table size untouched. If you are reusing a map many times, you can
     * call this method with a typical size to avoid keeping around a very large
     * table just because of a few large transient maps.
     *
     * @param n the threshold for the trimming.
     * @return true if there was enough memory to trim the map.
     * @see #trim()
     */
    public boolean trim(final int n) {
	final int l = HashCommon.nextPowerOfTwo((int) Math.ceil(n / this.f));
	if (l >= n || this.size > IntDoubleOrderedMap.maxFill(l, this.f)) {
	    return true;
	}
	try {
	    this.rehash(l);
	} catch (final Exception cantDoIt) {
	    return false;
	}
	return true;
    }

    /**
     * Rehashes the map.
     * <p>
     * <P>
     * This method implements the basic rehashing strategy, and may be overriden by
     * subclasses implementing different rehashing strategies (e.g., disk-based
     * rehashing). However, you should not override this method unless you
     * understand the internal workings of this class.
     *
     * @param newN the new size
     */
    protected void rehash(final int newN) {
	final int key[] = this.key;
	final double value[] = this.value;
	final int mask = newN - 1; // Note that this is used by the hashing macro
	final int newKey[] = new int[newN + 1];
	final double newValue[] = new double[newN + 1];
	int i = this.first, prev = -1, newPrev = -1, t, pos;
	final long link[] = this.link;
	final long newLink[] = new long[newN + 1];
	this.first = -1;
	for (int j = this.size; j-- != 0;) {
	    if (key[i] == 0) {
		pos = newN;
	    } else {
		pos = HashCommon.mix(key[i]) & mask;
		while (!(newKey[pos] == 0)) {
		    pos = pos + 1 & mask;
		}
	    }
	    newKey[pos] = key[i];
	    newValue[pos] = value[i];
	    if (prev != -1) {
		newLink[newPrev] ^= (newLink[newPrev] ^ pos & 0xFFFFFFFFL) & 0xFFFFFFFFL;
		newLink[pos] ^= (newLink[pos] ^ (newPrev & 0xFFFFFFFFL) << 32) & 0xFFFFFFFF00000000L;
		newPrev = pos;
	    } else {
		newPrev = this.first = pos;
		// Special case of SET(newLink[ pos ], -1, -1);
		newLink[pos] = -1L;
	    }
	    t = i;
	    i = (int) link[i];
	    prev = t;
	}
	this.link = newLink;
	this.last = newPrev;
	if (newPrev != -1) {
	    // Special case of SET_NEXT( newLink[ newPrev ], -1 );
	    newLink[newPrev] |= 0xFFFFFFFFL;
	}
	this.n = newN;
	this.mask = mask;
	this.maxFill = IntDoubleOrderedMap.maxFill(this.n, this.f);
	this.key = newKey;
	this.value = newValue;
    }

    /**
     * Returns a deep copy of this map.
     * <p>
     * <P>
     * This method performs a deep copy of this hash map; the data stored in the
     * map, however, is not cloned. Note that this makes a difference only for
     * object keys.
     *
     * @return a deep copy of this map.
     */
    @Override
    public IntDoubleOrderedMap clone() {
	return new IntDoubleOrderedMap(this);
    }

    /**
     * Returns a hash code for this map.
     *
     * @return a hash code for this map.
     */
    @Override
    public int hashCode() {
	int h = 0;
	for (int j = this.realSize(), i = 0, t = 0; j-- != 0;) {
	    while (this.key[i] == 0) {
		i++;
	    }
	    t = this.key[i];
	    t ^= NumberTools.doubleToMixedIntBits(this.value[i]);
	    h += t;
	    i++;
	}
	// Zero / null keys have hash zero.
	if (this.containsNullKey) {
	    h += NumberTools.doubleToMixedIntBits(this.value[this.n]);
	}
	return h;
    }

    @Override
    public boolean equals(final Object o) {
	if (o == this) {
	    return true;
	}
	if (!(o instanceof Map)) {
	    return false;
	}
	final Map<?, ?> m = (Map<?, ?>) o;
	if (m.size() != this.size()) {
	    return false;
	}
	return this.mapEntrySet().containsAll(m.entrySet());
    }

    /**
     * Delegates to the corresponding type-specific method.
     *
     * @deprecated Please use the corresponding type-specific method instead.
     */
    @Override
    @Deprecated
    public Integer firstKey() {
	return this.firstIntKey();
    }

    /**
     * Delegates to the corresponding type-specific method.
     *
     * @deprecated Please use the corresponding type-specific method instead.
     */
    @Override
    @Deprecated
    public Integer lastKey() {
	return this.lastIntKey();
    }

    /**
     * Returns the maximum number of entries that can be filled before rehashing.
     *
     * @param n the size of the backing array.
     * @param f the load factor.
     * @return the maximum number of entries before rehashing.
     */
    public static int maxFill(final int n, final float f) {
	/*
	 * We must guarantee that there is always at least one free entry (even with
	 * pathological load factors).
	 */
	return Math.min((int) Math.ceil(n * f), n - 1);
    }

    /**
     * Returns the maximum number of entries that can be filled before rehashing.
     *
     * @param n the size of the backing array.
     * @param f the load factor.
     * @return the maximum number of entries before rehashing.
     */
    public static long maxFill(final long n, final float f) {
	/*
	 * We must guarantee that there is always at least one free entry (even with
	 * pathological load factors).
	 */
	return Math.min((long) Math.ceil(n * f), n - 1);
    }

    /**
     * Returns the least power of two smaller than or equal to 2<sup>30</sup> and
     * larger than or equal to <code>Math.ceil( expected / f )</code>.
     *
     * @param expected the expected number of elements in a hash table.
     * @param f        the load factor.
     * @return the minimum possible size for a backing array.
     * @throws IllegalArgumentException if the necessary size is larger than
     *                                  2<sup>30</sup>.
     */
    public static int arraySize(final int expected, final float f) {
	final long s = Math.max(2, HashCommon.nextPowerOfTwo((long) Math.ceil(expected / f)));
	if (s > 1 << 30) {
	    throw new IllegalArgumentException(
		    "Too large (" + expected + " expected elements with load factor " + f + ")");
	}
	return (int) s;
    }

    public class DoubleCollection implements Collection<Double> {
	public double[] toArray(final double a[]) {
	    return this.toDoubleArray(a);
	}

	public double[] toDoubleArray() {
	    return this.toDoubleArray(null);
	}

	public double[] toDoubleArray(double a[]) {
	    if (a == null || a.length < this.size()) {
		a = new double[this.size()];
	    }
	    IntDoubleOrderedMap.unwrap(this.iterator(), a);
	    return a;
	}

	/**
	 * Adds all elements of the given type-specific collection to this collection.
	 *
	 * @param c a type-specific collection.
	 * @return <code>true</code> if this collection changed as a result of the call.
	 */
	public boolean addAll(final DoubleCollection c) {
	    boolean retVal = false;
	    final DoubleIterator i = c.iterator();
	    int n = c.size();
	    while (n-- != 0) {
		if (this.add(i.nextDouble())) {
		    retVal = true;
		}
	    }
	    return retVal;
	}

	/**
	 * Checks whether this collection contains all elements from the given
	 * type-specific collection.
	 *
	 * @param c a type-specific collection.
	 * @return <code>true</code> if this collection contains all elements of the
	 *         argument.
	 */
	public boolean containsAll(final DoubleCollection c) {
	    final DoubleIterator i = c.iterator();
	    int n = c.size();
	    while (n-- != 0) {
		if (!this.contains(i.nextDouble())) {
		    return false;
		}
	    }
	    return true;
	}

	/**
	 * Retains in this collection only elements from the given type-specific
	 * collection.
	 *
	 * @param c a type-specific collection.
	 * @return <code>true</code> if this collection changed as a result of the call.
	 */
	public boolean retainAll(final DoubleCollection c) {
	    boolean retVal = false;
	    int n = this.size();
	    final DoubleIterator i = this.iterator();
	    while (n-- != 0) {
		if (!c.contains(i.nextDouble())) {
		    i.remove();
		    retVal = true;
		}
	    }
	    return retVal;
	}

	/**
	 * Remove from this collection all elements in the given type-specific
	 * collection.
	 *
	 * @param c a type-specific collection.
	 * @return <code>true</code> if this collection changed as a result of the call.
	 */
	public boolean removeAll(final DoubleCollection c) {
	    boolean retVal = false;
	    int n = c.size();
	    final DoubleIterator i = c.iterator();
	    while (n-- != 0) {
		if (this.rem(i.nextDouble())) {
		    retVal = true;
		}
	    }
	    return retVal;
	}

	@Override
	public Object[] toArray() {
	    final Object[] a = new Object[this.size()];
	    IntDoubleOrderedMap.objectUnwrap(this.iterator(), a);
	    return a;
	}

	@Override
	@SuppressWarnings("unchecked")
	public <T> T[] toArray(final T[] a) {
	    IntDoubleOrderedMap.objectUnwrap(this.iterator(), a);
	    return a;
	}

	/**
	 * Adds all elements of the given collection to this collection.
	 *
	 * @param c a collection.
	 * @return <code>true</code> if this collection changed as a result of the call.
	 */
	@Override
	public boolean addAll(final Collection<? extends Double> c) {
	    boolean retVal = false;
	    final Iterator<? extends Double> i = c.iterator();
	    int n = c.size();
	    while (n-- != 0) {
		if (this.add(i.next())) {
		    retVal = true;
		}
	    }
	    return retVal;
	}

	public boolean add(final double k) {
	    throw new UnsupportedOperationException();
	}

	/**
	 * Delegates to the type-specific <code>rem()</code> method.
	 */
	@Override
	public boolean remove(final Object ok) {
	    return this.rem(((Double) ok).doubleValue());
	}

	/**
	 * Delegates to the corresponding type-specific method.
	 */
	@Override
	public boolean add(final Double o) {
	    return this.add(o.doubleValue());
	}

	/**
	 * Delegates to the corresponding type-specific method.
	 */
	public boolean rem(final Object o) {
	    return this.rem(((Double) o).doubleValue());
	}

	/**
	 * Delegates to the corresponding type-specific method.
	 */
	@Override
	public boolean contains(final Object o) {
	    return this.contains(((Double) o).doubleValue());
	}

	public boolean rem(final double k) {
	    final DoubleIterator iterator = this.iterator();
	    while (iterator.hasNext()) {
		if (k == iterator.nextDouble()) {
		    iterator.remove();
		    return true;
		}
	    }
	    return false;
	}

	/**
	 * Checks whether this collection contains all elements from the given
	 * collection.
	 *
	 * @param c a collection.
	 * @return <code>true</code> if this collection contains all elements of the
	 *         argument.
	 */
	@Override
	public boolean containsAll(final Collection<?> c) {
	    int n = c.size();
	    final Iterator<?> i = c.iterator();
	    while (n-- != 0) {
		if (!this.contains(i.next())) {
		    return false;
		}
	    }
	    return true;
	}

	/**
	 * Retains in this collection only elements from the given collection.
	 *
	 * @param c a collection.
	 * @return <code>true</code> if this collection changed as a result of the call.
	 */
	@Override
	public boolean retainAll(final Collection<?> c) {
	    boolean retVal = false;
	    int n = this.size();
	    final Iterator<?> i = this.iterator();
	    while (n-- != 0) {
		if (!c.contains(i.next())) {
		    i.remove();
		    retVal = true;
		}
	    }
	    return retVal;
	}

	/**
	 * Remove from this collection all elements in the given collection. If the
	 * collection is an instance of this class, it uses faster iterators.
	 *
	 * @param c a collection.
	 * @return <code>true</code> if this collection changed as a result of the call.
	 */
	@Override
	public boolean removeAll(final Collection<?> c) {
	    boolean retVal = false;
	    int n = c.size();
	    final Iterator<?> i = c.iterator();
	    while (n-- != 0) {
		if (this.remove(i.next())) {
		    retVal = true;
		}
	    }
	    return retVal;
	}

	@Override
	public boolean isEmpty() {
	    return this.size() == 0;
	}

	@Override
	public String toString() {
	    final StringBuilder s = new StringBuilder();
	    final DoubleIterator i = this.iterator();
	    int n = this.size();
	    double k;
	    boolean first = true;
	    s.append("{");
	    while (n-- != 0) {
		if (first) {
		    first = false;
		} else {
		    s.append(", ");
		}
		k = i.nextDouble();
		s.append(String.valueOf(k));
	    }
	    s.append("}");
	    return s.toString();
	}

	@Override
	public DoubleIterator iterator() {
	    return new DoubleIterator();
	}

	@Override
	public int size() {
	    return IntDoubleOrderedMap.this.size;
	}

	public boolean contains(final double v) {
	    return IntDoubleOrderedMap.this.containsValue(v);
	}

	@Override
	public void clear() {
	    IntDoubleOrderedMap.this.clear();
	}

	public double sum() {
	    final DoubleIterator i = this.iterator();
	    int j = 0;
	    while (i.hasNext()) {
		j += i.nextDouble();
	    }
	    return j;
	}
    }

    @Override
    public boolean containsValue(final Object ov) {
	return this.containsValue(((Double) ov).doubleValue());
    }

    /**
     * Unwraps an iterator into an array starting at a given offset for a given
     * number of elements.
     * <p>
     * <P>
     * This method iterates over the given type-specific iterator and stores the
     * elements returned, up to a maximum of <code>length</code>, in the given array
     * starting at <code>offset</code>. The number of actually unwrapped elements is
     * returned (it may be less than <code>max</code> if the iterator emits less
     * than <code>max</code> elements).
     *
     * @param i      a type-specific iterator.
     * @param array  an array to contain the output of the iterator.
     * @param offset the first element of the array to be returned.
     * @param max    the maximum number of elements to unwrap.
     * @return the number of elements unwrapped.
     */
    private static int unwrap(final DoubleIterator i, final double array[], int offset, final int max) {
	if (max < 0) {
	    throw new IllegalArgumentException("The maximum number of elements (" + max + ") is negative");
	}
	if (offset < 0 || offset + max > array.length) {
	    throw new IllegalArgumentException();
	}
	int j = max;
	while (j-- != 0 && i.hasNext()) {
	    array[offset++] = i.nextDouble();
	}
	return max - j - 1;
    }

    /**
     * Unwraps an iterator into an array.
     * <p>
     * <P>
     * This method iterates over the given type-specific iterator and stores the
     * elements returned in the given array. The iteration will stop when the
     * iterator has no more elements or when the end of the array has been reached.
     *
     * @param i     a type-specific iterator.
     * @param array an array to contain the output of the iterator.
     * @return the number of elements unwrapped.
     */
    private static int unwrap(final DoubleIterator i, final double array[]) {
	return IntDoubleOrderedMap.unwrap(i, array, 0, array.length);
    }

    /**
     * Unwraps an iterator into an array starting at a given offset for a given
     * number of elements.
     *
     * <P>
     * This method iterates over the given type-specific iterator and stores the
     * elements returned, up to a maximum of <code>length</code>, in the given array
     * starting at <code>offset</code>. The number of actually unwrapped elements is
     * returned (it may be less than <code>max</code> if the iterator emits less
     * than <code>max</code> elements).
     *
     * @param i      a type-specific iterator.
     * @param array  an array to contain the output of the iterator.
     * @param offset the first element of the array to be returned.
     * @param max    the maximum number of elements to unwrap.
     * @return the number of elements unwrapped.
     */
    public static <K> int objectUnwrap(final Iterator<? extends K> i, final K array[], int offset, final int max) {
	if (max < 0) {
	    throw new IllegalArgumentException("The maximum number of elements (" + max + ") is negative");
	}
	if (offset < 0 || offset + max > array.length) {
	    throw new IllegalArgumentException();
	}
	int j = max;
	while (j-- != 0 && i.hasNext()) {
	    array[offset++] = i.next();
	}
	return max - j - 1;
    }

    /**
     * Unwraps an iterator into an array.
     *
     * <P>
     * This method iterates over the given type-specific iterator and stores the
     * elements returned in the given array. The iteration will stop when the
     * iterator has no more elements or when the end of the array has been reached.
     *
     * @param i     a type-specific iterator.
     * @param array an array to contain the output of the iterator.
     * @return the number of elements unwrapped.
     */
    public static <K> int objectUnwrap(final Iterator<? extends K> i, final K array[]) {
	return IntDoubleOrderedMap.objectUnwrap(i, array, 0, array.length);
    }
}
