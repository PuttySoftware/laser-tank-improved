/*
 * Copyright (C) 2002-2015 Sebastiano Vigna
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package squidpony.squidmath;

import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.ListIterator;
import java.util.NoSuchElementException;
import java.util.SortedSet;

import squidpony.annotation.Beta;
import squidpony.annotation.GwtIncompatible;

/**
 * A generic linked hash set with with a fast implementation, originally from
 * fastutil as ObjectLinkedOpenHashSet but modified to support indexed access of
 * items, reordering, and optional hash strategies for array keys (which
 * fastutil does differently).
 * <p>
 * Instances of this class use a hash table to represent a set. The table is
 * filled up to a specified <em>load factor</em>, and then doubled in size to
 * accommodate new entries. If the table is emptied below <em>one fourth</em> of
 * the load factor, it is halved in size. However, halving is not performed when
 * deleting entries from an iterator, as it would interfere with the iteration
 * process.
 * </p>
 * <p>
 * Note that {@link #clear()} does not modify the hash table size. Rather, a
 * family of {@linkplain #trim() trimming methods} lets you control the size of
 * the table; this is particularly useful if you reuse instances of this class.
 * </p>
 * <p>
 * Iterators generated by this set will enumerate elements in the same order in
 * which they have been added to the set (addition of elements already present
 * in the set does not change the iteration order). Note that this order has
 * nothing in common with the natural order of the keys. The order is kept by
 * means of an array list, represented <i>via</i> an IntVLA parallel to the
 * table that can be modified with methods like {@link #shuffle(RNG)}.
 * </p>
 * <p>
 * This class implements the interface of a sorted set, so to allow easy access
 * of the iteration order: for instance, you can get the first element in
 * iteration order with {@code first()} without having to create an iterator;
 * however, this class partially violates the {@link SortedSet} contract because
 * all subset methods throw an exception and {@link #comparator()} returns
 * always <code>null</code>.
 * <p>
 * <p>
 * Additional methods, such as <code>addAndMoveToFirst()</code>, make it easy to
 * use instances of this class as a cache (e.g., with LRU policy).
 * </p>
 * <p>
 * This class allows approximately constant-time lookup of keys or values by
 * their index in the ordering, which can allow some novel usage of the data
 * structure. OrderedSet can be used like a list of unique elements, keeping
 * order like a list does but also allowing rapid checks for whether an item
 * exists in the OrderedSet, and {@link OrderedMap} can be used like that but
 * with values associated as well (where OrderedSet uses contains(), OrderedMap
 * uses containsKey()). You can also set the item at a position with
 * {@link #addAt(Object, Object, int)}, or alter an item while keeping index the
 * same with {@link #alter(Object, Object, Object, Object)}. Reordering works
 * here too, both with completely random orders from {@link #shuffle(RNG)} or
 * with a previously-generated ordering from {@link #reorder(int...)} (you can
 * produce such an ordering for a given size and reuse it across multiple
 * Ordered data structures with {@link RNG#randomOrdering(int)}).
 * </p>
 * <p>
 * You can pass an {@link CrossHash.IHasher} instance such as
 * {@link CrossHash#generalHasher} as an extra parameter to most of this class'
 * constructors, which allows the OrderedSet to use arrays (usually primitive
 * arrays) as items. If you expect only one type of array, you can use an
 * instance like {@link CrossHash#intHasher} to hash int arrays, or the
 * aforementioned generalHasher to hash most kinds of arrays (it can't handle
 * most multi-dimensional arrays well). If you aren't using array items, you
 * don't need to give an IHasher to the constructor and can ignore this feature.
 * </p>
 * <br>
 * Thank you, Sebastiano Vigna, for making FastUtil available to the public with
 * such high quality. <br>
 * See https://github.com/vigna/fastutil for the original library.
 *
 * @author Sebastiano Vigna (responsible for all the hard parts)
 * @author Tommy Ettinger (mostly responsible for squashing several layers of
 *         parent classes into one monster class)
 */
@Beta
public class TableSet<C, R> implements java.io.Serializable {
    private static final long serialVersionUID = 0L;
    /**
     * The array of column keys.
     */
    protected C[] cols;
    /**
     * The array of row keys.
     */
    protected R[] rows;
    /*
     * The array of values.
     */
    // protected V[] value;
    /**
     * The mask for wrapping a position counter.
     */
    protected int mask;
    /**
     * Whether this set contains the key zero.
     */
    protected boolean containsNull;
    /**
     * The index of the first entry in iteration order. It is valid iff
     * {@link #size} is nonzero; otherwise, it contains -1.
     */
    protected int first = -1;
    /**
     * The index of the last entry in iteration order. It is valid iff {@link #size}
     * is nonzero; otherwise, it contains -1.
     */
    protected int last = -1;
    /*
     * For each entry, the next and the previous entry in iteration order, stored as
     * <code>((prev & 0xFFFFFFFFL) << 32) | (next & 0xFFFFFFFFL)</code>. The first
     * entry contains predecessor -1, and the last entry contains successor -1.
     */
    // protected long[] link;
    protected IntVLA order;
    /**
     * The current table size.
     */
    protected int n;
    /**
     * Threshold after which we rehash. It must be the table size times {@link #f}.
     */
    protected int maxFill;
    /**
     * Number of entries in the set (including the key zero, if present).
     */
    protected int size;
    /**
     * The acceptable load factor.
     */
    public final float f;
    /**
     * The initial default size of a hash table.
     */
    public static final int DEFAULT_INITIAL_SIZE = 16;
    /**
     * The default load factor of a hash table.
     */
    public static final float DEFAULT_LOAD_FACTOR = .375f; // .1875f; // .75f;
    /**
     * The load factor for a (usually small) table that is meant to be particularly
     * fast.
     */
    public static final float FAST_LOAD_FACTOR = .5f;
    /**
     * The load factor for a (usually very small) table that is meant to be
     * extremely fast.
     */
    public static final float VERY_FAST_LOAD_FACTOR = .25f;
    protected CrossHash.IHasher columnHasher = CrossHash.defaultHasher, rowHasher = CrossHash.defaultHasher;

    /**
     * Creates a new hash map.
     * <p>
     * <p>
     * The actual table size will be the least power of two greater than
     * <code>expected</code>/<code>f</code>.
     *
     * @param expected the expected number of elements in the hash set.
     * @param f        the load factor.
     */
    @SuppressWarnings("unchecked")
    public TableSet(final int expected, final float f) {
	if (f <= 0 || f > 1) {
	    throw new IllegalArgumentException("Load factor must be greater than 0 and smaller than or equal to 1");
	}
	if (expected < 0) {
	    throw new IllegalArgumentException("The expected number of elements must be nonnegative");
	}
	this.f = f;
	this.n = TableSet.arraySize(expected, f);
	this.mask = this.n - 1;
	this.maxFill = TableSet.maxFill(this.n, f);
	this.cols = (C[]) new Object[this.n + 1];
	this.rows = (R[]) new Object[this.n + 1];
	// link = new long[n + 1];
	this.order = new IntVLA(expected);
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load factor.
     *
     * @param expected the expected number of elements in the hash set.
     */
    public TableSet(final int expected) {
	this(expected, TableSet.DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new hash set with initial expected {@link #DEFAULT_INITIAL_SIZE}
     * elements and {@link #DEFAULT_LOAD_FACTOR} as load factor.
     */
    public TableSet() {
	this(TableSet.DEFAULT_INITIAL_SIZE, TableSet.DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load factor
     * copying a given collection.
     *
     * @param t an existing (non-null) TableSet to be copied into the new TableSet.
     */
    public TableSet(final TableSet<? extends C, ? extends R> t) {
	this(t.size(), t.f);
	final int s = t.size();
	for (int i = 0; i < s; i++) {
	    this.add(this.columnAt(i), this.rowAt(i));
	}
    }

    /**
     * Creates a new hash set using elements provided by a type-specific iterator.
     *
     * @param c an iterator whose elements will fill the set's columns
     * @param r an iterator whose elements will fill the set's rows
     * @param f the load factor.
     */
    public TableSet(final Iterator<? extends C> c, final Iterator<? extends R> r, final float f) {
	this(TableSet.DEFAULT_INITIAL_SIZE, f);
	while (c.hasNext() && r.hasNext()) {
	    this.add(c.next(), r.next());
	}
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load factor using
     * elements provided by a type-specific iterator.
     *
     * @param c an iterator whose elements will fill the set's columns
     * @param r an iterator whose elements will fill the set's rows
     */
    public TableSet(final Iterator<? extends C> c, final Iterator<? extends R> r) {
	this(c, r, TableSet.DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new hash set and fills it with the elements of a given array.
     *
     * @param c        an array whose elements will be used to fill the set's
     *                 columns
     * @param offset_c the first element of r to use.
     * @param r        an array whose elements will be used to fill the set's rows
     * @param offset_r the first element of r to use.
     * @param length   the number of elements to use in total.
     * @param f        the load factor.
     */
    public TableSet(final C[] c, final int offset_c, final R[] r, final int offset_r, final int length, final float f) {
	this(length < 0 ? 0 : length, f);
	if (c == null || r == null) {
	    throw new NullPointerException("Array passed to TableSet constructor cannot be null");
	}
	if (offset_c < 0) {
	    throw new ArrayIndexOutOfBoundsException("Offset (" + offset_c + ") is negative");
	}
	if (offset_r < 0) {
	    throw new ArrayIndexOutOfBoundsException("Offset (" + offset_r + ") is negative");
	}
	if (length < 0) {
	    throw new IllegalArgumentException("Length (" + length + ") is negative");
	}
	if (offset_c + length > c.length) {
	    throw new ArrayIndexOutOfBoundsException(
		    "Last index (" + (offset_c + length) + ") is greater than array length (" + c.length + ")");
	}
	if (offset_r + length > r.length) {
	    throw new ArrayIndexOutOfBoundsException(
		    "Last index (" + (offset_r + length) + ") is greater than array length (" + r.length + ")");
	}
	for (int i = 0; i < length; i++) {
	    this.add(c[offset_c + i], r[offset_r + i]);
	}
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load factor and
     * fills it with the elements of a given array.
     *
     * @param c        an array whose elements will be used to fill the set's
     *                 columns
     * @param offset_c the first element of r to use.
     * @param r        an array whose elements will be used to fill the set's rows
     * @param offset_r the first element of r to use.
     * @param length   the number of elements to use in total.
     */
    public TableSet(final C[] c, final int offset_c, final R[] r, final int offset_r, final int length) {
	this(c, offset_c, r, offset_r, length, TableSet.DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new hash set copying the elements of an array.
     *
     * @param c an array to be copied into the new hash set's columns
     * @param r an array to be copied into the new hash set's rows
     * @param f the load factor.
     */
    public TableSet(final C[] c, final R[] r, final float f) {
	this(c, 0, r, 0, c.length, f);
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load factor
     * copying the elements of an array.
     *
     * @param c an array to be copied into the new hash set's columns
     * @param r an array to be copied into the new hash set's rows
     */
    public TableSet(final C[] c, final R[] r) {
	this(c, r, TableSet.DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new hash map.
     * <p>
     * <p>
     * The actual table size will be the least power of two greater than
     * <code>expected</code>/<code>f</code>.
     *
     * @param expected     the expected number of elements in the hash set.
     * @param f            the load factor.
     * @param columnHasher used to hash items; typically only needed when C is an
     *                     array, where CrossHash has implementations
     */
    @SuppressWarnings("unchecked")
    public TableSet(final int expected, final float f, final CrossHash.IHasher columnHasher,
	    final CrossHash.IHasher rowHasher) {
	if (f <= 0 || f > 1) {
	    throw new IllegalArgumentException("Load factor must be greater than 0 and smaller than or equal to 1");
	}
	if (expected < 0) {
	    throw new IllegalArgumentException("The expected number of elements must be nonnegative");
	}
	this.f = f;
	this.n = TableSet.arraySize(expected, f);
	this.mask = this.n - 1;
	this.maxFill = TableSet.maxFill(this.n, f);
	this.cols = (C[]) new Object[this.n + 1];
	this.rows = (R[]) new Object[this.n + 1];
	// link = new long[n + 1];
	this.order = new IntVLA(expected);
	this.columnHasher = columnHasher == null ? CrossHash.defaultHasher : columnHasher;
	this.rowHasher = rowHasher == null ? CrossHash.defaultHasher : rowHasher;
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load factor.
     *
     * @param columnHasher used to hash items for columns; typically only needed
     *                     when C is an array, where CrossHash has implementations
     * @param rowHasher    used to hash items for rows; typically only needed when C
     *                     is an array, where CrossHash has implementations
     */
    public TableSet(final CrossHash.IHasher columnHasher, final CrossHash.IHasher rowHasher) {
	this(TableSet.DEFAULT_INITIAL_SIZE, TableSet.DEFAULT_LOAD_FACTOR, columnHasher, rowHasher);
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load factor.
     *
     * @param columnHasher used to hash items for columns; typically only needed
     *                     when C is an array, where CrossHash has implementations
     * @param rowHasher    used to hash items for rows; typically only needed when C
     *                     is an array, where CrossHash has implementations
     */
    public TableSet(final int expected, final CrossHash.IHasher columnHasher, final CrossHash.IHasher rowHasher) {
	this(expected, TableSet.DEFAULT_LOAD_FACTOR, columnHasher, rowHasher);
    }

    /**
     * Creates a new hash set copying a given collection.
     *
     * @param c            a {@link Collection} to be copied into the new hash set.
     * @param f            the load factor.
     * @param columnHasher used to hash items; typically only needed when C is an
     *                     array, where CrossHash has implementations
     */
    public TableSet(final Collection<? extends C> c, final Collection<? extends R> r, final float f,
	    final CrossHash.IHasher columnHasher, final CrossHash.IHasher rowHasher) {
	this(c.size(), f, columnHasher, rowHasher);
	this.addAll(c, r);
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load factor
     * copying a given collection.
     *
     * @param c            a {@link Collection} to be copied into the new hash set.
     * @param columnHasher used to hash items; typically only needed when C is an
     *                     array, where CrossHash has implementations
     */
    public TableSet(final Collection<? extends C> c, final Collection<? extends R> r,
	    final CrossHash.IHasher columnHasher, final CrossHash.IHasher rowHasher) {
	this(c, r, TableSet.DEFAULT_LOAD_FACTOR, columnHasher, rowHasher);
    }

    /**
     * Creates a new hash set and fills it with the elements of a given array.
     *
     * @param c        an array whose elements will be used to fill the set's
     *                 columns
     * @param offset_c the first element of r to use.
     * @param r        an array whose elements will be used to fill the set's rows
     * @param offset_r the first element of r to use.
     * @param length   the number of elements to use in total.
     * @param f        the load factor.
     */
    public TableSet(final C[] c, final int offset_c, final R[] r, final int offset_r, final int length, final float f,
	    final CrossHash.IHasher columnHasher, final CrossHash.IHasher rowHasher) {
	this(length < 0 ? 0 : length, f, columnHasher, rowHasher);
	if (c == null || r == null) {
	    throw new NullPointerException("Array passed to TableSet constructor cannot be null");
	}
	if (offset_c < 0) {
	    throw new ArrayIndexOutOfBoundsException("Offset (" + offset_c + ") is negative");
	}
	if (offset_r < 0) {
	    throw new ArrayIndexOutOfBoundsException("Offset (" + offset_r + ") is negative");
	}
	if (length < 0) {
	    throw new IllegalArgumentException("Length (" + length + ") is negative");
	}
	if (offset_c + length > c.length) {
	    throw new ArrayIndexOutOfBoundsException(
		    "Last index (" + (offset_c + length) + ") is greater than array length (" + c.length + ")");
	}
	if (offset_r + length > r.length) {
	    throw new ArrayIndexOutOfBoundsException(
		    "Last index (" + (offset_r + length) + ") is greater than array length (" + r.length + ")");
	}
	for (int i = 0; i < length; i++) {
	    this.add(c[offset_c + i], r[offset_r + i]);
	}
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load factor and
     * fills it with the elements of a given array.
     *
     * @param c        an array whose elements will be used to fill the set's
     *                 columns
     * @param offset_c the first element of r to use.
     * @param r        an array whose elements will be used to fill the set's rows
     * @param offset_r the first element of r to use.
     * @param length   the number of elements to use in total.
     */
    public TableSet(final C[] c, final int offset_c, final R[] r, final int offset_r, final int length,
	    final CrossHash.IHasher columnHasher, final CrossHash.IHasher rowHasher) {
	this(c, offset_c, r, offset_r, length, TableSet.DEFAULT_LOAD_FACTOR, columnHasher, rowHasher);
    }

    /**
     * Creates a new hash set copying the elements of an array.
     *
     * @param c an array whose elements will be used to fill the set's columns
     * @param r an array whose elements will be used to fill the set's rows
     * @param f the load factor.
     */
    public TableSet(final C[] c, final R[] r, final float f, final CrossHash.IHasher columnHasher,
	    final CrossHash.IHasher rowHasher) {
	this(c, 0, r, 0, c.length, f, columnHasher, rowHasher);
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load factor
     * copying the elements of an array.
     *
     * @param c an array whose elements will be used to fill the set's columns
     * @param r an array whose elements will be used to fill the set's rows
     */
    public TableSet(final C[] c, final R[] r, final CrossHash.IHasher columnHasher, final CrossHash.IHasher rowHasher) {
	this(c, 0, r, 0, c.length, TableSet.DEFAULT_LOAD_FACTOR, columnHasher, rowHasher);
    }

    private void ensureCapacity(final int capacity) {
	final int needed = TableSet.arraySize(capacity, this.f);
	if (needed > this.n) {
	    this.rehash(needed);
	}
    }

    private void tryCapacity(final long capacity) {
	final int needed = (int) Math.min(1 << 30,
		Math.max(2, HashCommon.nextPowerOfTwo((long) Math.ceil(capacity / this.f))));
	if (needed > this.n) {
	    this.rehash(needed);
	}
    }

    public boolean addAll(final Collection<? extends C> c, final Collection<? extends R> r) {
	// The resulting collection will be at least c.size() big
	if (this.f <= .5) {
	    this.ensureCapacity(Math.min(c.size(), r.size())); // The resulting collection will be sized
	    // for c.size() elements
	} else {
	    this.tryCapacity(this.size() + Math.min(c.size(), r.size())); // The resulting collection will be
	}
	// tentatively sized for size() +
	// c.size() elements
	boolean retVal = false;
	final Iterator<? extends C> i = c.iterator();
	final Iterator<? extends R> j = r.iterator();
	int n = Math.min(c.size(), r.size());
	while (n-- != 0) {
	    if (this.add(i.next(), j.next())) {
		retVal = true;
	    }
	}
	return retVal;
    }

    public boolean add(final C c, final R r) {
	int pos;
	if (c == null && r == null) {
	    if (this.containsNull) {
		return false;
	    }
	    pos = this.n;
	    this.containsNull = true;
	} else {
	    C curr;
	    R rurr;
	    final C[] key = this.cols;
	    final R[] row = this.rows;
	    // The starting point.
	    if ((curr = key[pos = PintRNG.determine(this.columnHasher.hash(c), this.rowHasher.hash(r))
		    & this.mask]) != null && (rurr = row[pos]) != null) {
		if (this.columnHasher.areEqual(curr, c) && this.rowHasher.areEqual(rurr, r)) {
		    return false;
		}
		while ((curr = key[pos = pos + 1 & this.mask]) != null && (rurr = row[pos]) != null) {
		    if (this.columnHasher.areEqual(curr, c) && this.rowHasher.areEqual(rurr, r)) {
			return false;
		    }
		}
	    }
	    key[pos] = c;
	    row[pos] = r;
	}
	if (this.size == 0) {
	    this.first = this.last = pos;
	} else {
	    this.last = pos;
	}
	this.order.add(pos);
	if (this.size++ >= this.maxFill) {
	    this.rehash(TableSet.arraySize(this.size + 1, this.f));
	}
	return true;
    }

    public boolean addAt(final C c, final R r, int idx) {
	if (idx < 0) {
	    idx = 0;
	} else if (idx > this.size) {
	    idx = this.size;
	}
	int pos;
	if (c == null && r == null) {
	    if (this.containsNull) {
		return false;
	    }
	    pos = this.n;
	    this.containsNull = true;
	} else {
	    C curr;
	    R rurr;
	    final C[] key = this.cols;
	    final R[] row = this.rows;
	    // The starting point.
	    if ((curr = key[pos = PintRNG.determine(this.columnHasher.hash(c), this.rowHasher.hash(r))
		    & this.mask]) != null && (rurr = row[pos]) != null) {
		if (this.columnHasher.areEqual(curr, c) && this.rowHasher.areEqual(rurr, r)) {
		    return false;
		}
		while ((curr = key[pos = pos + 1 & this.mask]) != null && (rurr = row[pos]) != null) {
		    if (this.columnHasher.areEqual(curr, c) && this.rowHasher.areEqual(rurr, r)) {
			return false;
		    }
		}
	    }
	    key[pos] = c;
	    row[pos] = r;
	}
	if (idx == this.size) {
	    this.order.add(pos);
	    this.last = pos;
	} else {
	    this.order.insert(idx, pos);
	}
	if (idx == 0) {
	    this.first = pos;
	}
	if (this.size++ >= this.maxFill) {
	    this.rehash(TableSet.arraySize(this.size + 1, this.f));
	}
	return true;
    }

    /**
     * Shifts left entries with the specified hash code, starting at the specified
     * position, and empties the resulting free entry.
     *
     * @param pos a starting position.
     */
    protected final void shiftKeys(int pos) {
	// Shift entries with the same hash.
	int last, slot;
	C curr;
	R rurr;
	final C[] col = this.cols;
	final R[] row = this.rows;
	for (;;) {
	    pos = (last = pos) + 1 & this.mask;
	    for (;;) {
		if ((curr = col[pos]) == null || (rurr = row[pos]) == null) {
		    col[last] = null;
		    row[last] = null;
		    return;
		}
		slot = PintRNG.determine(this.columnHasher.hash(curr), this.rowHasher.hash(rurr)) & this.mask;
		if (last <= pos ? last >= slot || slot > pos : last >= slot && slot > pos) {
		    break;
		}
		pos = pos + 1 & this.mask;
	    }
	    col[last] = curr;
	    row[last] = rurr;
	    this.fixOrder(pos, last);
	}
    }

    private boolean removeEntry(final int pos) {
	this.size--;
	this.fixOrder(pos);
	this.shiftKeys(pos);
	if (this.size < this.maxFill / 4 && this.n > TableSet.DEFAULT_INITIAL_SIZE) {
	    this.rehash(this.n / 2);
	}
	return true;
    }

    private boolean removeNullEntry() {
	this.containsNull = false;
	this.cols[this.n] = null;
	this.rows[this.n] = null;
	this.size--;
	this.fixOrder(this.n);
	if (this.size < this.maxFill / 4 && this.n > TableSet.DEFAULT_INITIAL_SIZE) {
	    this.rehash(this.n / 2);
	}
	return true;
    }

    @SuppressWarnings("unchecked")
    public boolean remove(final Object c, final Object r) {
	if (c == null && r == null) {
	    return this.containsNull && this.removeNullEntry();
	}
	C curr;
	R rurr;
	final C[] col = this.cols;
	final R[] row = this.rows;
	int pos;
	// The starting point.
	if ((curr = col[pos = PintRNG.determine(this.columnHasher.hash(c), this.rowHasher.hash(r)) & this.mask]) == null
		|| (rurr = row[pos]) == null) {
	    return false;
	}
	if (this.columnHasher.areEqual(c, curr) && this.rowHasher.areEqual(r, rurr)) {
	    return this.removeEntry(pos);
	}
	while (true) {
	    if ((curr = col[pos = pos + 1 & this.mask]) == null || (rurr = row[pos]) == null) {
		return false;
	    }
	    if (this.columnHasher.areEqual(c, curr) && this.rowHasher.areEqual(r, rurr)) {
		return this.removeEntry(pos);
	    }
	}
    }

    public C column(final Object c, final Object r) {
	final int pos = this.positionOf(c, r);
	if (pos == -1 || pos >= this.size) {
	    return null;
	}
	return this.cols[pos];
    }

    public R row(final Object c, final Object r) {
	final int pos = this.positionOf(c, r);
	if (pos == -1 || pos >= this.size) {
	    return null;
	}
	return this.rows[pos];
    }

    public boolean contains(final Object c, final Object r) {
	if (c == null && r == null) {
	    return this.containsNull;
	}
	C curr;
	R rurr;
	final C[] col = this.cols;
	final R[] row = this.rows;
	int pos;
	// The starting point.
	if ((curr = col[pos = PintRNG.determine(this.columnHasher.hash(c), this.rowHasher.hash(r)) & this.mask]) == null
		|| (rurr = row[pos]) == null) {
	    return false;
	}
	if (this.columnHasher.areEqual(c, curr) && this.rowHasher.areEqual(r, rurr)) {
	    return true;
	}
	// There's always an unused entry.
	while (true) {
	    if ((curr = col[pos = pos + 1 & this.mask]) == null || (rurr = row[pos]) == null) {
		return false;
	    }
	    if (this.columnHasher.areEqual(c, curr) && this.rowHasher.areEqual(r, rurr)) {
		return true;
	    }
	}
    }

    protected int positionOf(final Object c, final Object r) {
	if (c == null && r == null) {
	    return this.containsNull ? this.n : -1;
	}
	C curr;
	R rurr;
	final C[] col = this.cols;
	final R[] row = this.rows;
	int pos;
	// The starting point.
	if ((curr = col[pos = PintRNG.determine(this.columnHasher.hash(c), this.rowHasher.hash(r)) & this.mask]) == null
		|| (rurr = row[pos]) == null) {
	    return -1;
	}
	if (this.columnHasher.areEqual(c, curr) && this.rowHasher.areEqual(r, rurr)) {
	    return pos;
	}
	// There's always an unused entry.
	while (true) {
	    if ((curr = col[pos = pos + 1 & this.mask]) == null || (rurr = row[pos]) == null) {
		return -1;
	    }
	    if (this.columnHasher.areEqual(c, curr) && this.rowHasher.areEqual(r, rurr)) {
		return pos;
	    }
	}
    }

    /*
     * Removes all elements from this set.
     *
     * <P>To increase object reuse, this method does not change the table size. If
     * you want to reduce the table size, you must use {@link #trim()}.
     */
    public void clear() {
	if (this.size == 0) {
	    return;
	}
	this.size = 0;
	this.containsNull = false;
	Arrays.fill(this.cols, null);
	this.first = this.last = -1;
	this.order.clear();
    }

    public int size() {
	return this.size;
    }

    /**
     * Checks whether this collection contains all elements from the given
     * collection.
     *
     * @param c a collection.
     * @return <code>true</code> if this collection contains all elements of the
     *         argument.
     */
    public boolean containsAll(final Collection<?> c, final Collection<?> r) {
	int n = Math.min(c.size(), r.size());
	final Iterator<?> i = c.iterator();
	final Iterator<?> j = r.iterator();
	while (n-- != 0) {
	    if (!this.contains(i.next(), j.next())) {
		return false;
	    }
	}
	return true;
    }

    /*
     * Retains in this collection only elements from the given collection.
     *
     * @param c a collection.
     *
     * @return <code>true</code> if this collection changed as a result of the call.
     * / public boolean retainAll(Collection<?> c, Collection<?> r) { boolean retVal
     * = false; int n = size(); final Iterator<?> i = iterator(); while (n-- != 0) {
     * if (!c.contains(i.next())) { i.remove(); retVal = true; } } return retVal; }
     */
    /**
     * Remove from this collection all elements in the given collection. If the
     * collection is an instance of this class, it uses faster iterators.
     *
     * @param c a collection.
     * @return <code>true</code> if this collection changed as a result of the call.
     */
    public boolean removeAll(final Collection<?> c, final Collection<?> r) {
	boolean retVal = false;
	int n = Math.min(c.size(), r.size());
	final Iterator<?> i = c.iterator();
	final Iterator<?> j = r.iterator();
	while (n-- != 0) {
	    if (this.remove(i.next(), j.next())) {
		retVal = true;
	    }
	}
	return retVal;
    }

    public boolean isEmpty() {
	return this.size() == 0;
    }

    /**
     * Modifies the link vector so that the given entry is removed. This method will
     * complete in logarithmic time.
     *
     * @param i the index of an entry.
     */
    protected int fixOrder(final int i) {
	if (this.size == 0) {
	    this.order.clear();
	    this.first = this.last = -1;
	    return 0;
	}
	final int idx = this.order.removeValue(i);
	if (this.first == i) {
	    this.first = this.order.get(0);
	}
	if (this.last == i) {
	    this.last = this.order.peek();
	}
	return idx;
    }

    /**
     * Modifies the ordering for a shift from s to d. <br>
     * This method will complete in logarithmic time or better.
     *
     * @param s the source position.
     * @param d the destination position.
     */
    protected void fixOrder(final int s, final int d) {
	if (this.size == 1) {
	    this.first = this.last = d;
	    this.order.set(0, d);
	} else if (this.first == s) {
	    this.first = d;
	    this.order.set(0, d);
	} else if (this.last == s) {
	    this.last = d;
	    this.order.set(this.order.size - 1, d);
	} else {
	    this.order.set(this.order.indexOf(s), d);
	}
    }

    /**
     * Returns the first element of this set in iteration order.
     *
     * @return the first element in iteration order.
     */
    public C first() {
	if (this.size == 0) {
	    throw new NoSuchElementException();
	}
	return this.cols[this.first];
    }

    /**
     * Returns the last element of this set in iteration order.
     *
     * @return the last element in iteration order.
     */
    public C last() {
	if (this.size == 0) {
	    throw new NoSuchElementException();
	}
	return this.cols[this.last];
    }

    public SortedSet<C> tailSet(final C from) {
	throw new UnsupportedOperationException();
    }

    public SortedSet<C> headSet(final C to) {
	throw new UnsupportedOperationException();
    }

    public SortedSet<C> subSet(final C from, final C to) {
	throw new UnsupportedOperationException();
    }

    public Comparator<? super C> comparator() {
	return null;
    }

    /**
     * A list iterator over a linked set.
     * <p>
     * <p>
     * This class provides a list iterator over a linked hash set. The constructor
     * runs in constant time.
     */
    private class SetIterator implements ListIterator<C> {
	/**
	 * The entry that will be returned by the next call to
	 * {@link ListIterator#previous()} (or <code>null</code> if no previous entry
	 * exists).
	 */
	int prev = -1;
	/**
	 * The entry that will be returned by the next call to
	 * {@link ListIterator#next()} (or <code>null</code> if no next entry exists).
	 */
	int next = -1;
	/**
	 * The last entry that was returned (or -1 if we did not iterate or used
	 * {@link #remove()}).
	 */
	int curr = -1;
	/**
	 * The current index (in the sense of a {@link ListIterator}). When -1, we do
	 * not know the current index.
	 */
	int index = -1;

	SetIterator() {
	    this.next = TableSet.this.first;
	    this.index = 0;
	}

	@Override
	public boolean hasNext() {
	    return this.next != -1;
	}

	@Override
	public boolean hasPrevious() {
	    return this.prev != -1;
	}

	@Override
	public C next() {
	    if (!this.hasNext()) {
		throw new NoSuchElementException();
	    }
	    this.curr = this.next;
	    if (++this.index >= TableSet.this.order.size) {
		this.next = -1;
	    } else {
		this.next = TableSet.this.order.get(this.index);// (int) link[curr];
	    }
	    this.prev = this.curr;
	    return TableSet.this.cols[this.curr];
	}

	@Override
	public C previous() {
	    if (!this.hasPrevious()) {
		throw new NoSuchElementException();
	    }
	    this.curr = this.prev;
	    if (--this.index < 1) {
		this.prev = -1;
	    } else {
		this.prev = TableSet.this.order.get(this.index - 1);
	    }
	    this.next = this.curr;
	    return TableSet.this.cols[this.curr];
	}

	private void ensureIndexKnown() {
	    if (this.index >= 0) {
		return;
	    }
	    if (this.prev == -1) {
		this.index = 0;
		return;
	    }
	    if (this.next == -1) {
		this.index = TableSet.this.size;
		return;
	    }
	    this.index = 0;
	}

	@Override
	public int nextIndex() {
	    this.ensureIndexKnown();
	    return this.index + 1;
	}

	@Override
	public int previousIndex() {
	    this.ensureIndexKnown();
	    return this.index - 1;
	}

	@Override
	public void remove() {
	    this.ensureIndexKnown();
	    if (this.curr == -1) {
		throw new IllegalStateException();
	    }
	    if (this.curr == this.prev) {
		/*
		 * If the last operation was a next(), we are removing an entry that precedes
		 * the current index, and thus we must decrement it.
		 */
		if (--this.index >= 1) {
		    this.prev = TableSet.this.order.get(this.index - 1); // (int) (link[curr] >>> 32);
		} else {
		    this.prev = -1;
		}
	    } else {
		if (this.index < TableSet.this.order.size - 1) {
		    this.next = TableSet.this.order.get(this.index + 1);
		} else {
		    this.next = -1;
		}
	    }
	    /*
	     * Now we manually fix the pointers. Because of our knowledge of next and prev,
	     * this is going to be faster than calling fixOrder().
	     */
	    if (this.prev == -1) {
		TableSet.this.first = this.next;
	    }
	    if (this.next == -1) {
		TableSet.this.last = this.prev;
	    }
	    TableSet.this.order.removeIndex(this.index);
	    TableSet.this.size--;
	    int last, slot, pos = this.curr;
	    this.curr = -1;
	    if (pos == TableSet.this.n) {
		TableSet.this.containsNull = false;
		TableSet.this.cols[TableSet.this.n] = null;
		// order.removeValue(pos);
	    } else {
		C curr;
		final C[] key = TableSet.this.cols;
		// We have to horribly duplicate the shiftKeys() code because we
		// need to update next/prev.
		for (;;) {
		    pos = (last = pos) + 1 & TableSet.this.mask;
		    for (;;) {
			if ((curr = key[pos]) == null) {
			    key[last] = null;
			    return;
			}
			slot = HashCommon.mix(TableSet.this.columnHasher.hash(curr)) & TableSet.this.mask;
			if (last <= pos ? last >= slot || slot > pos : last >= slot && slot > pos) {
			    break;
			}
			pos = pos + 1 & TableSet.this.mask;
		    }
		    key[last] = curr;
		    if (this.next == pos) {
			this.next = last;
		    }
		    if (this.prev == pos) {
			this.prev = last;
		    }
		    TableSet.this.fixOrder(pos, last);
		}
	    }
	}

	/**
	 * Replaces the last element returned by {@link #next} or {@link #previous} with
	 * the specified element (optional operation). This call can be made only if
	 * neither {@link #remove} nor {@link #add} have been called after the last call
	 * to {@code next} or {@code previous}.
	 *
	 * @param c the element with which to replace the last element returned by
	 *          {@code next} or {@code previous}
	 * @throws UnsupportedOperationException if the {@code set} operation is not
	 *                                       supported by this list iterator
	 * @throws ClassCastException            if the class of the specified element
	 *                                       prevents it from being added to this
	 *                                       list
	 * @throws IllegalArgumentException      if some aspect of the specified element
	 *                                       prevents it from being added to this
	 *                                       list
	 * @throws IllegalStateException         if neither {@code next} nor
	 *                                       {@code previous} have been called, or
	 *                                       {@code remove} or {@code add} have been
	 *                                       called after the last call to
	 *                                       {@code next} or {@code previous}
	 */
	@Override
	public void set(final C c) {
	    throw new UnsupportedOperationException("set() not supported on OrderedSet iterator");
	}

	/**
	 * Inserts the specified element into the list (optional operation). The element
	 * is inserted immediately before the element that would be returned by
	 * {@link #next}, if any, and after the element that would be returned by
	 * {@link #previous}, if any. (If the list contains no elements, the new element
	 * becomes the sole element on the list.) The new element is inserted before the
	 * implicit cursor: a subsequent call to {@code next} would be unaffected, and a
	 * subsequent call to {@code previous} would return the new element. (This call
	 * increases by one the value that would be returned by a call to
	 * {@code nextIndex} or {@code previousIndex}.)
	 *
	 * @param c the element to insert
	 * @throws UnsupportedOperationException if the {@code add} method is not
	 *                                       supported by this list iterator
	 * @throws ClassCastException            if the class of the specified element
	 *                                       prevents it from being added to this
	 *                                       list
	 * @throws IllegalArgumentException      if some aspect of this element prevents
	 *                                       it from being added to this list
	 */
	@Override
	public void add(final C c) {
	    throw new UnsupportedOperationException("add() not supported on OrderedSet iterator");
	}
    }

    public ListIterator<C> iterator() {
	return new SetIterator();
    }

    /**
     * A no-op for backward compatibility. The kind of tables implemented by this
     * class never need rehashing.
     * <p>
     * <P>
     * If you need to reduce the table size to fit exactly this set, use
     * {@link #trim()}.
     *
     * @return true.
     * @see #trim()
     * @deprecated A no-op.
     */
    @Deprecated
    public boolean rehash() {
	return true;
    }

    /**
     * Rehashes the map, making the table as small as possible.
     * <p>
     * <P>
     * This method rehashes the table to the smallest size satisfying the load
     * factor. It can be used when the set will not be changed anymore, so to
     * optimize access speed and size.
     * <p>
     * <P>
     * If the table size is already the minimum possible, this method does nothing.
     *
     * @return true if there was enough memory to trim the map.
     * @see #trim(int)
     */
    public boolean trim() {
	final int l = TableSet.arraySize(this.size, this.f);
	if (l >= this.n || this.size > TableSet.maxFill(l, this.f)) {
	    return true;
	}
	try {
	    this.rehash(l);
	} catch (final Exception cantDoIt) {
	    return false;
	}
	return true;
    }

    /**
     * Rehashes this map if the table is too large.
     * <p>
     * <P>
     * Let <var>N</var> be the smallest table size that can hold
     * <code>max(n,{@link #size()})</code> entries, still satisfying the load
     * factor. If the current table size is smaller than or equal to <var>N</var>,
     * this method does nothing. Otherwise, it rehashes this map in a table of size
     * <var>N</var>.
     * <p>
     * <P>
     * This method is useful when reusing maps. {@linkplain #clear() Clearing a map}
     * leaves the table size untouched. If you are reusing a map many times, you can
     * call this method with a typical size to avoid keeping around a very large
     * table just because of a few large transient maps.
     *
     * @param n the threshold for the trimming.
     * @return true if there was enough memory to trim the map.
     * @see #trim()
     */
    public boolean trim(final int n) {
	final int l = HashCommon.nextPowerOfTwo((int) Math.ceil(n / this.f));
	if (l >= n || this.size > TableSet.maxFill(l, this.f)) {
	    return true;
	}
	try {
	    this.rehash(l);
	} catch (final Exception cantDoIt) {
	    return false;
	}
	return true;
    }

    /**
     * Rehashes the map.
     * <p>
     * <p>
     * This method implements the basic rehashing strategy, and may be overriden by
     * subclasses implementing different rehashing strategies (e.g., disk-based
     * rehashing). However, you should not override this method unless you
     * understand the internal workings of this class.
     *
     * @param newN the new size
     */
    @SuppressWarnings("unchecked")
    protected void rehash(final int newN) {
	final C col[] = this.cols, newCol[] = (C[]) new Object[newN + 1];
	final R row[] = this.rows, newRow[] = (R[]) new Object[newN + 1];
	final int mask = newN - 1;
	int i, pos;
	final int sz = this.order.size, originalFirst = this.first, originalLast = this.last;
	for (int q = 0; q < sz; q++) {
	    i = this.order.get(q);
	    if (col[i] == null) {
		pos = newN;
	    } else {
		pos = PintRNG.determine(this.columnHasher.hash(col[i]), this.rowHasher.hash(row[i])) & mask;
		while (!(newCol[pos] == null)) {
		    pos = pos + 1 & mask;
		}
	    }
	    newCol[pos] = col[i];
	    newRow[pos] = row[i];
	    this.order.set(q, pos);
	    if (i == originalFirst) {
		this.first = pos;
	    }
	    if (i == originalLast) {
		this.last = pos;
	    }
	}
	this.n = newN;
	this.mask = mask;
	this.maxFill = TableSet.maxFill(this.n, this.f);
	this.cols = newCol;
	this.rows = newRow;
    }
    /*
     * @SuppressWarnings("unchecked") protected void rehash(final int newN) { final
     * C key[] = this.key; final V value[] = this.value; final int mask = newN - 1;
     * // Note that this is used by the hashing // macro final C newKey[] = (C[])
     * new Object[newN + 1]; final V newValue[] = (V[]) new Object[newN + 1]; int i
     * = first, prev = -1, newPrev = -1, t, pos; final long link[] = this.link;
     * final long newLink[] = new long[newN + 1]; first = -1; for (int j = size; j--
     * != 0;) { if (((key[i]) == null)) pos = newN; else { pos =
     * (HashCommon.mix((key[i]).hashCode())) & mask; while (!((newKey[pos]) ==
     * null)) pos = (pos + 1) & mask; } newKey[pos] = key[i]; newValue[pos] =
     * value[i]; if (prev != -1) { newLink[newPrev] ^= ((newLink[newPrev] ^ (pos &
     * 0xFFFFFFFFL)) & 0xFFFFFFFFL); newLink[pos] ^= ((newLink[pos] ^ ((newPrev &
     * 0xFFFFFFFFL) << 32)) & 0xFFFFFFFF00000000L); newPrev = pos; } else { newPrev
     * = first = pos; // Special case of SET(newLink[ pos ], -1, -1); newLink[pos] =
     * -1L; } t = i; i = (int) link[i]; prev = t; } this.link = newLink; this.last =
     * newPrev; if (newPrev != -1) // Special case of SET_NEXT( newLink[ newPrev ],
     * -1 ); newLink[newPrev] |= -1 & 0xFFFFFFFFL; n = newN; this.mask = mask;
     * maxFill = maxFill(n, f); this.key = newKey; this.value = newValue; }
     */

    @Override
    public int hashCode() {
	return CrossHash.Wisp.hash(this.cols) * 967 + CrossHash.Wisp.hash(this.rows) * 31 + this.order.hashWisp();
    }

    /**
     * Returns the maximum number of entries that can be filled before rehashing.
     *
     * @param n the size of the backing array.
     * @param f the load factor.
     * @return the maximum number of entries before rehashing.
     */
    public static int maxFill(final int n, final float f) {
	/*
	 * We must guarantee that there is always at least one free entry (even with
	 * pathological load factors).
	 */
	return Math.min((int) Math.ceil(n * f), n - 1);
    }

    /**
     * Returns the maximum number of entries that can be filled before rehashing.
     *
     * @param n the size of the backing array.
     * @param f the load factor.
     * @return the maximum number of entries before rehashing.
     */
    public static long maxFill(final long n, final float f) {
	/*
	 * We must guarantee that there is always at least one free entry (even with
	 * pathological load factors).
	 */
	return Math.min((long) Math.ceil(n * f), n - 1);
    }

    /**
     * Returns the least power of two smaller than or equal to 2<sup>30</sup> and
     * larger than or equal to <code>Math.ceil( expected / f )</code>.
     *
     * @param expected the expected number of elements in a hash table.
     * @param f        the load factor.
     * @return the minimum possible size for a backing array.
     * @throws IllegalArgumentException if the necessary size is larger than
     *                                  2<sup>30</sup>.
     */
    public static int arraySize(final int expected, final float f) {
	final long s = Math.max(2, HashCommon.nextPowerOfTwo((long) Math.ceil(expected / f)));
	if (s > 1 << 30) {
	    throw new IllegalArgumentException(
		    "Too large (" + expected + " expected elements with load factor " + f + ")");
	}
	return (int) s;
    }

    @Override
    public String toString() {
	final StringBuilder s = new StringBuilder();
	final int n = this.size();
	int i = 0;
	boolean first = true;
	s.append("TableSet{");
	while (i < n) {
	    if (first) {
		first = false;
	    } else {
		s.append(", ");
	    }
	    s.append(this.columnAt(i)).append(" with ").append(this.rowAt(i++));
	}
	s.append("}");
	return s.toString();
    }

    @Override
    public boolean equals(final Object o) {
	if (o == this) {
	    return true;
	}
	if (!(o instanceof TableSet)) {
	    return false;
	}
	final TableSet<?, ?> s = (TableSet<?, ?>) o;
	if (s.size() != this.size || this.columnHasher != s.columnHasher || this.rowHasher != s.rowHasher) {
	    return false;
	}
	int p;
	for (int i = 0; i < this.size; i++) {
	    if (!this.columnHasher.areEqual(this.cols[p = this.order.get(i)], s.cols[p])
		    || !this.rowHasher.areEqual(this.rows[p], s.rows[p])) {
		return false;
	    }
	}
	return true;
    }

    @GwtIncompatible
    private void writeObject(final java.io.ObjectOutputStream s) throws java.io.IOException {
	final ListIterator<C> i = this.iterator();
	s.defaultWriteObject();
	s.writeObject(this.columnHasher);
	for (int j = this.size; j-- != 0;) {
	    s.writeObject(i.next());
	}
    }

    @GwtIncompatible
    @SuppressWarnings("unchecked")
    private void readObject(final java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException {
	s.defaultReadObject();
	this.columnHasher = (CrossHash.IHasher) s.readObject();
	this.n = TableSet.arraySize(this.size, this.f);
	this.maxFill = TableSet.maxFill(this.n, this.f);
	this.mask = this.n - 1;
	final C key[] = this.cols = (C[]) new Object[this.n + 1];
	final IntVLA order = this.order = new IntVLA(this.n + 1);
	this.first = this.last = -1;
	C c;
	for (int i = this.size, pos; i-- != 0;) {
	    c = (C) s.readObject();
	    if (c == null) {
		pos = this.n;
		this.containsNull = true;
	    } else {
		if (!(key[pos = HashCommon.mix(this.columnHasher.hash(c)) & this.mask] == null)) {
		    while (!(key[pos = pos + 1 & this.mask] == null)) {
		    }
		}
	    }
	    key[pos] = c;
	    if (this.first != -1) {
		this.last = pos;
	    } else {
		this.first = this.last = pos;
	    }
	    order.add(pos);
	}
    }

    /**
     * Gets the item at the given index in the iteration order in constant time
     * (random-access).
     *
     * @param idx the index in the iteration order of the key to fetch
     * @return the key at the index, if the index is valid, otherwise null
     */
    public C columnAt(final int idx) {
	if (idx < 0 || idx >= this.order.size) {
	    return null;
	}
	// The starting point.
	return this.cols[this.order.get(idx)];
    }

    /**
     * Gets the item at the given index in the iteration order in constant time
     * (random-access).
     *
     * @param idx the index in the iteration order of the key to fetch
     * @return the key at the index, if the index is valid, otherwise null
     */
    public R rowAt(final int idx) {
	if (idx < 0 || idx >= this.order.size) {
	    return null;
	}
	// The starting point.
	return this.rows[this.order.get(idx)];
    }

    /**
     * Removes the item at the given index in the iteration order in not-exactly
     * constant time (though it still should be efficient).
     *
     * @param idx the index in the iteration order of the item to remove
     * @return true if this Set was changed as a result of this call, or false if
     *         nothing changed.
     */
    public boolean removeAt(final int idx) {
	if (idx < 0 || idx >= this.order.size) {
	    throw new NoSuchElementException();
	}
	final int pos = this.order.get(idx);
	if (pos > this.n) {
	    return false;
	}
	if (this.cols[pos] == null && this.rows[pos] == null) {
	    if (this.containsNull) {
		return this.removeNullEntry();
	    }
	    return false;
	}
	return this.removeEntry(pos);
    }

    /**
     * Gets a random value from this OrderedSet in constant time, using the given
     * RNG to generate a random number.
     *
     * @param rng used to generate a random index for a value
     * @return a random value from this OrderedSet
     */
    public C randomColumn(final RNG rng) {
	return this.columnAt(rng.nextIntHasty(this.order.size));
    }

    /**
     * Gets a random value from this OrderedSet in constant time, using the given
     * RNG to generate a random number.
     *
     * @param rng used to generate a random index for a value
     * @return a random value from this OrderedSet
     */
    public R randomRow(final RNG rng) {
	return this.rowAt(rng.nextIntHasty(this.order.size));
    }

    /**
     * Randomly alters the iteration order for this OrderedSet using the given RNG
     * to shuffle.
     *
     * @param rng used to generate a random ordering
     * @return this for chaining
     */
    public TableSet<C, R> shuffle(final RNG rng) {
	if (this.size < 2 || rng == null) {
	    return this;
	}
	this.order.shuffle(rng);
	this.first = this.order.get(0);
	this.last = this.order.peek();
	return this;
    }

    /**
     * Given an array or varargs of replacement indices for this OrderedSet's
     * iteration order, reorders this so the first item in the returned version is
     * the same as {@code getAt(ordering[0])} (with some care taken for negative or
     * too-large indices), the second item in the returned version is the same as
     * {@code getAt(ordering[1])}, etc. <br>
     * Negative indices are considered reversed distances from the end of ordering,
     * so -1 refers to the same index as {@code ordering[ordering.length - 1]}. If
     * ordering is smaller than {@code size()}, only the indices up to the length of
     * ordering will be modified. If ordering is larger than {@code size()}, only as
     * many indices will be affected as {@code size()}, and reversed distances are
     * measured from the end of this Set's entries instead of the end of ordering.
     * Duplicate values in ordering will produce duplicate values in the returned
     * Set. <br>
     * This method modifies this OrderedSet in-place and also returns it for
     * chaining.
     *
     * @param ordering an array or varargs of int indices, where the nth item in
     *                 ordering changes the nth item in this Set to have the value
     *                 currently in this Set at the index specified by the value in
     *                 ordering
     * @return this for chaining, after modifying it in-place
     */
    public TableSet<C, R> reorder(final int... ordering) {
	this.order.reorder(ordering);
	this.first = this.order.get(0);
	this.last = this.order.peek();
	return this;
    }

    /*
     * public boolean alter(C original, C replacement) { if (original == null) { if
     * (containsNull) { return replacement != null && alterNullEntry(replacement); }
     * else return add(replacement); } else if(hasher.areEqual(original,
     * replacement)) return false; C curr; final C[] key = this.key; int pos; // The
     * starting point. if ((curr = key[pos = HashCommon.mix(hasher.hash(original)) &
     * mask]) == null) return add(replacement); if (hasher.areEqual(original, curr))
     * return alterEntry(pos, replacement); while (true) { if ((curr = key[pos =
     * (pos + 1) & mask]) == null) return add(replacement); if
     * (hasher.areEqual(original, curr)) return alterEntry(pos, replacement); } }
     */
    private int alterEntry(final int pos) {
	this.size--;
	final int idx = this.fixOrder(pos);
	this.shiftKeys(pos);
	if (this.size < this.maxFill / 4 && this.n > TableSet.DEFAULT_INITIAL_SIZE) {
	    this.rehash(this.n / 2);
	}
	return idx;
    }

    private int alterNullEntry() {
	this.containsNull = false;
	this.cols[this.n] = null;
	this.size--;
	final int idx = this.fixOrder(this.n);
	if (this.size < this.maxFill / 4 && this.n > TableSet.DEFAULT_INITIAL_SIZE) {
	    this.rehash(this.n / 2);
	}
	return idx;
    }

    /**
     * Changes a pair of C and R, originalC and originalR, to another pair,
     * replacementC and replacementR. Keeps the replacement at the same point in the
     * ordering.
     *
     * @param originalC    the column part of a pair that will be removed from this
     *                     TableSet if present, and its iteration index remembered
     * @param originalR    the row part of a pair that will be removed from this
     *                     TableSet if present, and its iteration index remembered
     * @param replacementC another column value that will replace originalC at the
     *                     remembered index
     * @param replacementR another row value that will replace originalR at the
     *                     remembered index
     * @return true if the Set changed, or false if it didn't (such as if the two
     *         arguments are equal, or replacement was already in the Set but
     *         original was not)
     */
    public boolean alter(final C originalC, final R originalR, final C replacementC, final R replacementR) {
	int idx;
	if (originalC == null && originalR == null) {
	    if (this.containsNull) {
		if (replacementC != null && replacementR != null) {
		    idx = this.alterNullEntry();
		    this.addAt(replacementC, replacementR, idx);
		    return true;
		} else {
		    return false;
		}
	    }
	    return false;
	}
	if (this.columnHasher.areEqual(originalC, replacementR) && this.rowHasher.areEqual(originalR, replacementR)) {
	    return false;
	}
	C curr;
	R rurr;
	final C[] col = this.cols;
	final R[] row = this.rows;
	int pos;
	// The starting point.
	if ((curr = col[pos = PintRNG.determine(this.columnHasher.hash(originalC), this.rowHasher.hash(originalR))
		& this.mask]) == null || (rurr = row[pos]) == null) {
	    return false;
	}
	if (this.columnHasher.areEqual(originalC, curr) && this.rowHasher.areEqual(originalR, rurr)) {
	    idx = this.alterEntry(pos);
	    this.addAt(replacementC, replacementR, idx);
	    return true;
	}
	while (true) {
	    if ((curr = col[pos = pos + 1 & this.mask]) == null || (rurr = row[pos]) == null) {
		return false;
	    }
	    if (this.columnHasher.areEqual(originalC, curr) && this.rowHasher.areEqual(originalR, rurr)) {
		idx = this.alterEntry(pos);
		this.addAt(replacementC, replacementR, idx);
		return true;
	    }
	}
    }
}
